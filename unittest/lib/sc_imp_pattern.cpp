//
// Pattern file for the SymCrypt implementations. Shared between static and dynamically linked
// SymCrypt implementations.
//
// Copyright (c) Microsoft Corporation. Licensed under the MIT license.
//

#define ALG_NAME   MD2
#define ALG_Name   Md2
#define ALG_name   md2
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   MD4
#define ALG_Name   Md4
#define ALG_name   md4
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   MD5
#define ALG_Name   Md5
#define ALG_name   md5
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA1
#define ALG_Name   Sha1
#define ALG_name   sha1
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA256
#define ALG_Name   Sha256
#define ALG_name   sha256
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA384
#define ALG_Name   Sha384
#define ALG_name   sha384
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA512
#define ALG_Name   Sha512
#define ALG_name   sha512
#define SYMCRYPT_HASH_MD_SHA
#include "sc_imp_hashpattern.cpp"
#undef SYMCRYPT_HASH_MD_SHA
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA3_256
#define ALG_Name   Sha3_256
#define ALG_name   sha3_256
#include "sc_imp_hashpattern.cpp"
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA3_384
#define ALG_Name   Sha3_384
#define ALG_name   sha3_384
#include "sc_imp_hashpattern.cpp"
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

#define ALG_NAME   SHA3_512
#define ALG_Name   Sha3_512
#define ALG_name   sha3_512
#include "sc_imp_hashpattern.cpp"
#undef ALG_NAME
#undef ALG_Name
#undef ALG_name

 #define ALG_NAME   SHAKE128
 #define ALG_Name   Shake128
 #define ALG_name   shake128
 #include "sc_imp_xofpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

 #define ALG_NAME   SHAKE256
 #define ALG_Name   Shake256
 #define ALG_name   shake256
 #include "sc_imp_xofpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

 #define ALG_NAME   CSHAKE128
 #define ALG_Name   CShake128
 #define ALG_name   cshake128
 #include "sc_imp_cxofpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

 #define ALG_NAME   CSHAKE256
 #define ALG_Name   CShake256
 #define ALG_name   cshake256
 #include "sc_imp_cxofpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

 #define ALG_NAME   KMAC128
 #define ALG_Name   Kmac128
 #define ALG_name   kmac128
 #include "sc_imp_kmacpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

 #define ALG_NAME   KMAC256
 #define ALG_Name   Kmac256
 #define ALG_name   kmac256
 #include "sc_imp_kmacpattern.cpp"
 #undef ALG_NAME
 #undef ALG_Name
 #undef ALG_name

#define ALG_NAME    HMAC_MD5
#define ALG_Name    HmacMd5
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA1
#define ALG_Name    HmacSha1
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA256
#define ALG_Name    HmacSha256
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA384
#define ALG_Name    HmacSha384
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA512
#define ALG_Name    HmacSha512
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA3_256
#define ALG_Name    HmacSha3_256
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA3_384
#define ALG_Name    HmacSha3_384
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HMAC_SHA3_512
#define ALG_Name    HmacSha3_512
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    AES_CMAC
#define ALG_Name    AesCmac
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    MARVIN32
#define ALG_Name    Marvin32
#include "sc_imp_macpattern.cpp"
#undef ALG_NAME
#undef ALG_Name


#define ALG_NAME    AES
#define ALG_Name    Aes

#define SymCryptBlockCipherXxx ScShimSymCryptAesBlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    DES
#define ALG_Name    Des

#define SymCryptBlockCipherXxx ScShimSymCryptDesBlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    2DES
#define ALG_Name    2Des

#define SymCryptBlockCipherXxx ScShimSymCrypt3DesBlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    3DES
#define ALG_Name    3Des

#define SymCryptBlockCipherXxx ScShimSymCrypt3DesBlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    DESX
#define ALG_Name    Desx

#define SymCryptBlockCipherXxx ScShimSymCryptDesxBlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    RC2
#define ALG_Name    Rc2
#define ALG_Rc2SetKeyOverride (1)

#define SymCryptBlockCipherXxx ScShimSymCryptRc2BlockCipher
#include "sc_imp_blockciphertestfunctionspattern.cpp"
#undef SymCryptBlockCipherXxx

#define ALG_Mode    Ecb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cbc
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#define ALG_Mode    Cfb
#include "sc_imp_blockcipherpattern.cpp"
#undef ALG_Mode

#undef ALG_NAME
#undef ALG_Name
#undef ALG_Rc2SetKeyOverride

#define ALG_NAME    PBKDF2
#define ALG_Name    Pbkdf2

#define ALG_Base    HmacMd5
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha1
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha256
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha384
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha512
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#define ALG_Base    AesCmac
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_pbkdf2pattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    SP800_108
#define ALG_Name    Sp800_108

#define ALG_Base    HmacMd5
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha1
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha256
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha384
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha512
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#define ALG_Base    AesCmac
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sp800_108pattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    TLSPRF1_1
#define ALG_Name    TlsPrf1_1

#define ALG_Base    HmacMd5
#include "sc_imp_tlsprf1_1pattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    TLSPRF1_2
#define ALG_Name    TlsPrf1_2

#define ALG_Base    HmacSha256
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_tlsprf1_2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha384
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_tlsprf1_2pattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha512
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_tlsprf1_2pattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    HKDF
#define ALG_Name    Hkdf

#define ALG_Base    HmacSha256
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_HMAC_SHA256_RESULT_SIZE
#include "sc_imp_hkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#define ALG_Base    HmacSha1
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_HMAC_SHA1_RESULT_SIZE
#include "sc_imp_hkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name


#define ALG_NAME    SSHKDF
#define ALG_Name    SshKdf

#define ALG_Base    Sha1
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_SHA1_RESULT_SIZE
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sshkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#define ALG_Base    Sha256
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_SHA256_RESULT_SIZE
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sshkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#define ALG_Base    Sha384
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_SHA384_RESULT_SIZE
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sshkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#define ALG_Base    Sha512
#define SCSHIM_XXX_BASE_RESULT_SIZE   SYMCRYPT_SHA512_RESULT_SIZE
#include "sc_imp_kdfpattern.cpp"
#include "sc_imp_sshkdfpattern.cpp"
#undef SCSHIM_XXX_BASE_RESULT_SIZE
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    SRTPKDF
#define ALG_Name    SrtpKdf

#define ALG_Base    Aes
#include "sc_imp_srtpkdfpattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    SSKDF
#define ALG_Name    SskdfMac

#define ALG_Base    HmacSha256
#include "sc_imp_sskdfmacpattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha512
#include "sc_imp_sskdfmacpattern.cpp"
#undef ALG_Base

#define ALG_Base    HmacSha3_384
#include "sc_imp_sskdfmacpattern.cpp"
#undef ALG_Base

#define ALG_Base    Kmac128
#include "sc_imp_sskdfmacpattern.cpp"
#undef ALG_Base

#define ALG_Base    Kmac256
#include "sc_imp_sskdfmacpattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name

#define ALG_NAME    SSKDF
#define ALG_Name    SskdfHash

#define ALG_Base    Sha256
#include "sc_imp_sskdfhashpattern.cpp"
#undef ALG_Base

#define ALG_Base    Sha512
#include "sc_imp_sskdfhashpattern.cpp"
#undef ALG_Base

#define ALG_Base    Sha3_384
#include "sc_imp_sskdfhashpattern.cpp"
#undef ALG_Base

#undef ALG_NAME
#undef ALG_Name


//
// There is not enough structure to the CCM & GCM modes to share an implementation
//
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgAes, ModeCcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptAesExpandKey( (SYMCRYPT_AES_EXPANDED_KEY *) buf1, buf2, keySize );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgAes, ModeCcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptCcmEncrypt(
        ScShimSymCryptAesBlockCipher, (SYMCRYPT_AES_EXPANDED_KEY*)buf1,
        buf2, 12, nullptr, 0, buf2 + 16, buf3 + 16, dataSize, buf3, 16);
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgAes, ModeCcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptCcmDecrypt(
        ScShimSymCryptAesBlockCipher, (SYMCRYPT_AES_EXPANDED_KEY*)buf1,
        buf2, 12, nullptr, 0, buf3 + 16, buf2 + 16, dataSize, buf3, 16);
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgAes, ModeCcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_AES_EXPANDED_KEY ) );
}

template<>
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::AuthEncImp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgAes, ModeCcm>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgAes, ModeCcm>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgAes, ModeCcm>;
    m_perfDecryptFunction = &algImpDecryptPerfFunction<ImpXxx, AlgAes, ModeCcm>;
}

template<>
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::~AuthEncImp()
{
}

template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::getKeySizes()
{
    std::set<SIZE_T> res;

    res.insert( 16 );
    res.insert( 24 );
    res.insert( 32 );

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::getNonceSizes()
{
    std::set<SIZE_T> res;

    for( int i=7; i<=13; i++ )
    {
        res.insert( i );
    }

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::getTagSizes()
{
    std::set<SIZE_T> res;

    for( int i=4; i<=16; i += 2 )
    {
        res.insert( i );
    }

    return res;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::setKey( PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey == 16 || cbKey == 24 || cbKey == 32, "?" );
    ScShimSymCryptAesExpandKey( &state.key, pbKey, cbKey );

    state.inComputation = FALSE;
    return STATUS_SUCCESS;
}

template<>
VOID
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::setTotalCbData( SIZE_T cbData )
{
    state.totalCbData = cbData;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::encrypt(
        _In_reads_( cbNonce )       PCBYTE  pbNonce,
                                    SIZE_T  cbNonce,
        _In_reads_( cbAuthData )    PCBYTE  pbAuthData,
                                    SIZE_T  cbAuthData,
        _In_reads_( cbData )        PCBYTE  pbSrc,
        _Out_writes_( cbData )      PBYTE   pbDst,
                                    SIZE_T  cbData,
        _Out_writes_( cbTag )       PBYTE   pbTag,
                                    SIZE_T  cbTag,
                                    ULONG   flags )
{
    NTSTATUS status = STATUS_SUCCESS;

    // print( "cbNonce = %d, cbAuthData = %d, cbData = %d, cbTag = %d\n", (ULONG)cbNonce, (ULONG) cbAuthData, (ULONG) cbData, (ULONG) cbTag );

    CHECK( (flags & ~AUTHENC_FLAG_PARTIAL) == 0, "Unknown flag" );

    if( (flags & AUTHENC_FLAG_PARTIAL) == 0 )
    {
        // simple straight CCM computation.
        CHECK( ScShimSymCryptCcmValidateParameters(
            ScShimSymCryptAesBlockCipher,
            cbNonce,
            cbAuthData,
            cbData,
            cbTag ) == SYMCRYPT_NO_ERROR, "?" );

        ScShimSymCryptCcmEncrypt(
            ScShimSymCryptAesBlockCipher, &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            pbSrc, pbDst, cbData,
            pbTag, cbTag );

        // Done
        goto cleanup;
    }

    if( !state.inComputation )
    {
        CHECK( (flags & AUTHENC_FLAG_PARTIAL) != 0, "?" );
        // total cbData is passed in the cbTag parameter in the first partial call
        ScShimSymCryptCcmInit(
            &state.ccmState, ScShimSymCryptAesBlockCipher, &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            state.totalCbData, cbTag);

        state.inComputation = TRUE;
    }

    // We can process the next part before we decide whether to produce the tag.
    ScShimSymCryptCcmEncryptPart( &state.ccmState, pbSrc, pbDst, cbData );

    if( pbTag != nullptr )
    {
        ScShimSymCryptCcmEncryptFinal( &state.ccmState, pbTag, cbTag );

        state.inComputation = FALSE;
    }

cleanup:
    return status;

}


template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeCcm>::decrypt(
        _In_reads_( cbNonce )       PCBYTE  pbNonce,
                                    SIZE_T  cbNonce,
        _In_reads_( cbAuthData )    PCBYTE  pbAuthData,
                                    SIZE_T  cbAuthData,
        _In_reads_( cbData )        PCBYTE  pbSrc,
        _Out_writes_( cbData )      PBYTE   pbDst,
                                    SIZE_T  cbData,
        _In_reads_( cbTag )         PCBYTE  pbTag,
                                    SIZE_T  cbTag,
                                    ULONG   flags )
{
    NTSTATUS status = STATUS_SUCCESS;
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    // print( "cbNonce = %d, cbAuthData = %d, cbData = %d, cbTag = %d\n", (ULONG)cbNonce, (ULONG) cbAuthData, (ULONG) cbData, (ULONG) cbTag );

    CHECK( (flags & ~AUTHENC_FLAG_PARTIAL) == 0, "Unknown flag" );

    if( (flags & AUTHENC_FLAG_PARTIAL) == 0 )
    {
        // simple straight CCM computation.
        CHECK( ScShimSymCryptCcmValidateParameters(
            ScShimSymCryptAesBlockCipher,
            cbNonce,
            cbAuthData,
            cbData,
            cbTag ) == SYMCRYPT_NO_ERROR, "?" );

        scError = ScShimSymCryptCcmDecrypt(
            ScShimSymCryptAesBlockCipher, &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            pbSrc, pbDst, cbData,
            pbTag, cbTag );

        if( scError == SYMCRYPT_AUTHENTICATION_FAILURE )
        {
            status = STATUS_AUTH_TAG_MISMATCH;
        } else {
            CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
        }

        // Done
        goto cleanup;
    }

    if( !state.inComputation )
    {
        // First call of a partial computation.
        ScShimSymCryptCcmInit(
            &state.ccmState, ScShimSymCryptAesBlockCipher, &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            state.totalCbData, cbTag );

        state.inComputation = TRUE;
    }

    // We can process the next part before we decide whether to produce the tag.
    ScShimSymCryptCcmDecryptPart( &state.ccmState, pbSrc, pbDst, cbData );

    if( pbTag != nullptr )
    {
        scError = ScShimSymCryptCcmDecryptFinal( &state.ccmState, pbTag, cbTag );
        if( scError == SYMCRYPT_AUTHENTICATION_FAILURE )
        {
            status = STATUS_AUTH_TAG_MISMATCH;
        } else {
            CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
        }

        state.inComputation = FALSE;
    }

cleanup:
    return status;
}

//////////////////////////
// GCM

//
// There is not enough structure to the CCM & GCM modes to share an implementation
//

template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgAes, ModeGcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptGcmExpandKey( (PSYMCRYPT_GCM_EXPANDED_KEY) buf1,
                        ScShimSymCryptAesBlockCipher,
                        buf2, keySize );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgAes, ModeGcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptGcmEncrypt( (PCSYMCRYPT_GCM_EXPANDED_KEY) buf1,
                            buf2, 12,
                            nullptr, 0,
                            buf2 + 16, buf3 + 16, dataSize,
                            buf3, 16 );
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx,AlgAes, ModeGcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptGcmDecrypt( (PCSYMCRYPT_GCM_EXPANDED_KEY) buf1,
                            buf2, 12,
                            nullptr, 0,
                            buf3 + 16, buf2 + 16, dataSize,
                            buf3, 16 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgAes, ModeGcm>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_GCM_EXPANDED_KEY ) );
}

// AuthEncImp<..., AlgAes, ModeGcm> contains a corresponding AuthEncImpState with a SYMCRYPT_GCM_STATE.
// It must be aligned on a SYMCRYPT_ALIGN_VALUE boundary.
template<>
PVOID
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::operator new( size_t size )
{
    return ALIGNED_ALLOC( SYMCRYPT_ALIGN_VALUE, size );
}

template<>
VOID
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::operator delete( PVOID p )
{
    ALIGNED_FREE( p );
}

template<>
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::AuthEncImp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgAes, ModeGcm>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgAes, ModeGcm>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgAes, ModeGcm>;
    m_perfDecryptFunction = &algImpDecryptPerfFunction<ImpXxx, AlgAes, ModeGcm>;
}

template<>
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::~AuthEncImp()
{
    SymCryptWipeKnownSize( &state.key, sizeof( state.key ) );
}

template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::getKeySizes()
{
    std::set<SIZE_T> res;

    res.insert( 16 );
    res.insert( 24 );
    res.insert( 32 );

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::getNonceSizes()
{
    std::set<SIZE_T> res;

    for(int i = 1; i <= 256; ++i)
    {
        res.insert( i );
    }

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::getTagSizes()
{
    std::set<SIZE_T> res;

    for( int i=12; i<=16; i ++ )
    {
        res.insert( i );
    }

    return res;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::setKey( PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey == 16 || cbKey == 24 || cbKey == 32, "?" );

    ScShimSymCryptGcmExpandKey( &state.key, ScShimSymCryptAesBlockCipher, pbKey, cbKey );

    state.inComputation = FALSE;
    return STATUS_SUCCESS;
}

template<>
VOID
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::setTotalCbData( SIZE_T cbData )
{
    state.totalCbData = cbData;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::encrypt(
        _In_reads_( cbNonce )       PCBYTE  pbNonce,
                                    SIZE_T  cbNonce,
        _In_reads_( cbAuthData )    PCBYTE  pbAuthData,
                                    SIZE_T  cbAuthData,
        _In_reads_( cbData )        PCBYTE  pbSrc,
        _Out_writes_( cbData )      PBYTE   pbDst,
                                    SIZE_T  cbData,
        _Out_writes_( cbTag )       PBYTE   pbTag,
                                    SIZE_T  cbTag,
                                    ULONG   flags )
{
    NTSTATUS status = STATUS_SUCCESS;

    CHECK( (flags & ~AUTHENC_FLAG_PARTIAL) == 0, "Unknown flag" );

    if( (flags & AUTHENC_FLAG_PARTIAL) == 0 )
    {
        // simple straight GCM computation.
        CHECK( ScShimSymCryptGcmValidateParameters(
            ScShimSymCryptAesBlockCipher,
            cbNonce,
            cbAuthData,
            cbData,
            cbTag ) == SYMCRYPT_NO_ERROR, "?" );

        ScShimSymCryptGcmEncrypt( &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            pbSrc, pbDst, cbData,
            pbTag, cbTag );

        // Done
        goto cleanup;
    }

    // We can process the next part before we decide whether to produce the tag.
    SYMCRYPT_GCM_EXPANDED_KEY gcmKey2;
    SYMCRYPT_GCM_STATE gcmState1;

    ScShimSymCryptGcmKeyCopy( &state.key, &gcmKey2 );

    if( !state.inComputation )
    {
        CHECK( (flags & AUTHENC_FLAG_PARTIAL) != 0, "?" );
        // total cbData is passed in the cbTag parameter in the first partial call
        ScShimSymCryptGcmInit(
            &gcmState1, (g_rng.byte() & 1) ? &state.key : &gcmKey2,
            pbNonce, cbNonce );

        SIZE_T bytesDone = 0;
        while( bytesDone != cbAuthData )
        {
            SIZE_T bytesThisLoop = g_rng.sizet( cbAuthData - bytesDone + 1);
            ScShimSymCryptGcmAuthPart( &gcmState1, &pbAuthData[bytesDone], bytesThisLoop );
            bytesDone += bytesThisLoop;
        }

        state.inComputation = TRUE;
    } else {
        ScShimSymCryptGcmStateCopy( &state.gcmState, (g_rng.byte() & 1) ? &gcmKey2 : nullptr , &gcmState1 );
    }
    // Using gcmState1 which is using gcmKey2 or state.key.

    ScShimSymCryptGcmEncryptPart( &gcmState1, pbSrc, pbDst, cbData );

    if( pbTag != nullptr )
    {
        ScShimSymCryptGcmEncryptFinal( &gcmState1, pbTag, cbTag );

        state.inComputation = FALSE;
    } else {
        // Copy the state back into the object
        ScShimSymCryptGcmStateCopy( &gcmState1, &state.key, &state.gcmState );
    }


cleanup:
    return status;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgAes, ModeGcm>::decrypt(
        _In_reads_( cbNonce )       PCBYTE  pbNonce,
                                    SIZE_T  cbNonce,
        _In_reads_( cbAuthData )    PCBYTE  pbAuthData,
                                    SIZE_T  cbAuthData,
        _In_reads_( cbData )        PCBYTE  pbSrc,
        _Out_writes_( cbData )      PBYTE   pbDst,
                                    SIZE_T  cbData,
        _In_reads_( cbTag )         PCBYTE  pbTag,
                                    SIZE_T  cbTag,
                                    ULONG   flags )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    CHECK( (flags & ~AUTHENC_FLAG_PARTIAL) == 0, "Unknown flag" );

    if( (flags & AUTHENC_FLAG_PARTIAL) == 0 )
    {
        // simple straight GCM computation.
        CHECK( ScShimSymCryptGcmValidateParameters(
            ScShimSymCryptAesBlockCipher,
            cbNonce,
            cbAuthData,
            cbData,
            cbTag ) == SYMCRYPT_NO_ERROR, "?" );

        scError = ScShimSymCryptGcmDecrypt( &state.key,
            pbNonce, cbNonce, pbAuthData, cbAuthData,
            pbSrc, pbDst, cbData,
            pbTag, cbTag );

        // Done
        goto cleanup;
    }

    // We can process the next part before we decide whether to produce the tag.
    SYMCRYPT_GCM_EXPANDED_KEY gcmKey2;
    SYMCRYPT_GCM_STATE gcmState1;

    ScShimSymCryptGcmKeyCopy( &state.key, &gcmKey2 );

    if( !state.inComputation )
    {
        CHECK( (flags & AUTHENC_FLAG_PARTIAL) != 0, "?" );
        // total cbData is passed in the cbTag parameter in the first partial call
        ScShimSymCryptGcmInit(
            &gcmState1, (g_rng.byte() & 1) ? &state.key : &gcmKey2,
            pbNonce, cbNonce );

        SIZE_T bytesDone = 0;
        while( bytesDone != cbAuthData )
        {
            SIZE_T bytesThisLoop = g_rng.sizet( cbAuthData - bytesDone + 1);
            ScShimSymCryptGcmAuthPart( &gcmState1, &pbAuthData[bytesDone], bytesThisLoop );
            bytesDone += bytesThisLoop;
        }

        state.inComputation = TRUE;
    } else {
        ScShimSymCryptGcmStateCopy( &state.gcmState, (g_rng.byte() & 1) ? &gcmKey2 : nullptr , &gcmState1 );
    }
    // Using gcmState1 which is using gcmKey2 or state.key.

    ScShimSymCryptGcmDecryptPart( &gcmState1, pbSrc, pbDst, cbData );

    if( pbTag != nullptr )
    {
        scError = ScShimSymCryptGcmDecryptFinal( &gcmState1, pbTag, cbTag );

        state.inComputation = FALSE;
    } else {
        // Copy the state back into the object
        ScShimSymCryptGcmStateCopy( &gcmState1, &state.key, &state.gcmState );
    }

cleanup:
    return scError == SYMCRYPT_NO_ERROR ? 0 : STATUS_AUTH_TAG_MISMATCH;
}


//////////////////////////
// CHACHA20POLY1305
//template<>
//VOID
//algImpKeyPerfFunction< ImpXxx, AlgChaCha20Poly1305, ModeNone>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
//{
//    UNREFERENCED_PARAMETER( buf1 );
//    UNREFERENCED_PARAMETER( buf2 );
//    UNREFERENCED_PARAMETER( buf3 );
//    UNREFERENCED_PARAMETER( KeySize );
//}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgChaCha20Poly1305, ModeNone>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptChaCha20Poly1305Encrypt(
                        buf1, 32,
                        buf2, 12,
                        nullptr, 0,
                        buf2 + 16, buf3 + 16, dataSize,
                        buf3, 16 );
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgChaCha20Poly1305, ModeNone>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptChaCha20Poly1305Decrypt(
                        buf1, 32,
                        buf2, 12,
                        nullptr, 0,
                        buf3 + 16, buf2 + 16, dataSize,
                        buf3, 16 );
}

//template<>
//VOID
//algImpCleanPerfFunction<ImpXxx, AlgChaCha20Poly1305, ModeNone>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
//{
//    UNREFERENCED_PARAMETER( buf1 );
//    UNREFERENCED_PARAMETER( buf2 );
//    UNREFERENCED_PARAMETER( buf3 );
//}

template<>
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::AuthEncImp()
{
    m_perfKeyFunction     = nullptr;
    m_perfCleanFunction   = nullptr;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgChaCha20Poly1305, ModeNone>;
    m_perfDecryptFunction = &algImpDecryptPerfFunction<ImpXxx, AlgChaCha20Poly1305, ModeNone>;
}

template<>
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::~AuthEncImp()
{
    SymCryptWipeKnownSize( state.key, sizeof( state.key ) );
}

template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::getKeySizes()
{
    std::set<SIZE_T> res;

    res.insert( 32 );

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::getNonceSizes()
{
    std::set<SIZE_T> res;

    res.insert( 12 );

    return res;
}


template<>
std::set<SIZE_T>
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::getTagSizes()
{
    std::set<SIZE_T> res;

    res.insert( 16 );

    return res;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::setKey( PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey == 32, "?" );
    memcpy( state.key, pbKey, cbKey );

    return STATUS_SUCCESS;
}

template<>
VOID
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::setTotalCbData( SIZE_T cbData )
{
    UNREFERENCED_PARAMETER( cbData );
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::encrypt(
        _In_reads_( cbNonce )                     PCBYTE  pbNonce,
                                                  SIZE_T  cbNonce,
        _In_reads_( cbAuthData )                  PCBYTE  pbAuthData,
                                                  SIZE_T  cbAuthData,
        _In_reads_( cbData )                      PCBYTE  pbSrc,
        _Out_writes_( cbData )                    PBYTE   pbDst,
                                                  SIZE_T  cbData,
        _Out_writes_( cbTag )                     PBYTE   pbTag,
                                                  SIZE_T  cbTag,
                                                  ULONG   flags )
{
    UNREFERENCED_PARAMETER( flags );

    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    scError = ScShimSymCryptChaCha20Poly1305Encrypt(
                            state.key, sizeof(state.key),
                            pbNonce, cbNonce, pbAuthData, cbAuthData,
                            pbSrc, pbDst, cbData,
                            pbTag, cbTag );

    return scError == SYMCRYPT_NO_ERROR ? 0 : STATUS_ENCRYPTION_FAILED;
}

template<>
NTSTATUS
AuthEncImp<ImpXxx, AlgChaCha20Poly1305, ModeNone>::decrypt(
        _In_reads_( cbNonce )                     PCBYTE  pbNonce,
                                                  SIZE_T  cbNonce,
        _In_reads_( cbAuthData )                  PCBYTE  pbAuthData,
                                                  SIZE_T  cbAuthData,
        _In_reads_( cbData )                      PCBYTE  pbSrc,
        _Out_writes_( cbData )                    PBYTE   pbDst,
                                                  SIZE_T  cbData,
        _In_reads_( cbTag )                       PCBYTE  pbTag,
                                                  SIZE_T  cbTag,
                                                  ULONG   flags )
{
    UNREFERENCED_PARAMETER( flags );

    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    scError = ScShimSymCryptChaCha20Poly1305Decrypt(
                            state.key, sizeof(state.key),
                            pbNonce, cbNonce, pbAuthData, cbAuthData,
                            pbSrc, pbDst, cbData,
                            pbTag, cbTag );

    return scError == SYMCRYPT_NO_ERROR ? 0 : STATUS_AUTH_TAG_MISMATCH;
}


//////////////////////////
// RC4


template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgRc4>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptRc4Init( (PSYMCRYPT_RC4_STATE) buf1, buf2, keySize );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgRc4>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptRc4Crypt( (PSYMCRYPT_RC4_STATE) buf1, buf2, buf3, dataSize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgRc4>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SymCryptWipeKnownSize( buf1, sizeof( PSYMCRYPT_RC4_STATE ) );
}

template<>
StreamCipherImp<ImpXxx, AlgRc4>::StreamCipherImp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgRc4>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgRc4>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgRc4>;
}

template<>
StreamCipherImp<ImpXxx, AlgRc4>::~StreamCipherImp()
{
    SymCryptWipeKnownSize( &state.state, sizeof( state.state ) );
}

template<>
std::set<SIZE_T> StreamCipherImp<ImpXxx, AlgRc4>::getNonceSizes()
{
    std::set<SIZE_T> res;

    // No nonce sizes supported for RC4

    return res;
}

template<>
std::set<SIZE_T> StreamCipherImp<ImpXxx, AlgRc4>::getKeySizes()
{
    std::set<SIZE_T> res;
    SIZE_T maxKeySize = 256;

    for( SIZE_T i=1; i<=maxKeySize; i++ )
    {
        res.insert( i );
    }

    return res;
}

template<>
NTSTATUS
StreamCipherImp<ImpXxx, AlgRc4>::setNonce( PCBYTE pbNonce, SIZE_T cbNonce )
{
    UNREFERENCED_PARAMETER( pbNonce );

    CHECK( cbNonce == 0, "RC4 does not take a nonce" );

    return STATUS_SUCCESS;
}

template<>
VOID
StreamCipherImp< ImpXxx, AlgRc4>::setOffset( UINT64 offset )
{
    UNREFERENCED_PARAMETER( offset );
    CHECK( FALSE, "RC4 is not random access" );
}

template<>
NTSTATUS
StreamCipherImp<ImpXxx, AlgRc4>::setKey( PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey > 0 && cbKey <= 256, "?" );
    CHECK( ScShimSymCryptRc4Init( &state.state, pbKey, cbKey ) == SYMCRYPT_NO_ERROR, "??" );
    return STATUS_SUCCESS;
}

template<>
VOID
StreamCipherImp<ImpXxx, AlgRc4>::encrypt( PCBYTE pbSrc, PBYTE pbDst, SIZE_T cbData )
{
    ScShimSymCryptRc4Crypt( &state.state, pbSrc, pbDst, cbData );
}


//////////////////////////
// CHACHA20
template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgChaCha20>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( keySize );

    ScShimSymCryptChaCha20Init( (PSYMCRYPT_CHACHA20_STATE) buf1, buf2, 32, buf3, 12, 0 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgChaCha20>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptChaCha20Crypt( (PSYMCRYPT_CHACHA20_STATE) buf1, buf2, buf3, dataSize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgChaCha20>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SymCryptWipeKnownSize( buf1, sizeof( PSYMCRYPT_CHACHA20_STATE ) );
}

template<>
StreamCipherImp<ImpXxx, AlgChaCha20>::StreamCipherImp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgChaCha20>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgChaCha20>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgChaCha20>;
}

template<>
StreamCipherImp<ImpXxx, AlgChaCha20>::~StreamCipherImp()
{
    SymCryptWipeKnownSize( &state.state, sizeof( state.state ) );
}

template<>
std::set<SIZE_T> StreamCipherImp<ImpXxx, AlgChaCha20>::getNonceSizes()
{
    std::set<SIZE_T> res;

    res.insert( 12 );

    return res;
}

template<>
std::set<SIZE_T> StreamCipherImp<ImpXxx, AlgChaCha20>::getKeySizes()
{
    std::set<SIZE_T> res;

    res.insert( 32 );

    return res;
}

template<>
NTSTATUS
StreamCipherImp<ImpXxx, AlgChaCha20>::setNonce( PCBYTE pbNonce, SIZE_T cbNonce )
{
    CHECK( cbNonce == 12, "ChaCha20 takes a 12-byte nonce" );

    memcpy( state.nonce, pbNonce, cbNonce );
    state.offset = 0;

    CHECK( ScShimSymCryptChaCha20Init(
        &state.state, state.key, 32, state.nonce, 12, state.offset) == SYMCRYPT_NO_ERROR,
        "ChaCha20 init error" );

    return STATUS_SUCCESS;
}

template<>
VOID
StreamCipherImp< ImpXxx, AlgChaCha20>::setOffset( UINT64 offset )
{
    state.offset = offset;

    ScShimSymCryptChaCha20SetOffset( &state.state, offset );
}

template<>
NTSTATUS
StreamCipherImp<ImpXxx, AlgChaCha20>::setKey( PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey == 32, "ChaCha20 takes a 32-byte key" );

    memcpy( state.key, pbKey, cbKey );
    SymCryptWipeKnownSize( state.nonce, sizeof( state.nonce ) );
    state.offset = 0;

    CHECK( ScShimSymCryptChaCha20Init(
        &state.state, state.key, 32, state.nonce, 12, state.offset) == SYMCRYPT_NO_ERROR,
        "ChaCha20 init error");
    return STATUS_SUCCESS;
}

template<>
VOID
StreamCipherImp<ImpXxx, AlgChaCha20>::encrypt( PCBYTE pbSrc, PBYTE pbDst, SIZE_T cbData )
{

    ScShimSymCryptChaCha20Crypt( &state.state, pbSrc, pbDst, cbData );
}

///////////////////////////////////////////////////////
// Poly1305

/*
template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgPoly1305>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    // No per-key operations for Poly1305
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgPoly1305>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

*/

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgPoly1305>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptPoly1305( buf1, buf2, dataSize, buf3 );
}

template<>
MacImp<ImpXxx, AlgPoly1305>::MacImp()
{
    m_perfKeyFunction     = NULL;   // &algImpKeyPerfFunction    <ImpXxx, AlgPoly1305>;
    m_perfCleanFunction   = NULL;   //&algImpCleanPerfFunction  <ImpXxx, AlgPoly1305>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgPoly1305>;
}

template<>
MacImp<ImpXxx, AlgPoly1305>::~MacImp<ImpXxx, AlgPoly1305>()
{
}

template<>
NTSTATUS MacImp<ImpXxx, AlgPoly1305>::mac(
    _In_reads_( cbKey )      PCBYTE pbKey,   SIZE_T cbKey,
    _In_reads_( cbData )     PCBYTE pbData,  SIZE_T cbData,
    _Out_writes_( cbResult )  PBYTE pbResult, SIZE_T cbResult )
{
    CHECK( cbKey == 32, "?" );
    CHECK( cbResult == 16, "?" );

    ScShimSymCryptPoly1305( pbKey, pbData, cbData, pbResult );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
MacImp<ImpXxx, AlgPoly1305>::init( _In_reads_( cbKey ) PCBYTE pbKey, SIZE_T cbKey )
{
    CHECK( cbKey == 32, "?" );
    ScShimSymCryptPoly1305Init( &state.state, pbKey );

    return STATUS_SUCCESS;
}

template<>
VOID MacImp<ImpXxx, AlgPoly1305>::append( _In_reads_( cbData ) PCBYTE pbData, SIZE_T cbData )
{
    ScShimSymCryptPoly1305Append( &state.state, pbData, cbData );
}

template<>
VOID MacImp<ImpXxx, AlgPoly1305>::result( _Out_writes_( cbResult ) PBYTE pbResult, SIZE_T cbResult )
{
    CHECK( cbResult == 16, "Result len error SC/Poly1305" );
    ScShimSymCryptPoly1305Result( &state.state, pbResult );
}

template<>
SIZE_T MacImp<ImpXxx, AlgPoly1305>::inputBlockLen()
{
    return SYMCRYPT_POLY1305_RESULT_SIZE;
}

template<>
SIZE_T MacImp<ImpXxx, AlgPoly1305>::resultLen()
{
    return SYMCRYPT_POLY1305_RESULT_SIZE;
}



///////////////////////////////////////////////////////
// AES-CTR_DRBG
//


template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgAesCtrDrbg>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptRngAesInstantiate( (PSYMCRYPT_RNG_AES_STATE) buf1, buf2, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgAesCtrDrbg>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptRngAesUninstantiate( (PSYMCRYPT_RNG_AES_STATE) buf1 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgAesCtrDrbg>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );

    ScShimSymCryptRngAesGenerate( (PSYMCRYPT_RNG_AES_STATE) buf1, buf3, dataSize );
}

template<>
RngSp800_90Imp<ImpXxx, AlgAesCtrDrbg>::RngSp800_90Imp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgAesCtrDrbg>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgAesCtrDrbg>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgAesCtrDrbg>;
}

template<>
RngSp800_90Imp<ImpXxx, AlgAesCtrDrbg>::~RngSp800_90Imp()
{
    ScShimSymCryptRngAesUninstantiate( &state.state );
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgAesCtrDrbg>::instantiate( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRngAesInstantiate( &state.state, pbEntropy, cbEntropy );

    CHECK( scError == SYMCRYPT_NO_ERROR, "Error during instantiation" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgAesCtrDrbg>::reseed( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRngAesReseed( &state.state, pbEntropy, cbEntropy );

    CHECK3( scError == SYMCRYPT_NO_ERROR, "Error during reseed, len=%lld", (ULONGLONG) cbEntropy );

    return STATUS_SUCCESS;
}

template<>
VOID
RngSp800_90Imp<ImpXxx, AlgAesCtrDrbg>::generate(  _Out_writes_( cbData ) PBYTE pbData, SIZE_T cbData )
{
    ScShimSymCryptRngAesGenerate( &state.state, pbData, cbData );
}




template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgAesCtrF142>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptRngAesFips140_2Instantiate( (PSYMCRYPT_RNG_AES_FIPS140_2_STATE) buf1, buf2, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgAesCtrF142>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    ScShimSymCryptRngAesFips140_2Uninstantiate( (PSYMCRYPT_RNG_AES_FIPS140_2_STATE) buf1 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgAesCtrF142>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );

    ScShimSymCryptRngAesFips140_2Generate( (PSYMCRYPT_RNG_AES_FIPS140_2_STATE) buf1, buf3, dataSize );
}

template<>
RngSp800_90Imp<ImpXxx, AlgAesCtrF142>::RngSp800_90Imp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction    <ImpXxx, AlgAesCtrF142>;
    m_perfCleanFunction   = &algImpCleanPerfFunction  <ImpXxx, AlgAesCtrF142>;
    m_perfDataFunction    = &algImpDataPerfFunction   <ImpXxx, AlgAesCtrF142>;
}

template<>
RngSp800_90Imp<ImpXxx, AlgAesCtrF142>::~RngSp800_90Imp()
{
    ScShimSymCryptRngAesFips140_2Uninstantiate( &state.state );
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgAesCtrF142>::instantiate( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRngAesFips140_2Instantiate( &state.state, pbEntropy, cbEntropy );

    CHECK( scError == SYMCRYPT_NO_ERROR, "Error during instantiation" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgAesCtrF142>::reseed( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRngAesFips140_2Reseed( &state.state, pbEntropy, cbEntropy );

    CHECK3( scError == SYMCRYPT_NO_ERROR, "Error during reseed, len=%lld", (ULONGLONG) cbEntropy );

    return STATUS_SUCCESS;
}

template<>
VOID
RngSp800_90Imp<ImpXxx, AlgAesCtrF142>::generate(  _Out_writes_( cbData ) PBYTE pbData, SIZE_T cbData )
{
    ScShimSymCryptRngAesFips140_2Generate( &state.state, pbData, cbData );
}

#if IMP_UseSymCryptRandom
///////////////////////////////////////////////////////
// Dynamic Random
//

template<>
VOID
algImpKeyPerfFunction<ImpXxx,AlgDynamicRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );

    ScShimSymCryptProvideEntropy( buf3, keySize );
}


template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgDynamicRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgDynamicRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );

    ScShimSymCryptRandom( buf3, dataSize );
}

template<>
RngSp800_90Imp<ImpXxx, AlgDynamicRandom>::RngSp800_90Imp()
{
    m_perfKeyFunction     = &algImpKeyPerfFunction<ImpXxx, AlgDynamicRandom>;
    m_perfCleanFunction   = &algImpCleanPerfFunction<ImpXxx, AlgDynamicRandom>;
    m_perfDataFunction    = &algImpDataPerfFunction<ImpXxx, AlgDynamicRandom>;
}

template<>
RngSp800_90Imp<ImpXxx, AlgDynamicRandom>::~RngSp800_90Imp()
{
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgDynamicRandom>::instantiate( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    ScShimSymCryptProvideEntropy( pbEntropy, cbEntropy );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RngSp800_90Imp<ImpXxx, AlgDynamicRandom>::reseed( _In_reads_( cbEntropy ) PCBYTE pbEntropy, SIZE_T cbEntropy )
{
    ScShimSymCryptProvideEntropy( pbEntropy, cbEntropy );

    return STATUS_SUCCESS;
}

template<>
VOID
RngSp800_90Imp<ImpXxx, AlgDynamicRandom>::generate(  _Out_writes_( cbData ) PBYTE pbData, SIZE_T cbData )
{
    ScShimSymCryptRandom( pbData, cbData );
}
#endif

//=============================================================================
// Parallel hashing
//

#define N_PARALLEL_FOR_PERF 8

template<>
VOID
algImpKeyPerfFunction<ImpXxx,AlgParallelSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptParallelSha256Init( (PSYMCRYPT_SHA256_STATE) buf1, N_PARALLEL_FOR_PERF );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgParallelSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgParallelSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    int i;
    PSYMCRYPT_SHA256_STATE pState = (PSYMCRYPT_SHA256_STATE) buf1;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOperations = (PSYMCRYPT_PARALLEL_HASH_OPERATION) buf2;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOp = pOperations;

    PBYTE pSrc = buf3;
    PBYTE pDst = buf3 + PERF_BUFFER_SIZE / 2;

    for( i=0; i<N_PARALLEL_FOR_PERF; i++ )
    {
        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_APPEND;
        pOp->pbBuffer = pSrc;
        pOp->cbBuffer = dataSize / N_PARALLEL_FOR_PERF;

        pOp++;
        pSrc += dataSize / N_PARALLEL_FOR_PERF;

        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_RESULT;
        pOp->pbBuffer = pDst;
        pOp->cbBuffer = 32;

        pOp++;
        pDst += 32;
    }
    ScShimSymCryptParallelSha256Process(
        pState, N_PARALLEL_FOR_PERF, pOperations, 2 * N_PARALLEL_FOR_PERF, buf1 + PERF_BUFFER_SIZE / 2, PERF_BUFFER_SIZE / 2);
}

template<>
ParallelHashImp<ImpXxx, AlgParallelSha256>::ParallelHashImp()
{
    m_perfDataFunction = &algImpDataPerfFunction <ImpXxx, AlgParallelSha256>;
    m_perfKeyFunction  = &algImpKeyPerfFunction  <ImpXxx, AlgParallelSha256>;
    m_perfCleanFunction= &algImpCleanPerfFunction<ImpXxx, AlgParallelSha256>;

    state.nHashes = 0;
};

template<>
ParallelHashImp<ImpXxx, AlgParallelSha256>::~ParallelHashImp() {};

template<>
PCSYMCRYPT_HASH
ParallelHashImp<ImpXxx, AlgParallelSha256>::SymCryptHash()
{
    return ScShimSymCryptSha256Algorithm;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha256>::resultLen()
{
    return SYMCRYPT_SHA256_RESULT_SIZE;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha256>::inputBlockLen()
{
    return SYMCRYPT_SHA256_INPUT_BLOCK_SIZE;
}


template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha256>::init( SIZE_T nHashes )
{
    CHECK( nHashes <= MAX_PARALLEL_HASH_STATES, "Too many hash states requested" );
    state.nHashes = nHashes;

    ScShimSymCryptParallelSha256Init( &state.sc[0], nHashes );
}

template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha256>::process(
        _In_reads_( nOperations )   BCRYPT_MULTI_HASH_OPERATION *   pOperations,
                                    SIZE_T                          nOperations )
{
    SYMCRYPT_ERROR                      scError;
    SYMCRYPT_PARALLEL_HASH_OPERATION    op[MAX_PARALLEL_HASH_OPERATIONS];
    BYTE                                scratch[SYMCRYPT_PARALLEL_SHA256_FIXED_SCRATCH + SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH * MAX_PARALLEL_HASH_STATES + 128];

    CHECK( nOperations <= MAX_PARALLEL_HASH_OPERATIONS, "Too many operations" );

    for( SIZE_T i=0; i<nOperations; i++ )
    {
        op[i].iHash = pOperations[i].iHash;
        op[i].hashOperation = pOperations[i].hashOperation == BCRYPT_HASH_OPERATION_HASH_DATA ? SYMCRYPT_HASH_OPERATION_APPEND : SYMCRYPT_HASH_OPERATION_RESULT;
        op[i].pbBuffer = pOperations[i].pbBuffer;
        op[i].cbBuffer = pOperations[i].cbBuffer;

        CHECK( op[i].iHash < state.nHashes, "?" );
    }

    SIZE_T scratchOffset = g_rng.sizet( 64 );
    BYTE sentinel = g_rng.byte();
    SIZE_T nScratch = SYMCRYPT_PARALLEL_SHA256_FIXED_SCRATCH + state.nHashes * SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH;
    CHECK( nScratch + scratchOffset <= sizeof( scratch ), "?" );
    SYMCRYPT_ASSERT( nScratch + scratchOffset < sizeof( scratch ) );

    scratch[scratchOffset + nScratch] = sentinel;

    SYMCRYPT_ASSERT( state.nHashes <= MAX_PARALLEL_HASH_STATES );
    scError = ScShimSymCryptParallelSha256Process(
                                &state.sc[0],
                                state.nHashes,
                                &op[0],
                                nOperations,
                                &scratch[scratchOffset],
                                nScratch );
    CHECK( scError == SYMCRYPT_NO_ERROR, "Parallel SHA256 returned an error" );
    CHECK( scratch[scratchOffset + nScratch] == sentinel, "Parallel SHA256 used too much scratch space" );
}

template<>
NTSTATUS
ParallelHashImp<ImpXxx, AlgParallelSha256>::initWithLongMessage( ULONGLONG nBytes )
{
    // Discard this test for dynamic modules as it modifies state internals
    if constexpr ( std::is_same<ImpXxx, ImpScDynamic>::value )
    {
        return STATUS_NOT_SUPPORTED;
    }

    CHECK( nBytes % 64 == 0, "Odd bytes in initWithLongMessage" );
    CHECK( state.nHashes <= MAX_PARALLEL_HASH_STATES, "?" );

    for( SIZE_T i=0; i<state.nHashes; i++ )
    {
        memset( &state.sc[i].chain, 'b', sizeof( state.sc[i].chain ) );
        state.sc[i].dataLengthL = nBytes;
        state.sc[i].dataLengthH = 0;
        state.sc[i].bytesInBuffer = 0;
    }

    return STATUS_SUCCESS;
}


template<>
VOID
algImpKeyPerfFunction<ImpXxx,AlgParallelSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptParallelSha384Init( (PSYMCRYPT_SHA384_STATE) buf1, N_PARALLEL_FOR_PERF );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgParallelSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgParallelSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    int i;
    PSYMCRYPT_SHA384_STATE pState = (PSYMCRYPT_SHA384_STATE) buf1;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOperations = (PSYMCRYPT_PARALLEL_HASH_OPERATION) buf2;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOp = pOperations;

    PBYTE pSrc = buf3;
    PBYTE pDst = buf3 + PERF_BUFFER_SIZE / 2;

    for( i=0; i<N_PARALLEL_FOR_PERF; i++ )
    {
        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_APPEND;
        pOp->pbBuffer = pSrc;
        pOp->cbBuffer = dataSize / N_PARALLEL_FOR_PERF;

        pOp++;
        pSrc += dataSize / N_PARALLEL_FOR_PERF;

        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_RESULT;
        pOp->pbBuffer = pDst;
        pOp->cbBuffer = 48;

        pOp++;
        pDst += 48;
    }
    ScShimSymCryptParallelSha384Process(
        pState, N_PARALLEL_FOR_PERF, pOperations, 2 * N_PARALLEL_FOR_PERF, buf1 + PERF_BUFFER_SIZE / 2, PERF_BUFFER_SIZE / 2);
}

template<>
ParallelHashImp<ImpXxx, AlgParallelSha384>::ParallelHashImp()
{
    m_perfDataFunction = &algImpDataPerfFunction <ImpXxx, AlgParallelSha384>;
    m_perfKeyFunction  = &algImpKeyPerfFunction  <ImpXxx, AlgParallelSha384>;
    m_perfCleanFunction= &algImpCleanPerfFunction<ImpXxx, AlgParallelSha384>;

    state.nHashes = 0;
};

template<>
ParallelHashImp<ImpXxx, AlgParallelSha384>::~ParallelHashImp() {};

template<>
PCSYMCRYPT_HASH
ParallelHashImp<ImpXxx, AlgParallelSha384>::SymCryptHash()
{
    return ScShimSymCryptSha384Algorithm;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha384>::resultLen()
{
    return SYMCRYPT_SHA384_RESULT_SIZE;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha384>::inputBlockLen()
{
    return SYMCRYPT_SHA384_INPUT_BLOCK_SIZE;
}


template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha384>::init( SIZE_T nHashes )
{
    CHECK( nHashes <= MAX_PARALLEL_HASH_STATES, "Too many hash states requested" );
    state.nHashes = nHashes;
    ScShimSymCryptParallelSha384Init( &state.sc[0], nHashes );
}

template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha384>::process(
        _In_reads_( nOperations )   BCRYPT_MULTI_HASH_OPERATION *   pOperations,
                                    SIZE_T                          nOperations )
{
    SYMCRYPT_ERROR                      scError;
    SYMCRYPT_PARALLEL_HASH_OPERATION    op[MAX_PARALLEL_HASH_OPERATIONS];
    BYTE                                scratch[SYMCRYPT_PARALLEL_SHA384_FIXED_SCRATCH + SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH * MAX_PARALLEL_HASH_STATES + 128];

    CHECK( nOperations <= MAX_PARALLEL_HASH_OPERATIONS, "Too many operations" );

    for( SIZE_T i=0; i<nOperations; i++ )
    {
        op[i].iHash = pOperations[i].iHash;
        op[i].hashOperation = pOperations[i].hashOperation == BCRYPT_HASH_OPERATION_HASH_DATA ? SYMCRYPT_HASH_OPERATION_APPEND : SYMCRYPT_HASH_OPERATION_RESULT;
        op[i].pbBuffer = pOperations[i].pbBuffer;
        op[i].cbBuffer = pOperations[i].cbBuffer;

        CHECK( op[i].iHash < state.nHashes, "?" );
    }

    SIZE_T scratchOffset = g_rng.sizet( 64 );
    BYTE sentinel = g_rng.byte();
    SIZE_T nScratch = SYMCRYPT_PARALLEL_SHA384_FIXED_SCRATCH + state.nHashes * SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH;
    CHECK( nScratch + scratchOffset <= sizeof( scratch ), "?" );
    SYMCRYPT_ASSERT( nScratch + scratchOffset < sizeof( scratch ) );

    scratch[scratchOffset + nScratch] = sentinel;

    SYMCRYPT_ASSERT( state.nHashes <= MAX_PARALLEL_HASH_STATES );
    scError = ScShimSymCryptParallelSha384Process(
                                &state.sc[0],
                                state.nHashes,
                                &op[0],
                                nOperations,
                                &scratch[scratchOffset],
                                nScratch );
    CHECK( scError == SYMCRYPT_NO_ERROR, "Parallel SHA384 returned an error" );
    CHECK( scratch[scratchOffset + nScratch] == sentinel, "Parallel SHA384 used too much scratch space" );
}

template<>
NTSTATUS
ParallelHashImp<ImpXxx, AlgParallelSha384>::initWithLongMessage( ULONGLONG nBytes )
{
    // Discard this test for dynamic modules as it modifies state internals
    if constexpr ( std::is_same<ImpXxx, ImpScDynamic>::value )
    {
        return STATUS_NOT_SUPPORTED;
    }

    CHECK( nBytes % 128 == 0, "Odd bytes in initWithLongMessage" );
    CHECK( state.nHashes <= MAX_PARALLEL_HASH_STATES, "?" );

    for( SIZE_T i=0; i<state.nHashes; i++ )
    {
        memset( &state.sc[i].chain, 'b', sizeof( state.sc[i].chain ) );
        state.sc[i].dataLengthL = nBytes;
        state.sc[i].dataLengthH = 0;
        state.sc[i].bytesInBuffer = 0;
    }

    return STATUS_SUCCESS;
}


template<>
VOID
algImpKeyPerfFunction<ImpXxx,AlgParallelSha512>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptParallelSha512Init( (PSYMCRYPT_SHA512_STATE) buf1, N_PARALLEL_FOR_PERF );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgParallelSha512>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx,AlgParallelSha512>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    int i;
    PSYMCRYPT_SHA512_STATE pState = (PSYMCRYPT_SHA512_STATE) buf1;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOperations = (PSYMCRYPT_PARALLEL_HASH_OPERATION) buf2;
    PSYMCRYPT_PARALLEL_HASH_OPERATION pOp = pOperations;

    PBYTE pSrc = buf3;
    PBYTE pDst = buf3 + PERF_BUFFER_SIZE / 2;

    for( i=0; i<N_PARALLEL_FOR_PERF; i++ )
    {
        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_APPEND;
        pOp->pbBuffer = pSrc;
        pOp->cbBuffer = dataSize / N_PARALLEL_FOR_PERF;

        pOp++;
        pSrc += dataSize / N_PARALLEL_FOR_PERF;

        pOp->iHash = i;
        pOp->hashOperation = SYMCRYPT_HASH_OPERATION_RESULT;
        pOp->pbBuffer = pDst;
        pOp->cbBuffer = 64;

        pOp++;
        pDst += 64;
    }
    ScShimSymCryptParallelSha512Process(
        pState, N_PARALLEL_FOR_PERF, pOperations, 2 * N_PARALLEL_FOR_PERF, buf1 + PERF_BUFFER_SIZE / 2, PERF_BUFFER_SIZE / 2);
}

template<>
ParallelHashImp<ImpXxx, AlgParallelSha512>::ParallelHashImp()
{
    m_perfDataFunction = &algImpDataPerfFunction <ImpXxx, AlgParallelSha512>;
    m_perfKeyFunction  = &algImpKeyPerfFunction  <ImpXxx, AlgParallelSha512>;
    m_perfCleanFunction= &algImpCleanPerfFunction<ImpXxx, AlgParallelSha512>;

    state.nHashes = 0;
};

template<>
ParallelHashImp<ImpXxx, AlgParallelSha512>::~ParallelHashImp() {};

template<>
PCSYMCRYPT_HASH
ParallelHashImp<ImpXxx, AlgParallelSha512>::SymCryptHash()
{
    return ScShimSymCryptSha512Algorithm;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha512>::resultLen()
{
    return SYMCRYPT_SHA512_RESULT_SIZE;
}

template<>
SIZE_T ParallelHashImp<ImpXxx, AlgParallelSha512>::inputBlockLen()
{
    return SYMCRYPT_SHA512_INPUT_BLOCK_SIZE;
}


template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha512>::init( SIZE_T nHashes )
{
    CHECK( nHashes <= MAX_PARALLEL_HASH_STATES, "Too many hash states requested" );
    state.nHashes = nHashes;
    ScShimSymCryptParallelSha512Init( &state.sc[0], nHashes );
}

template<>
VOID
ParallelHashImp<ImpXxx, AlgParallelSha512>::process(
        _In_reads_( nOperations )   BCRYPT_MULTI_HASH_OPERATION *   pOperations,
                                    SIZE_T                          nOperations )
{
    SYMCRYPT_ERROR                      scError;
    SYMCRYPT_PARALLEL_HASH_OPERATION    op[MAX_PARALLEL_HASH_OPERATIONS];
    BYTE                                scratch[SYMCRYPT_PARALLEL_SHA512_FIXED_SCRATCH + SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH * MAX_PARALLEL_HASH_STATES + 128];

    CHECK( nOperations <= MAX_PARALLEL_HASH_OPERATIONS, "Too many operations" );

    for( SIZE_T i=0; i<nOperations; i++ )
    {
        op[i].iHash = pOperations[i].iHash;
        op[i].hashOperation = pOperations[i].hashOperation == BCRYPT_HASH_OPERATION_HASH_DATA ? SYMCRYPT_HASH_OPERATION_APPEND : SYMCRYPT_HASH_OPERATION_RESULT;
        op[i].pbBuffer = pOperations[i].pbBuffer;
        op[i].cbBuffer = pOperations[i].cbBuffer;

        CHECK( op[i].iHash < state.nHashes, "?" );
    }

    SIZE_T scratchOffset = g_rng.sizet( 64 );
    BYTE sentinel = g_rng.byte();
    SIZE_T nScratch = SYMCRYPT_PARALLEL_SHA512_FIXED_SCRATCH + state.nHashes * SYMCRYPT_PARALLEL_HASH_PER_STATE_SCRATCH;
    CHECK( nScratch + scratchOffset <= sizeof( scratch ), "?" );
    SYMCRYPT_ASSERT( nScratch + scratchOffset < sizeof( scratch ) );

    scratch[scratchOffset + nScratch] = sentinel;

    SYMCRYPT_ASSERT( state.nHashes <= MAX_PARALLEL_HASH_STATES );
    scError = ScShimSymCryptParallelSha512Process(
                                &state.sc[0],
                                state.nHashes,
                                &op[0],
                                nOperations,
                                &scratch[scratchOffset],
                                nScratch );
    CHECK( scError == SYMCRYPT_NO_ERROR, "Parallel SHA512 returned an error" );
    CHECK( scratch[scratchOffset + nScratch] == sentinel, "Parallel SHA512 used too much scratch space" );
}

template<>
NTSTATUS
ParallelHashImp<ImpXxx, AlgParallelSha512>::initWithLongMessage( ULONGLONG nBytes )
{
    // Discard this test for dynamic modules as it modifies state internals
    if constexpr ( std::is_same<ImpXxx, ImpScDynamic>::value )
    {
        return STATUS_NOT_SUPPORTED;
    }

    CHECK( nBytes % 128 == 0, "Odd bytes in initWithLongMessage" );
    CHECK( state.nHashes <= MAX_PARALLEL_HASH_STATES, "?" );

    for( SIZE_T i=0; i<state.nHashes; i++ )
    {
        memset( &state.sc[i].chain, 'b', sizeof( state.sc[i].chain ) );
        state.sc[i].dataLengthL = nBytes;
        state.sc[i].dataLengthH = 0;
        state.sc[i].bytesInBuffer = 0;
    }

    return STATUS_SUCCESS;
}



//////////////////////////////////////////////////////////////////////////////////////////////
//  XTS-AES
//
struct CONCAT2(ImpXxx, XtsAesExpandedKeyContext) {
    SYMCRYPT_XTS_AES_EXPANDED_KEY expandedKey;
    SIZE_T dataUnitSize;
};

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgXtsAes>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );
    SIZE_T actualKeySize = keySize & ~PERF_KEY_FLAGS_MASK;
    SIZE_T dataUnitSize = 512;
    if( (keySize & PERF_KEY_FLAGS_MASK) == PERF_KEY_XTS_DATA_UNIT_4096 )
    {
        dataUnitSize = 4096;
    }

    CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *context = (CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *)buf1;
    ScShimSymCryptXtsAesExpandKeyEx( &context->expandedKey, buf2, actualKeySize, SYMCRYPT_FLAG_KEY_NO_FIPS );
    context->dataUnitSize = dataUnitSize;
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgXtsAes>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *context = (CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *)buf1;
    ScShimSymCryptXtsAesEncrypt(
                        &context->expandedKey,
                        context->dataUnitSize,
                        'twek',
                        buf2,
                        buf3,
                        dataSize );
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgXtsAes>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *context = (CONCAT2(ImpXxx, XtsAesExpandedKeyContext) *)buf1;
    ScShimSymCryptXtsAesDecrypt(
                        &context->expandedKey,
                        context->dataUnitSize,
                        'twek',
                        buf2,
                        buf3,
                        dataSize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgXtsAes>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_XTS_AES_EXPANDED_KEY ) );
}


template<>
XtsImp<ImpXxx, AlgXtsAes>::XtsImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction<ImpXxx, AlgXtsAes>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgXtsAes>;
    m_perfKeyFunction       = &algImpKeyPerfFunction<ImpXxx, AlgXtsAes>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgXtsAes>;
}

template<>
XtsImp<ImpXxx, AlgXtsAes>::~XtsImp()
{
    SymCryptWipeKnownSize( &state.key, sizeof( state.key ) );
}

template<>
NTSTATUS
XtsImp<ImpXxx, AlgXtsAes>::setKey( PCBYTE pbKey, SIZE_T cbKey, UINT32 flags )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptXtsAesExpandKeyEx( &state.key, pbKey, cbKey, flags );

    return scError == SYMCRYPT_NO_ERROR ? 0 : STATUS_NOT_SUPPORTED;
}

template<>
NTSTATUS
XtsImp<ImpXxx, AlgXtsAes>::encrypt(
                                        SIZE_T      cbDataUnit,
                                        ULONGLONG   tweak,
        _In_reads_( cbData )            PCBYTE      pbSrc,
        _Out_writes_( cbData )          PBYTE       pbDst,
                                        SIZE_T      cbData )
{
    ScShimSymCryptXtsAesEncrypt(
                        &state.key,
                        cbDataUnit,
                        tweak,
                        pbSrc,
                        pbDst,
                        cbData );
    return 0;
}

template<>
NTSTATUS
XtsImp<ImpXxx, AlgXtsAes>::decrypt(
                                        SIZE_T      cbDataUnit,
                                        ULONGLONG   tweak,
        _In_reads_( cbData )            PCBYTE      pbSrc,
        _Out_writes_( cbData )          PBYTE       pbDst,
                                        SIZE_T      cbData )
{
    ScShimSymCryptXtsAesDecrypt(
                        &state.key,
                        cbDataUnit,
                        tweak,
                        pbSrc,
                        pbDst,
                        cbData );
    return 0;
}

template<>
NTSTATUS
XtsImp<ImpXxx, AlgXtsAes>::encryptWith128bTweak(
                                                SIZE_T  cbDataUnit,
        _In_reads_( SYMCRYPT_AES_BLOCK_SIZE )   PCBYTE  pbTweak,
        _In_reads_( cbData )                    PCBYTE  pbSrc,
        _Out_writes_( cbData )                  PBYTE   pbDst,
                                                SIZE_T  cbData )
{
    ScShimSymCryptXtsAesEncryptWith128bTweak(
                        &state.key,
                        cbDataUnit,
                        pbTweak,
                        pbSrc,
                        pbDst,
                        cbData );
    return 0;
}

template<>
NTSTATUS
XtsImp<ImpXxx, AlgXtsAes>::decryptWith128bTweak(
                                                SIZE_T  cbDataUnit,
        _In_reads_( SYMCRYPT_AES_BLOCK_SIZE )   PCBYTE  pbTweak,
        _In_reads_( cbData )                    PCBYTE  pbSrc,
        _Out_writes_( cbData )                  PBYTE   pbDst,
                                                SIZE_T  cbData )
{
    ScShimSymCryptXtsAesDecryptWith128bTweak(
                        &state.key,
                        cbDataUnit,
                        pbTweak,
                        pbSrc,
                        pbDst,
                        cbData );
    return 0;
}


///////////////////////
//  TlsCbcHmacSha256

template<> VOID algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize );
template<> VOID algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3 );
template<> VOID algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );
template<> VOID algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha256>::TlsCbcHmacImp()
{
    m_perfKeyFunction       = &algImpKeyPerfFunction    <ImpXxx, AlgTlsCbcHmacSha256>;
    m_perfCleanFunction     = &algImpCleanPerfFunction  <ImpXxx, AlgTlsCbcHmacSha256>;
    m_perfDataFunction      = &algImpDataPerfFunction   <ImpXxx, AlgTlsCbcHmacSha256>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>;
}

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha256>::~TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha256>()
{
}

template<>
NTSTATUS
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha256>::verify(
    _In_reads_( cbKey )     PCBYTE  pbKey,
                            SIZE_T  cbKey,
    _In_reads_( cbHeader )  PCBYTE  pbHeader,
                            SIZE_T  cbHeader,
    _In_reads_( cbData )    PCBYTE  pbData,
                            SIZE_T  cbData )
{
    SYMCRYPT_HMAC_SHA256_EXPANDED_KEY   key;
    SYMCRYPT_HMAC_SHA256_STATE          state;
    SYMCRYPT_ERROR scError;
    NTSTATUS status;

    ScShimSymCryptHmacSha256ExpandKey( &key, pbKey, cbKey );
    ScShimSymCryptHmacSha256Init( &state, &key );

    ScShimSymCryptHmacSha256Append( &state, pbHeader, cbHeader );
    scError = ScShimSymCryptTlsCbcHmacVerify( ScShimSymCryptHmacSha256Algorithm, &key, &state, pbData, cbData );

    status = scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    return status;
}

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );
    ScShimSymCryptHmacSha256ExpandKey( (SYMCRYPT_HMAC_SHA256_EXPANDED_KEY *) buf1, buf2, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_HMAC_SHA256_EXPANDED_KEY ) );
}


template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA256_STATE state;
    UINT32 paddingSize;

    ScShimSymCryptHmacSha256Init( &state, (SYMCRYPT_HMAC_SHA256_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha256Append( &state, buf3, 13 );       // typical header is 13 bytes
    ScShimSymCryptHmacSha256Append( &state, buf2, dataSize );
    ScShimSymCryptHmacSha256Result( &state, &buf2[ dataSize ] );

    paddingSize = 15 - (dataSize & 15);

    memset( &buf2[dataSize + SYMCRYPT_HMAC_SHA256_RESULT_SIZE], (BYTE) paddingSize, paddingSize + 1);
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha256>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA256_STATE  state;
    SYMCRYPT_ERROR scError;

    ScShimSymCryptHmacSha256Init( &state, (SYMCRYPT_HMAC_SHA256_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha256Append( &state, buf3, 13 );


    scError = ScShimSymCryptTlsCbcHmacVerify(
        ScShimSymCryptHmacSha256Algorithm,
        (SYMCRYPT_HMAC_SHA256_EXPANDED_KEY *) buf1,
        &state,
        buf2,
        ((dataSize + 16) & ~15) + SYMCRYPT_HMAC_SHA256_RESULT_SIZE);

    SYMCRYPT_ASSERT( scError == SYMCRYPT_NO_ERROR );
}


///////////////////////
//  TlsCbcHmacSha1

template<> VOID algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize );
template<> VOID algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3 );
template<> VOID algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );
template<> VOID algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha1>::TlsCbcHmacImp()
{
    m_perfKeyFunction       = &algImpKeyPerfFunction    <ImpXxx, AlgTlsCbcHmacSha1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction  <ImpXxx, AlgTlsCbcHmacSha1>;
    m_perfDataFunction      = &algImpDataPerfFunction   <ImpXxx, AlgTlsCbcHmacSha1>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>;
}

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha1>::~TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha1>()
{
}

template<>
NTSTATUS
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha1>::verify(
    _In_reads_( cbKey )     PCBYTE  pbKey,
    SIZE_T  cbKey,
    _In_reads_( cbHeader )  PCBYTE  pbHeader,
    SIZE_T  cbHeader,
    _In_reads_( cbData )    PCBYTE  pbData,
    SIZE_T  cbData )
{
    SYMCRYPT_HMAC_SHA1_EXPANDED_KEY   key;
    SYMCRYPT_HMAC_SHA1_STATE          state;
    SYMCRYPT_ERROR scError;
    NTSTATUS status;

    ScShimSymCryptHmacSha1ExpandKey( &key, pbKey, cbKey );
    ScShimSymCryptHmacSha1Init( &state, &key );

    ScShimSymCryptHmacSha1Append( &state, pbHeader, cbHeader );
    scError = ScShimSymCryptTlsCbcHmacVerify( ScShimSymCryptHmacSha1Algorithm, &key, &state, pbData, cbData );

    status = scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    return status;
}

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );
    ScShimSymCryptHmacSha1ExpandKey( (SYMCRYPT_HMAC_SHA1_EXPANDED_KEY *) buf1, buf2, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_HMAC_SHA1_EXPANDED_KEY ) );
}


template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA1_STATE state;
    UINT32 paddingSize;

    ScShimSymCryptHmacSha1Init( &state, (SYMCRYPT_HMAC_SHA1_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha1Append( &state, buf3, 13 );       // typical header is 13 bytes
    ScShimSymCryptHmacSha1Append( &state, buf2, dataSize );
    ScShimSymCryptHmacSha1Result( &state, &buf2[ dataSize ] );

    paddingSize = 15 - ((dataSize + SYMCRYPT_HMAC_SHA1_RESULT_SIZE) & 15);

    memset( &buf2[dataSize + SYMCRYPT_HMAC_SHA1_RESULT_SIZE], (BYTE) paddingSize, paddingSize + 1);
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA1_STATE  state;
    SYMCRYPT_ERROR scError;

    ScShimSymCryptHmacSha1Init( &state, (SYMCRYPT_HMAC_SHA1_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha1Append( &state, buf3, 13 );

    scError = ScShimSymCryptTlsCbcHmacVerify(
        ScShimSymCryptHmacSha1Algorithm,
        (SYMCRYPT_HMAC_SHA1_EXPANDED_KEY *) buf1,
        &state,
        buf2,
        ((dataSize + SYMCRYPT_HMAC_SHA1_RESULT_SIZE + 16) & ~15));

    SYMCRYPT_ASSERT( scError == SYMCRYPT_NO_ERROR );
}


///////////////////////
//  TlsCbcHmacSha384

template<> VOID algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize );
template<> VOID algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3 );
template<> VOID algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );
template<> VOID algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize );

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha384>::TlsCbcHmacImp()
{
    m_perfKeyFunction       = &algImpKeyPerfFunction    <ImpXxx, AlgTlsCbcHmacSha384>;
    m_perfCleanFunction     = &algImpCleanPerfFunction  <ImpXxx, AlgTlsCbcHmacSha384>;
    m_perfDataFunction      = &algImpDataPerfFunction   <ImpXxx, AlgTlsCbcHmacSha384>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>;
}

template<>
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha384>::~TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha384>()
{
}

template<>
NTSTATUS
TlsCbcHmacImp<ImpXxx, AlgTlsCbcHmacSha384>::verify(
    _In_reads_( cbKey )     PCBYTE  pbKey,
    SIZE_T  cbKey,
    _In_reads_( cbHeader )  PCBYTE  pbHeader,
    SIZE_T  cbHeader,
    _In_reads_( cbData )    PCBYTE  pbData,
    SIZE_T  cbData )
{
    SYMCRYPT_HMAC_SHA384_EXPANDED_KEY   key;
    SYMCRYPT_HMAC_SHA384_STATE          state;
    SYMCRYPT_ERROR scError;
    NTSTATUS status;

    ScShimSymCryptHmacSha384ExpandKey( &key, pbKey, cbKey );
    ScShimSymCryptHmacSha384Init( &state, &key );

    ScShimSymCryptHmacSha384Append( &state, pbHeader, cbHeader );
    scError = ScShimSymCryptTlsCbcHmacVerify( ScShimSymCryptHmacSha384Algorithm, &key, &state, pbData, cbData );

    status = scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;

    return status;
}

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );
    ScShimSymCryptHmacSha384ExpandKey( (SYMCRYPT_HMAC_SHA384_EXPANDED_KEY *) buf1, buf2, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    SymCryptWipeKnownSize( buf1, sizeof( SYMCRYPT_HMAC_SHA384_EXPANDED_KEY ) );
}


template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA384_STATE state;
    UINT32 paddingSize;

    ScShimSymCryptHmacSha384Init( &state, (SYMCRYPT_HMAC_SHA384_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha384Append( &state, buf3, 13 );       // typical header is 13 bytes
    ScShimSymCryptHmacSha384Append( &state, buf2, dataSize );
    ScShimSymCryptHmacSha384Result( &state, &buf2[ dataSize ] );

    paddingSize = 15 - (dataSize & 15);

    memset( &buf2[dataSize + SYMCRYPT_HMAC_SHA384_RESULT_SIZE], (BYTE) paddingSize, paddingSize + 1);
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgTlsCbcHmacSha384>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_HMAC_SHA384_STATE  state;
    SYMCRYPT_ERROR scError;

    ScShimSymCryptHmacSha384Init( &state, (SYMCRYPT_HMAC_SHA384_EXPANDED_KEY *) buf1 );
    ScShimSymCryptHmacSha384Append( &state, buf3, 13 );

    scError = ScShimSymCryptTlsCbcHmacVerify(
        ScShimSymCryptHmacSha384Algorithm,
        (SYMCRYPT_HMAC_SHA384_EXPANDED_KEY *) buf1,
        &state,
        buf2,
        ((dataSize + 16) & ~15) + SYMCRYPT_HMAC_SHA384_RESULT_SIZE);

    SYMCRYPT_ASSERT( scError == SYMCRYPT_NO_ERROR );
}

//============================
// The DeveloperTest algorithm is just for tests during active development.

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgDeveloperTest>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgDeveloperTest>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

//extern "C" { VOID SYMCRYPT_CALL SymCryptTestMulx(); }

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgDeveloperTest>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    //SymCryptTestMulx();
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );
}


template<>
ArithImp<ImpXxx, AlgDeveloperTest>::ArithImp()
{
    // if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptTestMulx))
    // {
    //     throw STATUS_NOT_SUPPORTED;
    // }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDeveloperTest>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDeveloperTest>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDeveloperTest>;
}

template<>
ArithImp<ImpXxx, AlgDeveloperTest>::~ArithImp()
{
}



//============================

// Table with the RSA keys' sizes and pointers to keys
struct {
    SIZE_T                      keySize;
    UINT32                      generateFlags;
    PSYMCRYPT_RSAKEY            pkRsakey;
} CONCAT2(g_precomputedRsaKeys, ImpXxx)[] = {
    {  32, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    {  64, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    { 128, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    { 256, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    { 384, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    { 512, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    {1024, SYMCRYPT_FLAG_RSAKEY_SIGN, NULL },
    {  32, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    {  64, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    { 128, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    { 256, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    { 384, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    { 512, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
    {1024, SYMCRYPT_FLAG_RSAKEY_ENCRYPT, NULL },
};

template<>
void
SetupSymCryptRsaKey<ImpXxx>( PBYTE buf1, SIZE_T keySize, UINT32 generateFlags )
{
    SIZE_T i = 0;
    BOOLEAN bFound = FALSE;

    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    for( i=0; i < ARRAY_SIZE(CONCAT2(g_precomputedRsaKeys, ImpXxx)); i++ )
    {
        if ( keySize == CONCAT2(g_precomputedRsaKeys, ImpXxx)[i].keySize &&
             generateFlags == CONCAT2(g_precomputedRsaKeys, ImpXxx)[i].generateFlags )
        {
            bFound = TRUE;

            if ( CONCAT2(g_precomputedRsaKeys, ImpXxx)[i].pkRsakey == NULL )
            {
                SYMCRYPT_RSA_PARAMS rsaParams = { 0 };
                PSYMCRYPT_RSAKEY pkRsakey = NULL;

                // Set the parameters
                rsaParams.version = 1;
                rsaParams.nBitsOfModulus = ((UINT32)keySize) * 8;
                rsaParams.nPrimes = 2;
                rsaParams.nPubExp = 1;

                pkRsakey = ScShimSymCryptRsakeyAllocate( &rsaParams, 0 );
                CHECK( pkRsakey != NULL, "?" );

                if ( rsaParams.nBitsOfModulus < SYMCRYPT_RSAKEY_FIPS_MIN_BITSIZE_MODULUS )
                {
                    generateFlags |= SYMCRYPT_FLAG_KEY_NO_FIPS;
                }

                // Use default exponent
                scError = ScShimSymCryptRsakeyGenerate( pkRsakey, nullptr, 0, generateFlags );
                CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

                CONCAT2(g_precomputedRsaKeys, ImpXxx)[i].pkRsakey = pkRsakey;
            }

            break;
        }
    }

    CHECK( bFound, "?" );

    *((PSYMCRYPT_RSAKEY *) buf1) = CONCAT2(g_precomputedRsaKeys, ImpXxx)[i].pkRsakey;
}

template<>
void
sc_RsaKeyPerf<ImpXxx>( PBYTE buf1, PBYTE buf2, SIZE_T keySize, UINT32 generateFlags )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    SetupSymCryptRsaKey<ImpXxx>( buf1, keySize, generateFlags );

    buf2[0] = 0;
    // Don't fill it up so that it is smaller than the modulus
#if IMP_UseSymCryptRandom
    ScShimSymCryptRandom( buf2 + 1, keySize - 1 );
#else
    scError = ScShimSymCryptCallbackRandom( buf2 + 1, keySize - 1 );
#endif
    CHECK(scError == SYMCRYPT_NO_ERROR, "?");
}

//================================================


HASH_INFO CONCAT2(hashInfoTable, ImpXxx)[9] = { 0 };

template<>
PCHASH_INFO getHashInfo<ImpXxx>(PCSTR pcstrName)
{
    if( CONCAT2(hashInfoTable, ImpXxx)[0].name == NULL )
    {
        CONCAT2(hashInfoTable, ImpXxx)[0] = { "MD5",    ScShimSymCryptMd5Algorithm,     ScShimSymCryptMd5OidList,    SYMCRYPT_MD5_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[1] = { "SHA1",   ScShimSymCryptSha1Algorithm,    ScShimSymCryptSha1OidList,   SYMCRYPT_SHA1_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[2] = { "SHA256", ScShimSymCryptSha256Algorithm,  ScShimSymCryptSha256OidList, SYMCRYPT_SHA256_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[3] = { "SHA384", ScShimSymCryptSha384Algorithm,  ScShimSymCryptSha384OidList, SYMCRYPT_SHA384_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[4] = { "SHA512", ScShimSymCryptSha512Algorithm,  ScShimSymCryptSha512OidList, SYMCRYPT_SHA512_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[5] = { "SHA3_256", ScShimSymCryptSha3_256Algorithm,  ScShimSymCryptSha3_256OidList, SYMCRYPT_SHA3_256_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[6] = { "SHA3_384", ScShimSymCryptSha3_384Algorithm,  ScShimSymCryptSha3_384OidList, SYMCRYPT_SHA3_384_OID_COUNT };
        CONCAT2(hashInfoTable, ImpXxx)[7] = { "SHA3_512", ScShimSymCryptSha3_512Algorithm,  ScShimSymCryptSha3_512OidList, SYMCRYPT_SHA3_512_OID_COUNT };
    }

    for (int i = 0; CONCAT2(hashInfoTable, ImpXxx)[i].name != NULL; i++)
    {
        if( STRICMP( pcstrName, CONCAT2(hashInfoTable, ImpXxx)[i].name ) == 0 )
        {
            return &CONCAT2(hashInfoTable, ImpXxx)[i];
        }
    }
    CHECK( FALSE, "?" );
    return NULL;
}

// Rsa Pkcs1 Sign
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaSignPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    SIZE_T cbDst = 0;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_SIGN );

    scError = ScShimSymCryptRsaPkcs1Sign(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    PERF_RSA_HASH_ALG_OIDS_SC,
                    PERF_RSA_HASH_ALG_NOIDS_SC,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize, "?" );

    scError = ScShimSymCryptRsaPkcs1Verify(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_OIDS_SC,
                    PERF_RSA_HASH_ALG_NOIDS_SC,
                    0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaSignPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaSignPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaPkcs1Sign(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            PERF_RSA_HASH_ALG_SIZE,
            PERF_RSA_HASH_ALG_OIDS_SC,
            PERF_RSA_HASH_ALG_NOIDS_SC,
            0,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            buf3,
            dataSize,
            &cbDst );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgRsaSignPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRsaPkcs1Verify(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    buf3,
                    dataSize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_OIDS_SC,
                    PERF_RSA_HASH_ALG_NOIDS_SC,
                    0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
RsaSignImp<ImpXxx, AlgRsaSignPkcs1>::RsaSignImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaSignPkcs1>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction< ImpXxx, AlgRsaSignPkcs1>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPkcs1>;

    state.pKey = NULL;
}

template<>
RsaSignImp<ImpXxx, AlgRsaSignPkcs1>::~RsaSignImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPkcs1>::setKey( PCRSAKEY_TESTBLOB pcKeyBlob )
{
    SYMCRYPT_ERROR scError;

    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }

    if( pcKeyBlob == NULL )
    {
        // Just used to clear the key state to do leak detection
        return STATUS_SUCCESS;
    }

    SYMCRYPT_RSA_PARAMS params;
    params.version = 1;
    params.nBitsOfModulus = pcKeyBlob->nBitsModulus;
    params.nPrimes = 2;
    params.nPubExp = 1;

    state.pKey = ScShimSymCryptRsakeyAllocate( &params, 0 );
    CHECK( state.pKey != NULL, "?" );

    PCBYTE ppPrime[2] = {&pcKeyBlob->abPrime1[0], &pcKeyBlob->abPrime2[0] };
    SIZE_T cbPrime[2] = {pcKeyBlob->cbPrime1, pcKeyBlob->cbPrime2 };

    scError = ScShimSymCryptRsakeySetValue(
        &pcKeyBlob->abModulus[0], pcKeyBlob->cbModulus,
        &pcKeyBlob->u64PubExp, 1,
        ppPrime, cbPrime, 2,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        SYMCRYPT_FLAG_RSAKEY_SIGN,
        state.pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPkcs1>::sign(
    _In_reads_( cbHash)     PCBYTE  pbHash,
                            SIZE_T  cbHash,
                            PCSTR   pcstrHashAlgName,
                            UINT32  u32Other,
    _Out_writes_( cbSig )   PBYTE   pbSig,
                            SIZE_T  cbSig )
{
    PCHASH_INFO pInfo;
    SYMCRYPT_ERROR scError;
    SIZE_T cbTmp;

    UNREFERENCED_PARAMETER( u32Other );

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName);
    scError = ScShimSymCryptRsaPkcs1Sign(
                    state.pKey,
                    pbHash,
                    cbHash,
                    pInfo->pcOids,
                    pInfo->nOids,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    pbSig,
                    cbSig,
                    &cbTmp );
    CHECK( scError == SYMCRYPT_NO_ERROR && cbTmp == cbSig, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPkcs1>::verify(
    _In_reads_( cbHash)     PCBYTE  pbHash,
                            SIZE_T  cbHash,
    _In_reads_( cbSig )     PCBYTE  pbSig,
                            SIZE_T  cbSig,
                            PCSTR   pcstrHashAlgName,
                            UINT32  u32Other )
{
    SYMCRYPT_ERROR scError;
    NTSTATUS ntStatus;
    PCHASH_INFO pInfo;

    UNREFERENCED_PARAMETER( u32Other );

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName);
    scError = ScShimSymCryptRsaPkcs1Verify(
                    state.pKey,
                    pbHash,
                    cbHash,
                    pbSig,
                    cbSig,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    pInfo->pcOids,
                    pInfo->nOids,
                    0 );

    switch( scError )
    {
    case SYMCRYPT_NO_ERROR:
        ntStatus = STATUS_SUCCESS;
        break;
    case SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE:
        ntStatus = STATUS_INVALID_SIGNATURE;
        break;
    case SYMCRYPT_INVALID_ARGUMENT:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        iprint( "Unexpected SymCrypt error %08x, %d, %d, %s\n", scError, cbHash, cbSig, pcstrHashAlgName );
        CHECK( FALSE, "?" );
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}


// Rsa Pss Sign
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaSignPss>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    SIZE_T cbDst = 0;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_SIGN );

    scError = ScShimSymCryptRsaPssSign(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    PERF_RSA_HASH_ALG_SC,
                    PERF_RSA_HASH_ALG_SIZE,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize, "?" );

    scError = ScShimSymCryptRsaPssVerify(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_SC,
                    PERF_RSA_HASH_ALG_SIZE,
                    0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaSignPss>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaSignPss>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaPssSign(
        *((PSYMCRYPT_RSAKEY *) buf1),
        buf2,
        PERF_RSA_HASH_ALG_SIZE,
        PERF_RSA_HASH_ALG_SC,
        PERF_RSA_HASH_ALG_SIZE,
        0,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        buf3,
        dataSize,
        &cbDst );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgRsaSignPss>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRsaPssVerify(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    PERF_RSA_HASH_ALG_SIZE,
                    buf3,
                    dataSize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_SC,
                    PERF_RSA_HASH_ALG_SIZE,
                    0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
RsaSignImp<ImpXxx, AlgRsaSignPss>::RsaSignImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaSignPss>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction< ImpXxx, AlgRsaSignPss>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPss>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPss>;

    state.pKey = NULL;
}

template<>
RsaSignImp<ImpXxx, AlgRsaSignPss>::~RsaSignImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPss>::setKey( PCRSAKEY_TESTBLOB pcKeyBlob )
{
    SYMCRYPT_ERROR scError;

    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }

    if( pcKeyBlob == NULL )
    {
        // Just used to clear the key state to do leak detection
        return STATUS_SUCCESS;
    }

    SYMCRYPT_RSA_PARAMS params;
    params.version = 1;
    params.nBitsOfModulus = pcKeyBlob->nBitsModulus;
    params.nPrimes = 2;
    params.nPubExp = 1;

    state.pKey = ScShimSymCryptRsakeyAllocate( &params, 0 );
    CHECK( state.pKey != NULL, "?" );

    PCBYTE ppPrime[2] = {&pcKeyBlob->abPrime1[0], &pcKeyBlob->abPrime2[0] };
    SIZE_T cbPrime[2] = {pcKeyBlob->cbPrime1, pcKeyBlob->cbPrime2 };

    scError = ScShimSymCryptRsakeySetValue(
        &pcKeyBlob->abModulus[0], pcKeyBlob->cbModulus,
        &pcKeyBlob->u64PubExp, 1,
        ppPrime, cbPrime, 2,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        SYMCRYPT_FLAG_RSAKEY_SIGN,
        state.pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPss>::sign(
    _In_reads_( cbHash)     PCBYTE  pbHash,
                            SIZE_T  cbHash,
                            PCSTR   pcstrHashAlgName,
                            UINT32  u32Other,
    _Out_writes_( cbSig )   PBYTE   pbSig,
                            SIZE_T  cbSig )
{
    PCHASH_INFO pInfo;
    SYMCRYPT_ERROR scError;
    SIZE_T cbTmp;

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName);
    scError = ScShimSymCryptRsaPssSign(
                    state.pKey,
                    pbHash,
                    cbHash,
                    pInfo->pcHash,
                    u32Other,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    pbSig,
                    cbSig,
                    &cbTmp );
    CHECK( scError == SYMCRYPT_NO_ERROR && cbTmp == cbSig, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaSignImp<ImpXxx, AlgRsaSignPss>::verify(
    _In_reads_( cbHash)     PCBYTE  pbHash,
                            SIZE_T  cbHash,
    _In_reads_( cbSig )     PCBYTE  pbSig,
                            SIZE_T  cbSig,
                            PCSTR   pcstrHashAlgName,
                            UINT32  u32Other )
{
    SYMCRYPT_ERROR scError;
    NTSTATUS ntStatus;
    PCHASH_INFO pInfo;

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName);
    scError = ScShimSymCryptRsaPssVerify(
                    state.pKey,
                    pbHash,
                    cbHash,
                    pbSig,
                    cbSig,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    pInfo->pcHash,
                    u32Other,
                    0 );

    // Test corner cases of PSS verification w.r.t. cbSalt when we have a known-good signature we can work with
    // This does not test that we don't spuriously verify some signature with a random signature modification and
    // incorrect cbSalt; but such a failure in our verification routine is highly implausible
    if( scError == SYMCRYPT_NO_ERROR )
    {
        scError = ScShimSymCryptRsaPssVerify(
                        state.pKey,
                        pbHash,
                        cbHash,
                        pbSig,
                        cbSig,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        pInfo->pcHash,
                        u32Other+1,
                        0 );
        if( scError == SYMCRYPT_NO_ERROR )
        {
            iprint( "Unexpected PSS verification success with too-large cbSalt: %d, %d, %d, %s\n",
                    u32Other+1, cbHash, cbSig, pcstrHashAlgName );
            CHECK( FALSE, "?" );
        }

        scError = ScShimSymCryptRsaPssVerify(
                        state.pKey,
                        pbHash,
                        cbHash,
                        pbSig,
                        cbSig,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        pInfo->pcHash,
                        u32Other-1,
                        0 );
        if( scError == SYMCRYPT_NO_ERROR )
        {
            iprint( "Unexpected PSS verification success with too-small cbSalt: %d, %d, %d, %s\n",
                    u32Other-1, cbHash, cbSig, pcstrHashAlgName );
            CHECK( FALSE, "?" );
        }

        scError = ScShimSymCryptRsaPssVerify(
                        state.pKey,
                        pbHash,
                        cbHash,
                        pbSig,
                        cbSig,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        pInfo->pcHash,
                        u32Other,
                        SYMCRYPT_FLAG_RSA_PSS_VERIFY_WITH_MINIMUM_SALT );
        if( scError != SYMCRYPT_NO_ERROR )
        {
            iprint( "Unexpected PSS verification failure with MINIMUM_SALT flag and unchanged cbSalt: %08x, %d, %d, %d, %s\n",
                    scError, u32Other, cbHash, cbSig, pcstrHashAlgName );
            CHECK( FALSE, "?" );
        }

        scError = ScShimSymCryptRsaPssVerify(
                        state.pKey,
                        pbHash,
                        cbHash,
                        pbSig,
                        cbSig,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        pInfo->pcHash,
                        0,
                        SYMCRYPT_FLAG_RSA_PSS_VERIFY_WITH_MINIMUM_SALT );
        if( scError != SYMCRYPT_NO_ERROR )
        {
            iprint( "Unexpected PSS verification failure with MINIMUM_SALT flag and 0 cbSalt: %08x, %d, %d, %s\n",
                    scError, cbHash, cbSig, pcstrHashAlgName );
            CHECK( FALSE, "?" );
        }

        scError = ScShimSymCryptRsaPssVerify(
                        state.pKey,
                        pbHash,
                        cbHash,
                        pbSig,
                        cbSig,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        pInfo->pcHash,
                        u32Other+1,
                        SYMCRYPT_FLAG_RSA_PSS_VERIFY_WITH_MINIMUM_SALT );
        if( scError == SYMCRYPT_NO_ERROR )
        {
            iprint( "Unexpected PSS verification success with MINIMUM_SALT flag and too-large cbSalt: %d, %d, %d, %s\n",
                    u32Other+1, cbHash, cbSig, pcstrHashAlgName );
            CHECK( FALSE, "?" );
        }

        scError = SYMCRYPT_NO_ERROR;
    }

    switch( scError )
    {
    case SYMCRYPT_NO_ERROR:
        ntStatus = STATUS_SUCCESS;
        break;
        // saml 2022/04:
        // In order to update error message returned from SymCryptRsaPssVerify and not break
        // multi-implementation test of SymCrypt vs. CNG, we must map SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE
        // to STATUS_INVALID_PARAMETER rather than STATUS_INVALID_SIGNATURE for now.
        // Once both CNG and SymCrypt are updated reliably we can reintroduce testing that the two
        // error responses cohere - but for now they won't.
    case SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE:
    case SYMCRYPT_INVALID_ARGUMENT:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        iprint( "Unexpected SymCrypt error %08x, %d, %d, %s\n", scError, cbHash, cbSig, pcstrHashAlgName );
        CHECK( FALSE, "?" );
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}



// Rsa Encryption

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaEncRaw>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_ENCRYPT );

    scError = ScShimSymCryptRsaRawEncrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf3,
                    keySize );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    scError = ScShimSymCryptRsaRawDecrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf2 + keySize,
                    keySize );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( memcmp(buf2, buf2 + keySize, keySize) == 0, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaEncRaw>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaEncRaw>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptRsaRawEncrypt(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            dataSize,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            0,
            buf3,
            dataSize );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgRsaEncRaw>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRsaRawDecrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    dataSize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf2 + dataSize,
                    dataSize );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}


template<>
RsaEncImp<ImpXxx, AlgRsaEncRaw>::RsaEncImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaEncRaw>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgRsaEncRaw>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncRaw>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncRaw>;

    state.pKey = NULL;
}

template<>
RsaEncImp<ImpXxx, AlgRsaEncRaw>::~RsaEncImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncRaw>::setKey( PCRSAKEY_TESTBLOB pcKeyBlob )
{
    SYMCRYPT_ERROR scError;

    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }

    if( pcKeyBlob == NULL )
    {
        // Just used to clear the key state to do leak detection
        return STATUS_SUCCESS;
    }

    SYMCRYPT_RSA_PARAMS params;
    params.version = 1;
    params.nBitsOfModulus = pcKeyBlob->nBitsModulus;
    params.nPrimes = 2;
    params.nPubExp = 1;

    state.pKey = ScShimSymCryptRsakeyAllocate( &params, 0 );
    CHECK( state.pKey != NULL, "?" );

    PCBYTE ppPrime[2] = {&pcKeyBlob->abPrime1[0], &pcKeyBlob->abPrime2[0] };
    SIZE_T cbPrime[2] = {pcKeyBlob->cbPrime1, pcKeyBlob->cbPrime2 };

    scError = ScShimSymCryptRsakeySetValue(
        &pcKeyBlob->abModulus[0], pcKeyBlob->cbModulus,
        &pcKeyBlob->u64PubExp, 1,
        ppPrime, cbPrime, 2,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        SYMCRYPT_FLAG_RSAKEY_ENCRYPT,
        state.pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncRaw>::encrypt(
    _In_reads_( cbMsg )             PCBYTE  pbMsg,
                                    SIZE_T  cbMsg,
                                    PCSTR   pcstrHashAlgName,
                                    PCBYTE  pbLabel,
                                    SIZE_T  cbLabel,
    _Out_writes_( cbCiphertext )    PBYTE   pbCiphertext,
                                    SIZE_T  cbCiphertext )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );
    CHECK( cbMsg == cbKey, "Wrong message size" );

    scError = ScShimSymCryptRsaRawEncrypt(
                                state.pKey,
                                pbMsg, cbMsg,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0,
                                pbCiphertext, cbCiphertext );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncRaw>::decrypt(
        _In_reads_( cbCiphertext )      PCBYTE  pbCiphertext,
                                        SIZE_T  cbCiphertext,
                                        PCSTR   pcstrHashAlgName,
                                        PCBYTE  pbLabel,
                                        SIZE_T  cbLabel,
        _Out_writes_to_(cbMsg,*pcbMsg)  PBYTE   pbMsg,
                                        SIZE_T  cbMsg,
                                        SIZE_T *pcbMsg )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );
    CHECK( cbMsg >= cbKey, "Wrong message size" );

    scError = ScShimSymCryptRsaRawDecrypt(
                                state.pKey,
                                pbCiphertext, cbCiphertext,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0,
                                pbMsg, cbKey );

    *pcbMsg = cbKey;

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


// RSA PKCS1 encryption

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaEncPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    SIZE_T cbDst = 0;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_ENCRYPT );

    scError = ScShimSymCryptRsaPkcs1Encrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    keySize - PERF_RSA_PKCS1_LESS_BYTES,        // This is the maximum size for PKCS1
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize, "?" );

    scError = ScShimSymCryptRsaPkcs1Decrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf2 + keySize,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize - PERF_RSA_PKCS1_LESS_BYTES, "?" );
    CHECK( memcmp(buf2, buf2 + keySize, cbDst) == 0, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaEncPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaEncPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaPkcs1Encrypt(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            dataSize - PERF_RSA_PKCS1_LESS_BYTES,
            0,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            buf3,
            dataSize,
            &cbDst );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgRsaEncPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbDst;

    scError = ScShimSymCryptRsaPkcs1Decrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    dataSize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf2 + dataSize,
                    dataSize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == dataSize - PERF_RSA_PKCS1_LESS_BYTES, "?" );
}


template<>
RsaEncImp<ImpXxx, AlgRsaEncPkcs1>::RsaEncImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaEncPkcs1>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgRsaEncPkcs1>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncPkcs1>;

    state.pKey = NULL;
}

template<>
RsaEncImp<ImpXxx, AlgRsaEncPkcs1>::~RsaEncImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncPkcs1>::setKey( PCRSAKEY_TESTBLOB pcKeyBlob )
{
    SYMCRYPT_ERROR scError;

    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }

    if( pcKeyBlob == NULL )
    {
        // Just used to clear the key state to do leak detection
        return STATUS_SUCCESS;
    }

    SYMCRYPT_RSA_PARAMS params;
    params.version = 1;
    params.nBitsOfModulus = pcKeyBlob->nBitsModulus;
    params.nPrimes = 2;
    params.nPubExp = 1;

    state.pKey = ScShimSymCryptRsakeyAllocate( &params, 0 );
    CHECK( state.pKey != NULL, "?" );

    PCBYTE ppPrime[2] = {&pcKeyBlob->abPrime1[0], &pcKeyBlob->abPrime2[0] };
    SIZE_T cbPrime[2] = {pcKeyBlob->cbPrime1, pcKeyBlob->cbPrime2 };

    scError = ScShimSymCryptRsakeySetValue(
        &pcKeyBlob->abModulus[0], pcKeyBlob->cbModulus,
        &pcKeyBlob->u64PubExp, 1,
        ppPrime, cbPrime, 2,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        SYMCRYPT_FLAG_RSAKEY_ENCRYPT,
        state.pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncPkcs1>::encrypt(
    _In_reads_( cbMsg )             PCBYTE  pbMsg,
                                    SIZE_T  cbMsg,
                                    PCSTR   pcstrHashAlgName,
                                    PCBYTE  pbLabel,
                                    SIZE_T  cbLabel,
    _Out_writes_( cbCiphertext )    PBYTE   pbCiphertext,
                                    SIZE_T  cbCiphertext )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbResult;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );

    scError = ScShimSymCryptRsaPkcs1Encrypt(
                                state.pKey,
                                pbMsg, cbMsg,
                                0,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                pbCiphertext, cbCiphertext,
                                &cbResult );

    CHECK( cbResult == cbKey, "Unexpected ciphertext size" );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncPkcs1>::decrypt(
        _In_reads_( cbCiphertext )      PCBYTE  pbCiphertext,
                                        SIZE_T  cbCiphertext,
                                        PCSTR   pcstrHashAlgName,
                                        PCBYTE  pbLabel,
                                        SIZE_T  cbLabel,
        _Out_writes_to_(cbMsg,*pcbMsg)  PBYTE   pbMsg,
                                        SIZE_T  cbMsg,
                                        SIZE_T *pcbMsg )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbResult;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );

    scError = ScShimSymCryptRsaPkcs1Decrypt(
                                state.pKey,
                                pbCiphertext, cbCiphertext,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0,
                                pbMsg, cbMsg,
                                &cbResult );

    *pcbMsg = cbResult;

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

// RSA OAEP encryption

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    SIZE_T cbDst = 0;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_ENCRYPT );

    scError = ScShimSymCryptRsaOaepEncrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    keySize - PERF_RSA_OAEP_LESS_BYTES, // This is the maximum size for OAEP
                    PERF_RSA_HASH_ALG_SC,
                    buf2 + keySize,                     // Use buf2 bytes as the label
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize, "?" );

    scError = ScShimSymCryptRsaOaepDecrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_SC,
                    buf2 + keySize,
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    buf3 + keySize,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize - PERF_RSA_OAEP_LESS_BYTES, "?" );
    CHECK( memcmp(buf2, buf3 + keySize, cbDst) == 0, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptRsaOaepEncrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    dataSize - PERF_RSA_OAEP_LESS_BYTES, // This is the maximum size for OAEP
                    PERF_RSA_HASH_ALG_SC,
                    buf2 + dataSize,                     // Use buf2 bytes as the label
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    dataSize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == dataSize, "?" );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbDst;

    scError = ScShimSymCryptRsaOaepDecrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    dataSize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_SC,
                    buf2 + dataSize,    // label
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    buf3 + dataSize,
                    dataSize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == dataSize - PERF_RSA_OAEP_LESS_BYTES, "?" );
}


template<>
RsaEncImp<ImpXxx, AlgRsaEncOaep>::RsaEncImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaEncOaep>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgRsaEncOaep>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncOaep>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncOaep>;

    state.pKey = NULL;
}

template<>
RsaEncImp<ImpXxx, AlgRsaEncOaep>::~RsaEncImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncOaep>::setKey( PCRSAKEY_TESTBLOB pcKeyBlob )
{
    SYMCRYPT_ERROR scError;

    if( state.pKey != NULL )
    {
        ScShimSymCryptRsakeyFree( state.pKey );
        state.pKey = NULL;
    }

    if( pcKeyBlob == NULL )
    {
        // Just used to clear the key state to do leak detection
        return STATUS_SUCCESS;
    }

    SYMCRYPT_RSA_PARAMS params;
    params.version = 1;
    params.nBitsOfModulus = pcKeyBlob->nBitsModulus;
    params.nPrimes = 2;
    params.nPubExp = 1;

    state.pKey = ScShimSymCryptRsakeyAllocate( &params, 0 );
    CHECK( state.pKey != NULL, "?" );

    PCBYTE ppPrime[2] = {&pcKeyBlob->abPrime1[0], &pcKeyBlob->abPrime2[0] };
    SIZE_T cbPrime[2] = {pcKeyBlob->cbPrime1, pcKeyBlob->cbPrime2 };

    scError = ScShimSymCryptRsakeySetValue(
        &pcKeyBlob->abModulus[0], pcKeyBlob->cbModulus,
        &pcKeyBlob->u64PubExp, 1,
        ppPrime, cbPrime, 2,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        SYMCRYPT_FLAG_RSAKEY_ENCRYPT,
        state.pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncOaep>::encrypt(
    _In_reads_( cbMsg )             PCBYTE  pbMsg,
                                    SIZE_T  cbMsg,
                                    PCSTR   pcstrHashAlgName,
                                    PCBYTE  pbLabel,
                                    SIZE_T  cbLabel,
    _Out_writes_( cbCiphertext )    PBYTE   pbCiphertext,
                                    SIZE_T  cbCiphertext )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbResult;
    PCHASH_INFO pInfo;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName );
    scError = ScShimSymCryptRsaOaepEncrypt(
                                state.pKey,
                                pbMsg, cbMsg,
                                pInfo->pcHash,
                                pbLabel, cbLabel,
                                0,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                pbCiphertext, cbCiphertext,
                                &cbResult );

    CHECK( cbResult == cbKey, "Unexpected ciphertext size" );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

template<>
NTSTATUS
RsaEncImp<ImpXxx, AlgRsaEncOaep>::decrypt(
        _In_reads_( cbCiphertext )      PCBYTE  pbCiphertext,
                                        SIZE_T  cbCiphertext,
                                        PCSTR   pcstrHashAlgName,
                                        PCBYTE  pbLabel,
                                        SIZE_T  cbLabel,
        _Out_writes_to_(cbMsg,*pcbMsg)  PBYTE   pbMsg,
                                        SIZE_T  cbMsg,
                                        SIZE_T *pcbMsg )
{
    SYMCRYPT_ERROR scError;
    SIZE_T cbResult;
    PCHASH_INFO pInfo;

    UNREFERENCED_PARAMETER( pcstrHashAlgName );
    UNREFERENCED_PARAMETER( pbLabel );
    UNREFERENCED_PARAMETER( cbLabel );

    SIZE_T cbKey = ScShimSymCryptRsakeySizeofModulus( state.pKey );
    CHECK( cbCiphertext == cbKey, "Wrong ciphertext size" );

    pInfo = getHashInfo<ImpXxx>( pcstrHashAlgName );
    scError = ScShimSymCryptRsaOaepDecrypt(
                                state.pKey,
                                pbCiphertext, cbCiphertext,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                pInfo->pcHash,
                                pbLabel, cbLabel,
                                0,
                                pbMsg, cbMsg,
                                &cbResult );

    *pcbMsg = cbResult;

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


// Rsa Pkcs1 Encryption
/*
template<>
RsaImp<ImpXxx, AlgRsaEncPkcs1>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaEncPkcs1>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncPkcs1>;
}

template<>
RsaImp<ImpXxx, AlgRsaEncPkcs1>::~RsaImp()
{
}

// Rsa Pkcs1 Decryption

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaDecPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaPkcs1Decrypt(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf3,
            dataSize,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            0,
            buf2,
            dataSize,
            &cbDst );
}

template<>
RsaImp<ImpXxx, AlgRsaDecPkcs1>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaDecPkcs1>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncPkcs1>;
}

template<>
RsaImp<ImpXxx, AlgRsaDecPkcs1>::~RsaImp()
{
}
*/

// Rsa Oaep Encryption
/*
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    BYTE rbResult[1024] = { 0 };
    SIZE_T cbDst = 0;

    sc_RsaKeyPerf<ImpXxx>( buf1, buf2, keySize, SYMCRYPT_FLAG_RSAKEY_ENCRYPT );

    scError = ScShimSymCryptRsaOaepEncrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf2,
                    keySize - PERF_RSA_OAEP_LESS_BYTES, // This is the maximum size for OAEP
                    PERF_RSA_HASH_ALG_SC,
                    buf2,                               // Use buf2 bytes as the label
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    buf3,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize, "?" );

    CHECK( sizeof(rbResult) >= keySize, "?" );

    scError = ScShimSymCryptRsaOaepDecrypt(
                    *((PSYMCRYPT_RSAKEY *) buf1),
                    buf3,
                    keySize,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    PERF_RSA_HASH_ALG_SC,
                    buf2,                            // Use buf2 bytes as label
                    PERF_RSA_LABEL_LENGTH,
                    0,
                    rbResult,
                    keySize,
                    &cbDst );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    CHECK( cbDst == keySize - PERF_RSA_OAEP_LESS_BYTES, "?" );
    CHECK( memcmp(buf2, rbResult, cbDst) == 0, "?" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaEncOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaOaepEncrypt(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            dataSize - PERF_RSA_OAEP_LESS_BYTES,    // This is the maximum size for OAEP
            PERF_RSA_HASH_ALG_SC,
            buf2,                                   // Use buf2 bytes as label
            PERF_RSA_LABEL_LENGTH,
            0,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            buf3,
            dataSize,
            &cbDst );
}
*/

/*
template<>
RsaImp<ImpXxx, AlgRsaEncOaep>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaEncOaep>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncOaep>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncOaep>;
}

template<>
RsaImp<ImpXxx, AlgRsaEncOaep>::~RsaImp()
{
}

// Rsa Oaep Decryption

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaDecOaep>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SIZE_T cbDst = 0;

    ScShimSymCryptRsaOaepDecrypt(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf3,
            dataSize,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            PERF_RSA_HASH_ALG_SC,
            buf2,                            // Use buf2 bytes as label
            PERF_RSA_LABEL_LENGTH,
            0,
            buf2,
            dataSize,
            &cbDst );
}

template<>
RsaImp<ImpXxx, AlgRsaDecOaep>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaDecOaep>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaEncOaep>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaEncOaep>;
}

template<>
RsaImp<ImpXxx, AlgRsaDecOaep>::~RsaImp()
{
}

template<>
RsaImp<ImpXxx, AlgRsaSignPkcs1>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaSignPkcs1>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPkcs1>;
}

template<>
RsaImp<ImpXxx, AlgRsaSignPkcs1>::~RsaImp()
{
}

// Rsa Pkcs1 Verify

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaVerifyPkcs1>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptRsaPkcs1Verify(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            PERF_RSA_HASH_ALG_SIZE,
            buf3,
            dataSize,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            (PSYMCRYPT_OID) (buf2+PERF_RSA_HASH_ALG_SIZE),
            1,
            0 );
}

template<>
RsaImp<ImpXxx, AlgRsaVerifyPkcs1>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaVerifyPkcs1>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPkcs1>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPkcs1>;
}

template<>
RsaImp<ImpXxx, AlgRsaVerifyPkcs1>::~RsaImp()
{
}

template<>
RsaImp<ImpXxx, AlgRsaSignPss>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaSignPss>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPss>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPss>;
}

template<>
RsaImp<ImpXxx, AlgRsaSignPss>::~RsaImp()
{
}

// Rsa Pss Verify

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgRsaVerifyPss>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCryptRsaPssVerify(
            *((PSYMCRYPT_RSAKEY *) buf1),
            buf2,
            PERF_RSA_HASH_ALG_SIZE,
            buf3,
            dataSize,
            SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
            PERF_RSA_HASH_ALG_SC,
            PERF_RSA_SALT_LENGTH,
            0 );
}

template<>
RsaImp<ImpXxx, AlgRsaVerifyPss>::RsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgRsaVerifyPss>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgRsaSignPss>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgRsaSignPss>;
}

template<>
RsaImp<ImpXxx, AlgRsaVerifyPss>::~RsaImp()
{
}
*/

//============================

template<>
VOID
DlgroupSetup<ImpXxx>( PBYTE buf1, SIZE_T keySize, BOOLEAN forDiffieHellman )
{
    SYMCRYPT_ERROR scError;
    PDLGROUP_INFO pInfo = (PDLGROUP_INFO)buf1;

    PCDLGROUP_TESTBLOB pBlob = dlgroupForSize( keySize * 8, forDiffieHellman );

    PCSYMCRYPT_HASH pHashAlgorithm = NULL;
    if( pBlob->pcstrHashAlgName != NULL )
    {
        pHashAlgorithm = getHashInfo<ImpXxx>(pBlob->pcstrHashAlgName)->pcHash;
    }

    CHECK( pBlob != NULL, "?" );

    PSYMCRYPT_DLGROUP pGroup = ScShimSymCryptDlgroupCreate( buf1 + 64, PERF_BUFFER_SIZE/2, pBlob->nBitsP, 8*pBlob->cbPrimeQ );

    CHECK( pGroup != NULL, "Could not create group" );

    scError = ScShimSymCryptDlgroupSetValue(
        &pBlob->abPrimeP[0], pBlob->cbPrimeP,
        pBlob->cbPrimeQ == 0 ? NULL : &pBlob->abPrimeQ[0], pBlob->cbPrimeQ,
        &pBlob->abGenG[0], pBlob->cbPrimeP,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        pHashAlgorithm,
        &pBlob->abSeed[0], pBlob->cbSeed,
        pBlob->genCounter,
        pBlob->fipsStandard,
        pGroup );

    CHECK( scError == SYMCRYPT_NO_ERROR, "Error setting group values" );

    pInfo->pBlob = pBlob;
    pInfo->pGroup = pGroup;
}

// Table with the DL groups sizes and pointers to the groups
struct {
    SIZE_T              keySize;        // Always equal to cbPrimeP
    PSYMCRYPT_DLGROUP   pDlgroup;
} CONCAT2(g_precomputedDlGroups, ImpXxx)[] = {
    {  64, NULL },
    { 128, NULL },
    { 256, NULL },
};

template<>
void
SetupDlGroup<ImpXxx>( PBYTE buf1, SIZE_T keySize )
{
    SIZE_T i = 0;
    BOOLEAN bFound = FALSE;

    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;
    PSYMCRYPT_DLGROUP pDlgroup = NULL;

    for( i=0; i < ARRAY_SIZE(CONCAT2(g_precomputedDlGroups, ImpXxx)); i++ )
    {
        if ( keySize == CONCAT2(g_precomputedDlGroups, ImpXxx)[i].keySize )
        {
            bFound = TRUE;

            if ( CONCAT2(g_precomputedDlGroups, ImpXxx)[i].pDlgroup == NULL )
            {
                pDlgroup = ScShimSymCryptDlgroupAllocate( 8*((UINT32)CONCAT2(g_precomputedDlGroups, ImpXxx)[i].keySize), 0 );
                CHECK( pDlgroup != NULL, "?" );

                scError = ScShimSymCryptDlgroupGenerate(
                    ScShimSymCryptSha256Algorithm, SYMCRYPT_DLGROUP_FIPS_LATEST, pDlgroup );
                    // This algorithm is safe for all our sizes
                CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

                CONCAT2(g_precomputedDlGroups, ImpXxx)[i].pDlgroup = pDlgroup;
            }

            break;
        }
    }

    CHECK( bFound, "?" );

    *((PSYMCRYPT_DLGROUP *) buf1) = CONCAT2(g_precomputedDlGroups, ImpXxx)[i].pDlgroup;
}

template<>
void
SetupSymCryptDsa<ImpXxx>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    PCSYMCRYPT_DLGROUP pDlgroup = *((PCSYMCRYPT_DLGROUP *)buf1);

    PSYMCRYPT_DLKEY * pPtrs = ((PSYMCRYPT_DLKEY *) buf2);

    SIZE_T buff2Offset = ((2*sizeof(PSYMCRYPT_DLKEY) + SYMCRYPT_ASYM_ALIGN_VALUE - 1)/SYMCRYPT_ASYM_ALIGN_VALUE )*SYMCRYPT_ASYM_ALIGN_VALUE;
    UINT32 dlkeysize = ScShimSymCryptSizeofDlkeyFromDlgroup( pDlgroup );

    SIZE_T buff3Offset = sizeof(UINT32);
    UINT32 signatureSize = 0;
    PUINT32 puiSignatureSize = NULL;
    UINT32 cbAgreedSecret, cbHashValue;

    UINT32 generateFlags = SYMCRYPT_FLAG_DLKEY_DSA;

    pPtrs[0] = ScShimSymCryptDlkeyCreate( buf2 + buff2Offset, dlkeysize, pDlgroup );
    scError = ScShimSymCryptDlkeyGenerate( generateFlags, pPtrs[0] );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    pPtrs[1] = ScShimSymCryptDlkeyCreate( buf2 + buff2Offset + dlkeysize, dlkeysize, pDlgroup );
    scError = ScShimSymCryptDlkeyGenerate( generateFlags, pPtrs[1] );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    signatureSize = 2*ScShimSymCryptDlkeySizeofPrivateKey( pPtrs[0] );
    puiSignatureSize = (PUINT32) buf3;

    cbAgreedSecret = ScShimSymCryptDlkeySizeofPublicKey( pPtrs[0] );
    CHECK( buff3Offset + SYMCRYPT_MAX( signatureSize, cbAgreedSecret ) <= SCRATCH_BUF_SIZE,
           "Destination buffer cannot fit the DSA signature or the DH secret" );

    *puiSignatureSize = signatureSize;

    // Verify that DSA can work
    cbHashValue = ScShimSymCryptDlkeySizeofPrivateKey( ((PSYMCRYPT_DLKEY *)buf2)[0] );
    scError = ScShimSymCryptDsaSign(
                ((PSYMCRYPT_DLKEY *) buf2)[0],
                buf2,           // Sign the keys' buffer
                cbHashValue,
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0,
                buf3 + sizeof(UINT32),
                *((PUINT32) buf3) ) ;
    CHECK( scError == SYMCRYPT_NO_ERROR, "SymCryptDsaSign failed" );

    // Verify the signature to make sure everything is ok
    scError = ScShimSymCryptDsaVerify(
                ((PSYMCRYPT_DLKEY *) buf2)[0],
                buf2,           // Verify the keys' buffer
                cbHashValue,
                buf3 + sizeof(UINT32),
                *((PUINT32) buf3),
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "SymCryptDsaVerify failed" );
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgDsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SetupDlGroup<ImpXxx>( buf1, keySize );
    SetupSymCryptDsa<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgDsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgDsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( dataSize );

    UINT32 cbHashValue = ScShimSymCryptDlkeySizeofPrivateKey( ((PSYMCRYPT_DLKEY *)buf2)[0] );

    ScShimSymCryptDsaSign(
                ((PSYMCRYPT_DLKEY *) buf2)[0],
                buf2,           // Sign the keys' buffer
                cbHashValue,
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0,
                buf3 + sizeof(UINT32),
                *((PUINT32) buf3) );
}

template<>
DlImp<ImpXxx, AlgDsaSign>::DlImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDsaSign>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDsaSign>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDsaSign>;
}

template<>
DlImp<ImpXxx, AlgDsaSign>::~DlImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgDsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    SetupDlGroup<ImpXxx>( buf1, keySize );
    SetupSymCryptDsa<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgDsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgDsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( dataSize );

    UINT32 cbHashValue = ScShimSymCryptDlkeySizeofPrivateKey( ((PSYMCRYPT_DLKEY *)buf2)[0] );

    ScShimSymCryptDsaVerify(
                ((PSYMCRYPT_DLKEY *) buf2)[0],
                buf2,           // Sign the keys' buffer
                cbHashValue,
                buf3 + sizeof(UINT32),
                *((PUINT32) buf3),
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0 );
}

template<>
DlImp<ImpXxx, AlgDsaVerify>::DlImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDsaVerify>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDsaVerify>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDsaVerify>;
}

template<>
DlImp<ImpXxx, AlgDsaVerify>::~DlImp()
{
}

//============================

template<>
PSYMCRYPT_DLGROUP
dlgroupObjectFromTestBlob<ImpXxx>( PCDLGROUP_TESTBLOB pBlob )
{
    SYMCRYPT_ERROR scError;

    PSYMCRYPT_DLGROUP pGroup = NULL;

    PCSYMCRYPT_HASH pHashAlgorithm = NULL;
    if( pBlob->pcstrHashAlgName != NULL )
    {
        pHashAlgorithm = getHashInfo<ImpXxx>(pBlob->pcstrHashAlgName)->pcHash;
    }

    pGroup = ScShimSymCryptDlgroupAllocate( pBlob->nBitsP, 8*pBlob->cbPrimeQ );
    CHECK( pGroup != NULL, "Could not create group" );

    scError = ScShimSymCryptDlgroupSetValue(
        &pBlob->abPrimeP[0], pBlob->cbPrimeP,
        pBlob->cbPrimeQ == 0 ? NULL : &pBlob->abPrimeQ[0], pBlob->cbPrimeQ,
        &pBlob->abGenG[0], pBlob->cbPrimeP,
        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
        pHashAlgorithm,
        pBlob->cbSeed == 0 ? NULL : &pBlob->abSeed[0], pBlob->cbSeed,
        pBlob->genCounter,
        pBlob->fipsStandard,
        pGroup );

    CHECK( scError == SYMCRYPT_NO_ERROR, "Error setting group values" );

    return pGroup;
}

template<>
PSYMCRYPT_DLKEY
dlkeyObjectFromTestBlob<ImpXxx>( PCSYMCRYPT_DLGROUP pGroup, PCDLKEY_TESTBLOB pBlob, UINT32 algFlags, BOOL setPrivate /*= TRUE*/ )
{
    PSYMCRYPT_DLKEY pRes;
    SYMCRYPT_ERROR scError;
    UINT32 flags = algFlags;
    PCBYTE pbPrivKey = NULL;
    SIZE_T cbPrivKey = 0;
    PCBYTE pbPubKey = NULL;
    SIZE_T cbPubKey = 0;

    pRes = ScShimSymCryptDlkeyAllocate( pGroup );
    CHECK( pRes != NULL, "?" );

    // We want to exercise the various code paths semi-randomly in tests - we will be hitting this function 100s of times
    // in unit tests, and there are only 16 combinations of code paths we want to exercise, so we should get decent coverage

    BYTE randByte = g_rng.byte();

    if (!pBlob->pGroup->fHasPrimeQ ||
        pBlob->fPrivateModP ||
        ((algFlags == SYMCRYPT_FLAG_DLKEY_DH) && (!pBlob->pGroup->isSafePrimeGroup)) ||
        ((algFlags == SYMCRYPT_FLAG_DLKEY_DSA) && (pBlob->pGroup->isSafePrimeGroup)) ||
        (randByte & 0x1))
    {
        flags |= SYMCRYPT_FLAG_KEY_NO_FIPS;
        if (randByte & 0x2)
        {
            flags |= SYMCRYPT_FLAG_DLKEY_DSA;
            flags |= SYMCRYPT_FLAG_DLKEY_DH;
        }
    }

    if (setPrivate || (randByte & 0x4))
    {
        pbPrivKey = &pBlob->abPrivKey[0];
        cbPrivKey = pBlob->cbPrivKey;

        if (pBlob->nBitsPriv != 0)
        {
            scError = ScShimSymCryptDlkeySetPrivateKeyLength( pRes, pBlob->nBitsPriv, 0 );
            CHECK4( scError == SYMCRYPT_NO_ERROR, "Error setting private key length pBlob->nBitsPriv %d pBlob->pGroup->cbPrimeP %d",
                    pBlob->nBitsPriv, pBlob->pGroup->cbPrimeP );
        }
    }

    if (((flags & SYMCRYPT_FLAG_KEY_NO_FIPS) != 0) && (randByte & 0x8))
    {
        flags |= SYMCRYPT_FLAG_KEY_MINIMAL_VALIDATION;
    }

    if (!setPrivate)
    {
        pbPubKey = &pBlob->abPubKey[0];
        cbPubKey = pBlob->pGroup->cbPrimeP;
    }

    scError = ScShimSymCryptDlkeySetValue(
                                pbPrivKey, cbPrivKey,
                                pbPubKey, cbPubKey,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                flags, // Do as much verification that the key is correct as possible
                                pRes );

    CHECK( scError == SYMCRYPT_NO_ERROR, "Error importing key" );

    return pRes;
}

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgDh>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( buf3 );

    DlgroupSetup<ImpXxx>( buf1, keySize, TRUE );

    // Set up two keys in buf2
    PDLGROUP_INFO pInfo = (PDLGROUP_INFO) buf1;
    PSYMCRYPT_DLGROUP pGroup = pInfo->pGroup;

    PSYMCRYPT_DLKEY pKey1 = ScShimSymCryptDlkeyCreate( buf2 + 64, PERF_BUFFER_SIZE/4, pGroup );
    PSYMCRYPT_DLKEY pKey2 = ScShimSymCryptDlkeyCreate( buf2 + 64 + PERF_BUFFER_SIZE/4, PERF_BUFFER_SIZE/4, pGroup );

    UINT32 generateFlags = SYMCRYPT_FLAG_DLKEY_DH | (pInfo->pBlob->isSafePrimeGroup ? 0 : SYMCRYPT_FLAG_KEY_NO_FIPS);

    CHECK( pKey1 != NULL && pKey2 != NULL, "Failed to create keys" );

    scError = ScShimSymCryptDlkeyGenerate( generateFlags, pKey1 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    scError = ScShimSymCryptDlkeyGenerate( generateFlags, pKey2 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    ((PSYMCRYPT_DLKEY *) buf2)[0] = pKey1;
    ((PSYMCRYPT_DLKEY *) buf2)[1] = pKey2;
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgDh>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}


template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgDh>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( dataSize );

    PDLGROUP_INFO pInfo = (PDLGROUP_INFO) buf1;
    PSYMCRYPT_DLGROUP pGroup = pInfo->pGroup;

    UINT32 generateFlags = SYMCRYPT_FLAG_DLKEY_DH | (pInfo->pBlob->isSafePrimeGroup ? 0 : SYMCRYPT_FLAG_KEY_NO_FIPS);

    PSYMCRYPT_DLKEY pKey = ScShimSymCryptDlkeyCreate( buf3, (1 << 16), pGroup );
    CHECK( pKey != NULL, "?" );

    scError = ScShimSymCryptDlkeyGenerate( generateFlags, pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    scError = ScShimSymCryptDlkeyGetValue( pKey, nullptr, 0, buf3 + (1 << 16), pInfo->pBlob->cbPrimeP, SYMCRYPT_NUMBER_FORMAT_MSB_FIRST, 0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgDh>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );

    ScShimSymCryptDhSecretAgreement(
                ((PSYMCRYPT_DLKEY *) buf2)[0],
                ((PSYMCRYPT_DLKEY *) buf2)[1],
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0,
                buf3,
                dataSize );     // This will be the same as the key size
}

template<>
DhImp<ImpXxx, AlgDh>::DhImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDh>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction< ImpXxx, AlgDh>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDh>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDh>;

    state.pGroup = NULL;
    state.pKey = NULL;
}

template<>
DhImp<ImpXxx, AlgDh>::~DhImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptDlkeyFree( state.pKey );
        state.pKey = NULL;
    }
    if( state.pGroup != NULL )
    {
        ScShimSymCryptDlgroupFree( state.pGroup );
        state.pGroup = NULL;
    }
}

template<>
NTSTATUS
DhImp<ImpXxx, AlgDh>::setKey( _In_    PCDLKEY_TESTBLOB    pcKeyBlob )
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptDlkeyFree( state.pKey );
        state.pKey = NULL;
    }
    if( state.pGroup != NULL )
    {
        ScShimSymCryptDlgroupFree( state.pGroup );
        state.pGroup = NULL;
    }

    if( pcKeyBlob != NULL )
    {
        state.pGroup = dlgroupObjectFromTestBlob<ImpXxx>( pcKeyBlob->pGroup );
        state.pKey = dlkeyObjectFromTestBlob<ImpXxx>( state.pGroup, pcKeyBlob, SYMCRYPT_FLAG_DLKEY_DH );

        CHECK( state.pGroup != NULL && state.pKey != NULL, "?" );
    }

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
DhImp<ImpXxx, AlgDh>::sharedSecret(
        _In_                        PCDLKEY_TESTBLOB    pcPubkey,
        _Out_writes_( cbSecret )    PBYTE               pbSecret,
                                    SIZE_T              cbSecret )
{
    PSYMCRYPT_DLKEY pKey2;
    SYMCRYPT_ERROR scError;

    pKey2 = dlkeyObjectFromTestBlob<ImpXxx>( state.pGroup, pcPubkey, SYMCRYPT_FLAG_DLKEY_DH, /*setPrivate=*/ FALSE );
    CHECK( pKey2 != NULL, "?")

        scError = ScShimSymCryptDhSecretAgreement(
                                    state.pKey,
                                    pKey2,
                                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                    0,
                                    pbSecret, cbSecret );

    ScShimSymCryptDlkeyFree( pKey2 );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}


template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgDsa>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( buf3 );

    DlgroupSetup<ImpXxx>( buf1, keySize, FALSE );  // Set buf1 to contain a DL group of size keySize

    // Set up a key in buf2
    PSYMCRYPT_DLGROUP pGroup = ((PDLGROUP_INFO) buf1)->pGroup;

    PSYMCRYPT_DLKEY pKey = ScShimSymCryptDlkeyCreate( buf2 + 64, PERF_BUFFER_SIZE/4, pGroup );

    CHECK( pKey != NULL, "Failed to create key" );

    scError = ScShimSymCryptDlkeyGenerate( SYMCRYPT_FLAG_DLKEY_DSA, pKey );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    ((PSYMCRYPT_DLKEY *) buf2)[0] = pKey;
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgDsa>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}


template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgDsa>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( dataSize );

    PSYMCRYPT_DLKEY pKey = *(PSYMCRYPT_DLKEY *) buf2;
    PDLGROUP_INFO pInfo = (PDLGROUP_INFO) buf1;

    scError = ScShimSymCryptDsaSign(
                                pKey,
                                buf3, 32,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0,
                                buf3 + 64, 2 * pInfo->pBlob->cbPrimeQ );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgDsa>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    SYMCRYPT_ERROR scError;

    UNREFERENCED_PARAMETER( dataSize );

    PSYMCRYPT_DLKEY pKey = *(PSYMCRYPT_DLKEY *) buf2;
    PDLGROUP_INFO pInfo = (PDLGROUP_INFO) buf1;

    scError = ScShimSymCryptDsaVerify(
                                pKey,
                                buf3, 32,
                                buf3 + 64, 2 * pInfo->pBlob->cbPrimeQ,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0 );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
}

template<>
DsaImp<ImpXxx, AlgDsa>::DsaImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDsa>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction< ImpXxx, AlgDsa>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDsa>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDsa>;

    state.pGroup = NULL;
    state.pKey = NULL;
}

template<>
DsaImp<ImpXxx, AlgDsa>::~DsaImp()
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptDlkeyFree( state.pKey );
        state.pKey = NULL;
    }
    if( state.pGroup != NULL )
    {
        ScShimSymCryptDlgroupFree( state.pGroup );
        state.pGroup = NULL;
    }
}

template<>
NTSTATUS
DsaImp<ImpXxx, AlgDsa>::setKey( _In_    PCDLKEY_TESTBLOB    pcKeyBlob )
{
    if( state.pKey != NULL )
    {
        ScShimSymCryptDlkeyFree( state.pKey );
        state.pKey = NULL;
    }
    if( state.pGroup != NULL )
    {
        ScShimSymCryptDlgroupFree( state.pGroup );
        state.pGroup = NULL;
    }

    if( pcKeyBlob != NULL )
    {
        state.pGroup = dlgroupObjectFromTestBlob<ImpXxx>( pcKeyBlob->pGroup );
        state.pKey = dlkeyObjectFromTestBlob<ImpXxx>( state.pGroup, pcKeyBlob, SYMCRYPT_FLAG_DLKEY_DSA );

        CHECK( state.pGroup != NULL && state.pKey != NULL, "?" );
    }

    return STATUS_SUCCESS;
}

template<>
NTSTATUS
DsaImp<ImpXxx, AlgDsa>::sign(
        _In_reads_( cbHash)     PCBYTE  pbHash,
                                SIZE_T  cbHash,             // Can be any size, but often = size of Q
        _Out_writes_( cbSig )   PBYTE   pbSig,
                                SIZE_T  cbSig )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptDsaSign(
                                state.pKey,
                                pbHash, cbHash,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0,
                                pbSig, cbSig );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

template<>
NTSTATUS
DsaImp<ImpXxx, AlgDsa>::verify(
    _In_reads_( cbHash)     PCBYTE  pbHash,
                            SIZE_T  cbHash,
    _In_reads_( cbSig )     PCBYTE  pbSig,
                            SIZE_T  cbSig )
{
    SYMCRYPT_ERROR scError;

    scError = ScShimSymCryptDsaVerify(
                                state.pKey,
                                pbHash, cbHash,
                                pbSig, cbSig,
                                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                                0 );

    return scError == SYMCRYPT_NO_ERROR ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}



template<>
DlImp<ImpXxx, AlgDh>::DlImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgDh>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgDh>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgDh>;
}

template<>
DlImp<ImpXxx, AlgDh>::~DlImp()
{
}

//============================
// Global table with the curve pointers (same size as the g_exKeyToCurve)
//
// These curves are allocated on demand as they are needed in tests and all deallocated by a single
// call to CleanupSymCryptCurves performed in the destructor for AlgEcpointSetZero (which is called
// once at the end of the unit tests). A more robust solution for freeing the curves with reference
// counts in each algorithm using the global curves and a critical sections to avoid double freeing
// at program end could be done, but just doing the simplest thing to avoid memory leaks in the unit
// tests for now.
PCSYMCRYPT_ECURVE   CONCAT2(g_pCurves, ImpXxx)[ARRAY_SIZE(g_exKeyToCurve)] = { 0 };

template<>
void
CleanupSymCryptCurves<ImpXxx>()
{
    SIZE_T i = 0;
    for( i=0; i < ARRAY_SIZE(g_exKeyToCurve); i++ )
    {
        if (CONCAT2(g_pCurves, ImpXxx)[i] != NULL)
        {
            ScShimSymCryptEcurveFree( (PSYMCRYPT_ECURVE) CONCAT2(g_pCurves, ImpXxx)[i] );
            CONCAT2(g_pCurves, ImpXxx)[i] = NULL;
        }
    }
}

template<>
void
SetupSymCryptCurves<ImpXxx>( PBYTE buf1, SIZE_T keySize )
{
    SIZE_T i = 0;
    BOOLEAN bKeyFound = FALSE;
    PCSYMCRYPT_ECURVE pCurve = NULL;

    for( i=0; i < ARRAY_SIZE(g_exKeyToCurve); i++ )
    {
        if ( keySize == g_exKeyToCurve[i].exKeyParam )
        {
            bKeyFound = TRUE;
            break;
        }
    }

    CHECK( bKeyFound, "?" );

    if (CONCAT2(g_pCurves, ImpXxx)[i] == NULL)
    {
        pCurve = ScShimSymCryptEcurveAllocate( g_exKeyToCurve[i].pParams, 0 );

        CONCAT2(g_pCurves, ImpXxx)[i] = pCurve;
    }
    else
    {
        pCurve = CONCAT2(g_pCurves, ImpXxx)[i];
    }

    CHECK( pCurve != NULL, "?");

    *((PCSYMCRYPT_ECURVE *) buf1) = pCurve;
}

template<>
void
SetupSymCryptEckey<ImpXxx>( PBYTE buf1, PBYTE buf2, PBYTE buf3, UINT32 setRandomFlags )
{
    SYMCRYPT_ERROR scError = SYMCRYPT_NO_ERROR;

    PCSYMCRYPT_ECURVE pCurve = *((PCSYMCRYPT_ECURVE *)buf1);

    UINT32 eckeySize = ScShimSymCryptSizeofEckeyFromCurve( pCurve );
    UINT32 signatureSize = 2 * ScShimSymCryptEcurveSizeofFieldElement( pCurve );

    PSYMCRYPT_ECKEY * pPtrs = ((PSYMCRYPT_ECKEY *) buf2);
    pPtrs[0] = ScShimSymCryptEckeyCreate( buf2 + 32, eckeySize, pCurve );

    scError = ScShimSymCryptEckeySetRandom( setRandomFlags, pPtrs[0] );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

    pPtrs[1] = (PSYMCRYPT_ECKEY) ((PBYTE)buf2 + 32 + eckeySize);    // This will hold the hash of the message

    CHECK( 32 + eckeySize + SYMCRYPT_SHA512_RESULT_SIZE <= SCRATCH_BUF_SIZE, "ECKEY and hash cannot fit into scratch buffer" );
    GENRANDOM( (PBYTE)pPtrs[1], SYMCRYPT_SHA512_RESULT_SIZE );

    PUINT32 puiSignatureSize = (PUINT32) buf3;

    CHECK( sizeof(UINT32) + signatureSize <= SCRATCH_BUF_SIZE, "Destination buffer cannot fit the signature" );

    *puiSignatureSize = signatureSize;

    // Verify that ECDH can work
    if ( setRandomFlags & SYMCRYPT_FLAG_ECKEY_ECDH )
    {
        UINT32 cbAgreedSecret = ScShimSymCryptEcurveSizeofFieldElement( *(PSYMCRYPT_ECURVE *) buf1 );
        CHECK( cbAgreedSecret <= *((PUINT32)buf3), "Buffer 3 too small for ECDH");
        scError = ScShimSymCryptEcDhSecretAgreement(
                    ((PSYMCRYPT_ECKEY *) buf2)[0],
                    ((PSYMCRYPT_ECKEY *) buf2)[0],      // Same private and public key
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf3 + sizeof(UINT32),
                    cbAgreedSecret);
        CHECK( scError == SYMCRYPT_NO_ERROR, "SymCryptEcDhSecretAgreement failed" );
    }

    // Verify that ECDSA can work
    if ( (setRandomFlags & SYMCRYPT_FLAG_ECKEY_ECDSA) != 0 )
    {
        scError = ScShimSymCryptEcDsaSign(
                        pPtrs[0],
                        (PBYTE) pPtrs[1],
                        SYMCRYPT_SHA512_RESULT_SIZE,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        0,
                        buf3 + sizeof(UINT32),
                        signatureSize );
        CHECK( scError == SYMCRYPT_NO_ERROR, "SymCryptEcDsaSign failed" );

        // Verify the signature to make sure everything is ok
        scError = ScShimSymCryptEcDsaVerify(
                    ((PSYMCRYPT_ECKEY *) buf2)[0],
                    ((PBYTE *) buf2)[1],
                    SYMCRYPT_SHA512_RESULT_SIZE,
                    buf3 + sizeof(UINT32),
                    *((PUINT32)buf3),
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0 );
        CHECK( scError == SYMCRYPT_NO_ERROR, "SymCryptEcDsaVerify failed" );
    }
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcurveAllocate>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SIZE_T i = 0;
    BOOLEAN bKeyFound = FALSE;

    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    for( i=0; i < ARRAY_SIZE(g_exKeyToCurve); i++ )
    {
        if ( keySize == g_exKeyToCurve[i].exKeyParam )
        {
            bKeyFound = TRUE;
            break;
        }
    }

    CHECK( bKeyFound, "?" );

    *((PCSYMCRYPT_ECURVE_PARAMS *) buf1) = g_exKeyToCurve[i].pParams;
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcurveAllocate>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcurveAllocate>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    *((PSYMCRYPT_ECURVE *) buf3) = ScShimSymCryptEcurveAllocate( *((PCSYMCRYPT_ECURVE_PARAMS *) buf1), 0 );
    ScShimSymCryptEcurveFree( *((PSYMCRYPT_ECURVE *) buf3) );
}


template<>
EccImp<ImpXxx, AlgEcurveAllocate>::EccImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcurveAllocate>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcurveAllocate>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcurveAllocate>;
}

template<>
EccImp<ImpXxx, AlgEcurveAllocate>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEckeySetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf3 );

    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    PCSYMCRYPT_ECURVE pCurve = *((PCSYMCRYPT_ECURVE *)buf1);

    UINT32 eckeySize = ScShimSymCryptSizeofEckeyFromCurve( pCurve );

    PSYMCRYPT_ECKEY * pPtrs = ((PSYMCRYPT_ECKEY *) buf2);
    pPtrs[0] = ScShimSymCryptEckeyCreate( buf2 + 32, eckeySize, pCurve );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEckeySetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEckeySetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    PSYMCRYPT_ECKEY * pPtrs = ((PSYMCRYPT_ECKEY *) buf2);
    ScShimSymCryptEckeySetRandom( SYMCRYPT_FLAG_ECKEY_ECDH, pPtrs[0] );
}


template<>
EccImp<ImpXxx, AlgEckeySetRandom>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEckeySetRandom))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEckeySetRandom>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEckeySetRandom>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEckeySetRandom>;
}

template<>
EccImp<ImpXxx, AlgEckeySetRandom>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcdsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEckey<ImpXxx>( buf1, buf2, buf3, SYMCRYPT_FLAG_ECKEY_ECDSA );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcdsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgEcdsaSign>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcDsaSign(
                    ((PSYMCRYPT_ECKEY *) buf2)[0],
                    ((PBYTE *) buf2)[1],
                    SYMCRYPT_SHA512_RESULT_SIZE,
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0,
                    buf3 + sizeof(UINT32),
                    *((PUINT32)buf3) );
}


template<>
EccImp<ImpXxx, AlgEcdsaSign>::EccImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcdsaSign>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcdsaSign>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcdsaSign>;
}

template<>
EccImp<ImpXxx, AlgEcdsaSign>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcdsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEckey<ImpXxx>( buf1, buf2, buf3, SYMCRYPT_FLAG_ECKEY_ECDSA );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcdsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgEcdsaVerify>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcDsaVerify(
                    ((PSYMCRYPT_ECKEY *) buf2)[0],
                    ((PBYTE *) buf2)[1],
                    SYMCRYPT_SHA512_RESULT_SIZE,
                    buf3 + sizeof(UINT32),
                    *((PUINT32)buf3),
                    SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                    0 );
}


template<>
EccImp<ImpXxx, AlgEcdsaVerify>::EccImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcdsaVerify>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcdsaVerify>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcdsaVerify>;
}

template<>
EccImp<ImpXxx, AlgEcdsaVerify>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcdh>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEckey<ImpXxx>( buf1, buf2, buf3, SYMCRYPT_FLAG_ECKEY_ECDH );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcdh>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgEcdh>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    UINT32 cbAgreedSecret = ScShimSymCryptEcurveSizeofFieldElement( *(PSYMCRYPT_ECURVE*)buf1);

    ScShimSymCryptEcDhSecretAgreement(
                ((PSYMCRYPT_ECKEY *) buf2)[0],
                ((PSYMCRYPT_ECKEY *) buf2)[0],      // Same private and public key
                SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                0,
                buf3 + sizeof(UINT32),
                cbAgreedSecret );
}


template<>
EccImp<ImpXxx, AlgEcdh>::EccImp()
{
    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcdh>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcdh>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcdh>;
}

template<>
EccImp<ImpXxx, AlgEcdh>::~EccImp()
{
}

//============================
#if SYMCRYPT_MS_VC
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIEEE802_11SaeCustom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    ScShimSymCrypt802_11SaeCustomInit(
        (PSYMCRYPT_802_11_SAE_CUSTOM_STATE) buf1, &buf2[0], &buf2[6], &buf2[12], keySize, nullptr, nullptr, nullptr );

    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIEEE802_11SaeCustom>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    ScShimSymCrypt802_11SaeCustomDestroy(
        (PSYMCRYPT_802_11_SAE_CUSTOM_STATE) buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIEEE802_11SaeCustom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCrypt802_11SaeCustomCommitCreate(
        (PSYMCRYPT_802_11_SAE_CUSTOM_STATE) buf1, buf2, buf3 );

    UNREFERENCED_PARAMETER( dataSize );
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx,AlgIEEE802_11SaeCustom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    ScShimSymCrypt802_11SaeCustomCommitProcess(
        (PSYMCRYPT_802_11_SAE_CUSTOM_STATE) buf1, buf2, buf3, &buf3[1024], &buf3[2048] );

    UNREFERENCED_PARAMETER( dataSize );
}

template<>
ArithImp<ImpXxx, AlgIEEE802_11SaeCustom>::ArithImp()
{
    if( !SCTEST_LOOKUP_SCIMPSYM(SymCrypt802_11SaeCustomInit) )
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIEEE802_11SaeCustom>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction<ImpXxx, AlgIEEE802_11SaeCustom>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIEEE802_11SaeCustom>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIEEE802_11SaeCustom>;
}

template<>
ArithImp<ImpXxx, AlgIEEE802_11SaeCustom>::~ArithImp()
{
}
#endif


/////////////////////////
// Big integer
//


template<>
VOID
setupPerfInt<ImpXxx>( PBYTE pb, SIZE_T cb, UINT32 nDigits )
{
    *(PSYMCRYPT_INT*)pb = ScShimSymCryptIntCreate(
        pb + SYMCRYPT_ASYM_ALIGN_VALUE, cb - SYMCRYPT_ASYM_ALIGN_VALUE, nDigits);
}

template<>
VOID
setupIntsForPerfFunction<ImpXxx>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T inSize, UINT32 outFactor )
{
    BYTE buf[2048];

    CHECK( 2*inSize <= sizeof( buf ), "?" );
    GENRANDOM( buf, (UINT32)(2*inSize) );

    UINT32 nDigitsIn = ScShimSymCryptDigitsFromBits( (UINT32) (8 * inSize) );
    UINT32 nDigitsOut = outFactor * nDigitsIn;

    setupPerfInt<ImpXxx>( buf1, SCRATCH_BUF_OFFSET, nDigitsIn );
    setupPerfInt<ImpXxx>( buf2, SCRATCH_BUF_OFFSET, nDigitsIn );
    setupPerfInt<ImpXxx>( buf3, SCRATCH_BUF_OFFSET, nDigitsOut );

    ScShimSymCryptIntSetValue( buf, (UINT32) inSize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, *(PSYMCRYPT_INT *) buf1 );
    ScShimSymCryptIntSetValue( buf+inSize, (UINT32) inSize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, *(PSYMCRYPT_INT *) buf2 );
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIntAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupIntsForPerfFunction<ImpXxx>( buf1, buf2, buf3, keySize, 1 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIntAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIntAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptIntAddSameSize( *(PSYMCRYPT_INT *) buf1, *(PSYMCRYPT_INT *) buf2, *(PSYMCRYPT_INT *) buf3 );
}


template<>
ArithImp<ImpXxx, AlgIntAdd>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntAddSameSize))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIntAdd>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIntAdd>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIntAdd>;
}

template<>
ArithImp<ImpXxx, AlgIntAdd>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIntSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupIntsForPerfFunction<ImpXxx>( buf1, buf2, buf3, keySize, 1 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIntSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIntSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptIntSubSameSize( *(PSYMCRYPT_INT *) buf1, *(PSYMCRYPT_INT *) buf2, *(PSYMCRYPT_INT *) buf3 );
}


template<>
ArithImp<ImpXxx, AlgIntSub>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntSubSameSize))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIntSub>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIntSub>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIntSub>;
}

template<>
ArithImp<ImpXxx, AlgIntSub>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIntMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupIntsForPerfFunction<ImpXxx>( buf1, buf2, buf3, keySize, 2 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIntMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIntMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptIntMulSameSize( *(PSYMCRYPT_INT *) buf1, *(PSYMCRYPT_INT *) buf2, *(PSYMCRYPT_INT *) buf3, buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgIntMul>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntMulSameSize))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIntMul>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIntMul>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIntMul>;
}

template<>
ArithImp<ImpXxx, AlgIntMul>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIntSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupIntsForPerfFunction<ImpXxx>( buf1, buf2, buf3, keySize, 2 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIntSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIntSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    UNREFERENCED_PARAMETER( buf2 );
    ScShimSymCryptIntSquare( *(PSYMCRYPT_INT *) buf1, *(PSYMCRYPT_INT *) buf3, buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgIntSquare>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntSquare))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIntSquare>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIntSquare>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIntSquare>;
}

template<>
ArithImp<ImpXxx, AlgIntSquare>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgIntDivMod>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    BYTE buf[4096];
    PSYMCRYPT_INT piDiv;

    CHECK3( 3*keySize <= sizeof( buf ), "keySize too big %08x", keySize );
    GENRANDOM( buf, (UINT32)(3*keySize) );

    UINT32 nDigits = ScShimSymCryptDigitsFromBits( (UINT32) (8 * keySize) );
    UINT32 numSize = ScShimSymCryptSizeofIntFromDigits( 2*nDigits );

    *(PSYMCRYPT_DIVISOR *) buf2 = ScShimSymCryptDivisorCreate( buf2 + SYMCRYPT_ASYM_ALIGN_VALUE, PERF_BUFFER_SIZE-SYMCRYPT_ASYM_ALIGN_VALUE, nDigits );
    ((PSYMCRYPT_INT *) buf1)[0] = ScShimSymCryptIntCreate( buf1 + SYMCRYPT_ASYM_ALIGN_VALUE, numSize, nDigits * 2 );

    buf[0] |= 0x80;     // Make sure highest bit in divisor is set (using MSByte first for simplicity)
    piDiv = ScShimSymCryptIntFromDivisor( *(PSYMCRYPT_DIVISOR*)buf2 );
    ScShimSymCryptIntSetValue( buf, (UINT32)keySize, SYMCRYPT_NUMBER_FORMAT_MSB_FIRST, piDiv );
    ScShimSymCryptIntToDivisor( piDiv, *(PSYMCRYPT_DIVISOR *)buf2, 1000, 0, buf3, PERF_BUFFER_SIZE );

    ScShimSymCryptIntSetValue( buf+keySize, (UINT32) 2*keySize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, *(PSYMCRYPT_INT *) buf1 );

    ((PSYMCRYPT_INT *) buf3)[0] = ScShimSymCryptIntCreate( buf3 + SYMCRYPT_ASYM_ALIGN_VALUE, numSize, nDigits * 2 );
    ((PSYMCRYPT_INT *) buf3)[1] = ScShimSymCryptIntCreate( buf3 + SYMCRYPT_ASYM_ALIGN_VALUE + numSize, numSize, nDigits );
    CHECK( 2*numSize + SYMCRYPT_ASYM_ALIGN_VALUE <= SCRATCH_BUF_OFFSET, "DivMod destinations overlap scratch buffer" );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgIntDivMod>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgIntDivMod>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    UNREFERENCED_PARAMETER( buf2 );
    ScShimSymCryptIntDivMod( *(PSYMCRYPT_INT*)buf1, *(PSYMCRYPT_DIVISOR*)buf2, ((PSYMCRYPT_INT*)buf3)[0], ((PSYMCRYPT_INT*)buf3)[1], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgIntDivMod>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntDivMod))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgIntDivMod>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgIntDivMod>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgIntDivMod>;
}

template<>
ArithImp<ImpXxx, AlgIntDivMod>::~ArithImp()
{
}

//
// SetupModulus
// Initializes a modulus of the desired keysize & features
//
// *((PSYMCRYPT_MODULUS *) buf1) will contain a pointer to the modulus, which is also in buf1.
// buf3 is used as scratch
//
template<>
VOID
setupModulus<ImpXxx>( PBYTE buf1, PBYTE buf3, SIZE_T keySize )
{
    UINT32 keyBytes = (UINT32) keySize & 0x00ffffff;
    UINT32 keyFlags = (UINT32) keySize & 0xff000000;

    UINT32 nDigits = ScShimSymCryptDigitsFromBits( 8 * keyBytes );
    PSYMCRYPT_INT piMod;

    PSYMCRYPT_MODULUS pmMod = ScShimSymCryptModulusCreate( buf1 + SYMCRYPT_ASYM_ALIGN_VALUE, PERF_BUFFER_SIZE - SYMCRYPT_ASYM_ALIGN_VALUE, nDigits );

    piMod = ScShimSymCryptIntFromModulus( pmMod );
    ScShimSymCryptIntSetValue(
                        getPerfTestModulus((UINT32)keySize),
                        ((UINT32)keySize) & 0x00ffffff,
                        SYMCRYPT_NUMBER_FORMAT_MSB_FIRST,
                        piMod );

    UINT32 flags = 0;
    switch( keyFlags & ~PERF_KEY_PRIME )
    {
    case PERF_KEY_SECRET:   flags = 0; break;
    case PERF_KEY_PUB_ODD:  flags = SYMCRYPT_FLAG_MODULUS_PARITY_PUBLIC; break;
    case PERF_KEY_PUBLIC:   flags = SYMCRYPT_FLAG_DATA_PUBLIC; break;
    case PERF_KEY_PUB_PM:   flags = SYMCRYPT_FLAG_DATA_PUBLIC; break;
    case PERF_KEY_PUB_NIST: flags = SYMCRYPT_FLAG_DATA_PUBLIC; break;
    default: CHECK(FALSE, "?" );
    }

    flags |= SYMCRYPT_FLAG_MODULUS_PRIME;   // All our moduli are prime values, and Inv requires it at the moment.

    ScShimSymCryptIntToModulus( piMod, pmMod, 10000, flags, buf3, PERF_BUFFER_SIZE );

    *((PSYMCRYPT_MODULUS *) buf1) = pmMod;
}

//
// setupModOperations
// Initializes a modulus in buf1, two modElements in buf2, and one modElement in buf3.
// The modElements in buf2 are set to random values
//
template<>
void
setupModOperations<ImpXxx>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    BYTE buf[4096];
    SYMCRYPT_ERROR scError;

    UINT32 keyBytes = (UINT32) keySize & 0x00ffffff;
    CHECK( 2 * keyBytes <= sizeof( buf ), "?" );
    GENRANDOM( buf, (2*keyBytes) );

    setupModulus<ImpXxx>( buf1, buf3, keySize );
    PCSYMCRYPT_MODULUS pmMod = *((PCSYMCRYPT_MODULUS *)buf1);

    UINT32 modElSize = ScShimSymCryptSizeofModElementFromModulus( pmMod );
    PSYMCRYPT_MODELEMENT * pPtrs = ((PSYMCRYPT_MODELEMENT *) buf2);
    pPtrs[0] = ScShimSymCryptModElementCreate( buf2 + SYMCRYPT_ASYM_ALIGN_VALUE, modElSize, pmMod );
    pPtrs[1] = ScShimSymCryptModElementCreate( buf2 + SYMCRYPT_ASYM_ALIGN_VALUE + modElSize, modElSize, pmMod );

    ((PSYMCRYPT_MODELEMENT *) buf3)[0] = ScShimSymCryptModElementCreate( buf3 + SYMCRYPT_ASYM_ALIGN_VALUE, modElSize, pmMod );

    CHECK( modElSize + SYMCRYPT_ASYM_ALIGN_VALUE <= SCRATCH_BUF_OFFSET, "ModElement overlaps with scratch buffer" );

    scError = ScShimSymCryptModElementSetValue( buf, modElSize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, pmMod, pPtrs[0], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );
    scError = ScShimSymCryptModElementSetValue( buf+modElSize, modElSize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, pmMod, pPtrs[1], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
    CHECK( scError == SYMCRYPT_NO_ERROR, "?" );

}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgModAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptModAdd( *(PSYMCRYPT_MODULUS *) buf1, ((PSYMCRYPT_MODELEMENT *) buf2)[0], ((PSYMCRYPT_MODELEMENT *) buf2)[1], ((PSYMCRYPT_MODELEMENT *) buf3)[0],  buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgModAdd>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModAdd))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModAdd>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModAdd>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModAdd>;
}

template<>
ArithImp<ImpXxx, AlgModAdd>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgModSub>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptModSub( *(PSYMCRYPT_MODULUS *) buf1, ((PSYMCRYPT_MODELEMENT *) buf2)[0], ((PSYMCRYPT_MODELEMENT *) buf2)[1], ((PSYMCRYPT_MODELEMENT *) buf3)[0],  buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgModSub>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModSub))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModSub>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModSub>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModSub>;
}

template<>
ArithImp<ImpXxx, AlgModSub>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgModMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptModMul( *(PSYMCRYPT_MODULUS *) buf1, ((PSYMCRYPT_MODELEMENT *) buf2)[0], ((PSYMCRYPT_MODELEMENT *) buf2)[1], ((PSYMCRYPT_MODELEMENT *) buf3)[0],  buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgModMul>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModMul))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModMul>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModMul>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModMul>;
}

template<>
ArithImp<ImpXxx, AlgModMul>::~ArithImp()
{
}



template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModExp>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    BYTE buf[4096];
    UINT32 keyBytes = (UINT32) keySize & 0x00ffffff;
    UINT32 nDigits = 0;

    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );

    CHECK( keyBytes <= sizeof( buf ), "?" );
    GENRANDOM( buf, keyBytes );

    nDigits = ScShimSymCryptDigitsFromBits( 8 * keyBytes);

    ((PSYMCRYPT_INT *) buf2)[1] = ScShimSymCryptIntCreate(
        (PBYTE)(((PSYMCRYPT_INT *) buf2)[1]) + SYMCRYPT_ASYM_ALIGN_VALUE, SCRATCH_BUF_OFFSET - SYMCRYPT_ASYM_ALIGN_VALUE, nDigits );

    ScShimSymCryptIntSetValue( buf, keyBytes, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, ((PSYMCRYPT_INT *) buf2)[1] );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModExp>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgModExp>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    PSYMCRYPT_INT piMod = ScShimSymCryptIntFromModulus( *(PSYMCRYPT_MODULUS *) buf1 );
    UINT32 nBitsExp = ScShimSymCryptIntBitsizeOfValue( piMod );

    ScShimSymCryptModExp(
                *(PSYMCRYPT_MODULUS *) buf1,
                ((PSYMCRYPT_MODELEMENT *) buf2)[0],
                ((PSYMCRYPT_INT *) buf2)[1],
                nBitsExp,
                0,      // Default flags: Side-channel safe
                ((PSYMCRYPT_MODELEMENT *) buf3)[0],
                buf3 + SCRATCH_BUF_OFFSET,
                SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgModExp>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModExp))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModExp>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModExp>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModExp>;
}

template<>
ArithImp<ImpXxx, AlgModExp>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgModSquare>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    ScShimSymCryptModSquare( *(PSYMCRYPT_MODULUS *) buf1, ((PSYMCRYPT_MODELEMENT *) buf2)[0], ((PSYMCRYPT_MODELEMENT *) buf3)[0],  buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
}


template<>
ArithImp<ImpXxx, AlgModSquare>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModSquare))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModSquare>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModSquare>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModSquare>;
}

template<>
ArithImp<ImpXxx, AlgModSquare>::~ArithImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgModInv>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    setupModOperations<ImpXxx>( buf1, buf2, buf3, keySize );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgModInv>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgModInv>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    SYMCRYPT_ERROR scError;
    scError = ScShimSymCryptModInv(
                                *(PSYMCRYPT_MODULUS *) buf1,
                                ((PSYMCRYPT_MODELEMENT *) buf2)[0],
                                ((PSYMCRYPT_MODELEMENT *) buf3)[0],
                                0,
                                buf3 + SCRATCH_BUF_OFFSET,
                                SCRATCH_BUF_SIZE );
    CHECK( scError == SYMCRYPT_NO_ERROR, "Error in perf test case" );
}


template<>
ArithImp<ImpXxx, AlgModInv>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptModInv))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgModInv>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgModInv>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgModInv>;
}

template<>
ArithImp<ImpXxx, AlgModInv>::~ArithImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgTrialDivision>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    // We create two fake trial division contexts to measure the performance of both the group modulo reduction
    // and the actual per-prime test.
    // One context has 1000 groups of 11 primes each.
    // One context has 1000 groups of 1 prime each.
    // Together these measurements allow us to determine the cost per group and cost per prime which we need
    // to tune the choice of trial division limit.

    // First create the input in buf3.
    // But make sure it is odd because the prime fake doesn't work on 2

    createFakeTrialDivisionContext( buf1, 1 );
    createFakeTrialDivisionContext( buf2, 11 );

    UINT32 numDigits = ScShimSymCryptDigitsFromBits( (UINT32)keySize * 8 );

    PSYMCRYPT_INT piSrc = ScShimSymCryptIntCreate( buf3 + 64, PERF_BUFFER_SIZE - 64, numDigits );

    PBYTE p = buf3 + PERF_BUFFER_SIZE/2;
    GENRANDOM( p, (ULONG) keySize );
    p[0] |= 1;   // Make sure it is odd so we don't get zeroes...
    ScShimSymCryptIntSetValue( p, keySize, SYMCRYPT_NUMBER_FORMAT_LSB_FIRST, piSrc );

    *(PSYMCRYPT_INT *) buf3 = piSrc;
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgTrialDivision>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgTrialDivision>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( dataSize );

    PCSYMCRYPT_TRIALDIVISION_CONTEXT pContext = (PCSYMCRYPT_TRIALDIVISION_CONTEXT) buf1;
    PCSYMCRYPT_INT piSrc = *(PCSYMCRYPT_INT *) buf3;

    *(PUINT32) (buf3 + PERF_BUFFER_SIZE/2) = ScShimSymCryptIntFindSmallDivisor( pContext, piSrc, nullptr, 0 );
}

template<>
VOID
algImpDecryptPerfFunction< ImpXxx, AlgTrialDivision>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( dataSize );

    PCSYMCRYPT_TRIALDIVISION_CONTEXT pContext = (PCSYMCRYPT_TRIALDIVISION_CONTEXT) buf2;
    PCSYMCRYPT_INT piSrc = *(PCSYMCRYPT_INT *) buf3;

    *(PUINT32) (buf3 + PERF_BUFFER_SIZE/2) = ScShimSymCryptIntFindSmallDivisor( pContext, piSrc, nullptr, 0 );
}


template<>
ArithImp<ImpXxx, AlgTrialDivision>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptIntFindSmallDivisor))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgTrialDivision>;
    m_perfDecryptFunction   = &algImpDecryptPerfFunction  <ImpXxx, AlgTrialDivision>;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgTrialDivision>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgTrialDivision>;
}

template<>
ArithImp<ImpXxx, AlgTrialDivision>::~ArithImp()
{
}

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgTrialDivisionContext>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    *(UINT32 *) buf2 = (UINT32) keySize;
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgTrialDivisionContext>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );

    *(PCSYMCRYPT_TRIALDIVISION_CONTEXT *) buf1 = NULL;
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgTrialDivisionContext>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    PCSYMCRYPT_TRIALDIVISION_CONTEXT context;

    UINT32 numDigits = ScShimSymCryptDigitsFromBits( 8 * *(UINT32 *) buf2 );
    context = ScShimSymCryptCreateTrialDivisionContext( numDigits );

    // Save a copy of the pointer to stop the compiler from optimizing the whole thing away.
    *(PCSYMCRYPT_TRIALDIVISION_CONTEXT *) buf1 = context;

    ScShimSymCryptFreeTrialDivisionContext( context );
}


template<>
ArithImp<ImpXxx, AlgTrialDivisionContext>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptCreateTrialDivisionContext))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgTrialDivisionContext>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgTrialDivisionContext>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgTrialDivisionContext>;
}

template<>
ArithImp<ImpXxx, AlgTrialDivisionContext>::~ArithImp()
{
}



template<>
void
SetupSymCryptEcpoints<ImpXxx>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    PSYMCRYPT_INT piScalar;

    PCSYMCRYPT_ECURVE pCurve = *((PCSYMCRYPT_ECURVE *)buf1);

    UINT32 ecpointSize = ScShimSymCryptSizeofEcpointFromCurve( pCurve );
    UINT32 numDigits = ScShimSymCryptEcurveDigitsofScalarMultiplier( pCurve );
    UINT32 scalarSize = ScShimSymCryptSizeofIntFromDigits( numDigits );

    PSYMCRYPT_ECPOINT * pPtrs = ((PSYMCRYPT_ECPOINT *) buf2);
    pPtrs[0] = ScShimSymCryptEcpointCreate( buf2 + 32, ecpointSize, pCurve );
    pPtrs[1] = ScShimSymCryptEcpointCreate( buf2 + 32 + ecpointSize, ecpointSize, pCurve );

    piScalar = ScShimSymCryptIntCreate( buf2 + 32 + 2*ecpointSize, scalarSize, numDigits );
    pPtrs[2] = (PSYMCRYPT_ECPOINT) piScalar;

    ((PSYMCRYPT_ECPOINT *) buf3)[0] = ScShimSymCryptEcpointCreate( buf3 + 32, ecpointSize, pCurve );

    CHECK( ecpointSize + 32 <= SCRATCH_BUF_OFFSET, "Destination ECPOINT overlaps with scratch buffer" );

    ScShimSymCryptEcpointSetRandom( pCurve, piScalar, pPtrs[0], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );

    ScShimSymCryptEcpointSetRandom( pCurve, piScalar, pPtrs[1], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );

    if( !SYMCRYPT_CURVE_IS_MONTGOMERY_TYPE( pCurve ) )
    {
        ScShimSymCryptEcpointSetZero( pCurve, ((PSYMCRYPT_ECPOINT *) buf3)[0], buf3 + SCRATCH_BUF_OFFSET, SCRATCH_BUF_SIZE );
    }
}


//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointSetZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointSetZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointSetZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointSetZero(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf3)[0],
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointSetZero>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointSetZero))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointSetZero>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointSetZero>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointSetZero>;
}

template<>
EccImp<ImpXxx, AlgEcpointSetZero>::~EccImp()
{
    // We free the global curves in just this destructor (which is called once at the end of the
    // unit tests) to avoid memory leaks. See the comments by g_pCurves declaration above.
    CleanupSymCryptCurves<ImpXxx>();
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointSetDistinguished>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointSetDistinguished>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointSetDistinguished>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointSetDistinguishedPoint(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf3)[0],
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointSetDistinguished>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointSetDistinguishedPoint))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointSetDistinguished>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointSetDistinguished>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointSetDistinguished>;
}

template<>
EccImp<ImpXxx, AlgEcpointSetDistinguished>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointSetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointSetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointSetRandom>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointSetRandom(
                    *(PSYMCRYPT_ECURVE *) buf1,
                    ((PSYMCRYPT_INT *) buf2)[2],
                    ((PSYMCRYPT_ECPOINT *) buf3)[0],
                    buf3 + SCRATCH_BUF_OFFSET,
                    SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointSetRandom>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointSetRandom))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointSetRandom>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointSetRandom>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointSetRandom>;
}

template<>
EccImp<ImpXxx, AlgEcpointSetRandom>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointIsEqual>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointIsEqual>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointIsEqual>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointIsEqual(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        ((PSYMCRYPT_ECPOINT *) buf2)[1],
        SYMCRYPT_FLAG_ECPOINT_EQUAL | SYMCRYPT_FLAG_ECPOINT_NEG_EQUAL,
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointIsEqual>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointIsEqual))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointIsEqual>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointIsEqual>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointIsEqual>;
}

template<>
EccImp<ImpXxx, AlgEcpointIsEqual>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointIsZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointIsZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointIsZero>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointIsZero(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointIsZero>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointIsZero))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointIsZero>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointIsZero>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointIsZero>;
}

template<>
EccImp<ImpXxx, AlgEcpointIsZero>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointOnCurve>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointOnCurve>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointOnCurve>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( buf3 );
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointOnCurve(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointOnCurve>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointOnCurve))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointOnCurve>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointOnCurve>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointOnCurve>;
}

template<>
EccImp<ImpXxx, AlgEcpointOnCurve>::~EccImp()
{
}


//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointAdd>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointAdd(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        ((PSYMCRYPT_ECPOINT *) buf2)[1],
        ((PSYMCRYPT_ECPOINT *) buf3)[0],
        0,                                  // Side-channel safe version
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointAdd>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointAdd))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointAdd>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointAdd>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointAdd>;
}

template<>
EccImp<ImpXxx, AlgEcpointAdd>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointAddDiffNz>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );

    do {
        SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
    }
    while (ScShimSymCryptEcpointIsEqual(
                *(PSYMCRYPT_ECURVE *) buf1,
                ((PSYMCRYPT_ECPOINT *) buf2)[0],
                ((PSYMCRYPT_ECPOINT *) buf2)[1],
                SYMCRYPT_FLAG_ECPOINT_EQUAL | SYMCRYPT_FLAG_ECPOINT_NEG_EQUAL,
                buf3 + SCRATCH_BUF_OFFSET,
                SCRATCH_BUF_SIZE ) );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointAddDiffNz>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointAddDiffNz>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointAddDiffNonZero(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        ((PSYMCRYPT_ECPOINT *) buf2)[1],
        ((PSYMCRYPT_ECPOINT *) buf3)[0],
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointAddDiffNz>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointAddDiffNonZero))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointAddDiffNz>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointAddDiffNz>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointAddDiffNz>;
}

template<>
EccImp<ImpXxx, AlgEcpointAddDiffNz>::~EccImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointDouble>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );

    do {
        SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
    }
    while (ScShimSymCryptEcpointIsEqual(
                *(PSYMCRYPT_ECURVE *) buf1,
                ((PSYMCRYPT_ECPOINT *) buf2)[0],
                ((PSYMCRYPT_ECPOINT *) buf3)[0],        // buf3 is set to the zero point in SetupSymCryptEcpoints<ImpXxx>
                SYMCRYPT_FLAG_ECPOINT_EQUAL | SYMCRYPT_FLAG_ECPOINT_NEG_EQUAL,
                buf3 + SCRATCH_BUF_OFFSET,
                SCRATCH_BUF_SIZE ) );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointDouble>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointDouble>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointDouble(
        *(PSYMCRYPT_ECURVE *) buf1,
        ((PSYMCRYPT_ECPOINT *) buf2)[0],
        ((PSYMCRYPT_ECPOINT *) buf3)[0],
        0,                                  // Side-channel safe version
        buf3 + SCRATCH_BUF_OFFSET,
        SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointDouble>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointDouble))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointDouble>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointDouble>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointDouble>;
}

template<>
EccImp<ImpXxx, AlgEcpointDouble>::~EccImp()
{
}

//============================
template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgScsTable>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    UINT32 nElements = 32;
    PSYMCRYPT_SCSTABLE  pTable = (PSYMCRYPT_SCSTABLE) buf1;

    UINT32 cbBuffer = ScShimSymCryptScsTableInit( pTable, nElements, (UINT32) keySize );
    ScShimSymCryptScsTableSetBuffer( pTable, buf2, cbBuffer );

    for( UINT32 i=0; i<nElements; i++ )
    {
        GENRANDOM( buf3, (UINT32) keySize );
        ScShimSymCryptScsTableStore( pTable, i, buf3, (UINT32) keySize );
    }
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx,AlgScsTable>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgScsTable>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );
    UNREFERENCED_PARAMETER( buf2 );
    PSYMCRYPT_SCSTABLE  pTable = (PSYMCRYPT_SCSTABLE) buf1;
    ScShimSymCryptScsTableLoad( pTable, 7, buf3, pTable->elementSize );
}


template<>
ArithImp<ImpXxx, AlgScsTable>::ArithImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptScsTableLoad))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgScsTable>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgScsTable>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgScsTable>;
}

template<>
ArithImp<ImpXxx, AlgScsTable>::~ArithImp()
{
}

//============================

template<>
VOID
algImpKeyPerfFunction<ImpXxx, AlgEcpointScalarMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize )
{
    SetupSymCryptCurves<ImpXxx>( buf1, keySize );
    SetupSymCryptEcpoints<ImpXxx>( buf1, buf2, buf3 );
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgEcpointScalarMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3 )
{
    UNREFERENCED_PARAMETER( buf1 );
    UNREFERENCED_PARAMETER( buf2 );
    UNREFERENCED_PARAMETER( buf3 );
}

template<>
VOID
algImpDataPerfFunction< ImpXxx, AlgEcpointScalarMul>( PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize )
{
    UNREFERENCED_PARAMETER( dataSize );

    ScShimSymCryptEcpointScalarMul(
                *(PSYMCRYPT_ECURVE *) buf1,
                ((PSYMCRYPT_INT *) buf2)[2],
                ((PSYMCRYPT_ECPOINT *) buf2)[0],
                0,
                ((PSYMCRYPT_ECPOINT *) buf3)[0],
                buf3 + SCRATCH_BUF_OFFSET,
                SCRATCH_BUF_SIZE );
}


template<>
EccImp<ImpXxx, AlgEcpointScalarMul>::EccImp()
{
    if (!SCTEST_LOOKUP_SCIMPSYM(SymCryptEcpointScalarMul))
    {
        throw STATUS_NOT_SUPPORTED;
    }

    m_perfDataFunction      = &algImpDataPerfFunction <ImpXxx, AlgEcpointScalarMul>;
    m_perfDecryptFunction   = NULL;
    m_perfKeyFunction       = &algImpKeyPerfFunction  <ImpXxx, AlgEcpointScalarMul>;
    m_perfCleanFunction     = &algImpCleanPerfFunction<ImpXxx, AlgEcpointScalarMul>;
}

template<>
EccImp<ImpXxx, AlgEcpointScalarMul>::~EccImp()
{
}

#ifndef PERF_XMSS_DATA
#define PERF_XMSS_DATA

static const BYTE g_XmsskeySha2_10_256[] = {
    0x00, 0x00, 0x00, 0x01, 0xb3, 0x4c, 0x51, 0xe0, 0x09, 0xd2, 0x95, 0xdc, 0x8b, 0x3a, 0x43, 0x8a,
    0x7c, 0x1c, 0x6f, 0x53, 0xdb, 0x56, 0x58, 0x80, 0xad, 0x70, 0x93, 0xdb, 0x3f, 0xbf, 0xce, 0xca,
    0x4c, 0x8e, 0x76, 0x1e, 0x0e, 0xcf, 0xd6, 0xcc, 0x41, 0xd7, 0x12, 0x45, 0x5a, 0x4a, 0x23, 0xe5,
    0xfe, 0xe1, 0x7b, 0x43, 0xe4, 0xb9, 0xa3, 0x17, 0xbd, 0x82, 0xa1, 0x13, 0x62, 0x3a, 0xf0, 0x22,
    0xa9, 0xb2, 0xb6, 0xf7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xe5, 0x8e, 0x28, 0x3b,
    0x8c, 0xcc, 0x11, 0xd0, 0xe3, 0xbd, 0x3d, 0xec, 0xde, 0x6b, 0xff, 0xb6, 0xdc, 0x72, 0x99, 0x8b,
    0x7c, 0x40, 0xea, 0x27, 0xee, 0x5e, 0x97, 0x08, 0x7c, 0xdf, 0x0f, 0x74, 0x78, 0xc3, 0x03, 0x39,
    0x6f, 0x1e, 0x2c, 0x08, 0x46, 0x94, 0x17, 0x74, 0x4e, 0x17, 0x81, 0x24, 0x56, 0xaf, 0x1d, 0x54,
    0x04, 0xd1, 0x9e, 0xf8, 0x2f, 0x35, 0xbc, 0x88, 0x3c, 0x20, 0xb9, 0x42
};

static const BYTE g_XmssSigSha2_10_256[] = {
    0x00, 0x00, 0x00, 0x01, 0xe2, 0x1f, 0xf3, 0x69, 0xd0, 0x88, 0x30, 0xa4, 0x5b, 0x56, 0xc9, 0xdb, 0x63, 0xbc, 0x6f, 0x4a, 0x22, 0xd0, 0x5c, 0xec, 0x6c, 0x65, 0xa1, 0x41, 0xae, 0xe5, 0x33, 0x92, 
    0xe0, 0x1b, 0xb0, 0xe4, 0x74, 0x1d, 0x92, 0x8f, 0x75, 0xb4, 0xad, 0x78, 0x11, 0x36, 0xc7, 0x65, 0x5c, 0x4a, 0xd0, 0xad, 0x6e, 0xff, 0xef, 0x68, 0x46, 0x2d, 0x5a, 0x3e, 0x52, 0xe6, 0x0d, 0xce, 
    0x66, 0x39, 0x5d, 0x54, 0xc7, 0x06, 0x7e, 0xd1, 0x1c, 0xcc, 0x2b, 0x5b, 0x78, 0x5d, 0xc8, 0x54, 0xd8, 0x61, 0xe8, 0x09, 0xd1, 0x95, 0xad, 0x83, 0xf5, 0x82, 0x56, 0xca, 0xe2, 0x57, 0xe4, 0x0f, 
    0x99, 0xeb, 0x2e, 0xc3, 0x50, 0x1a, 0x04, 0xbc, 0xea, 0x8d, 0xca, 0x99, 0x6e, 0x3c, 0x2e, 0x7b, 0xcd, 0x93, 0x8e, 0x42, 0x42, 0x75, 0x1b, 0x93, 0x57, 0xfd, 0xc9, 0x00, 0xc8, 0x2d, 0xdf, 0x7c, 
    0x9c, 0x6b, 0x8c, 0x5c, 0x57, 0x93, 0xeb, 0xf3, 0x1f, 0xd6, 0x0e, 0x0a, 0x27, 0x19, 0xf7, 0x04, 0x08, 0x7f, 0x57, 0xdc, 0xb1, 0x75, 0x58, 0xe6, 0x7b, 0xd0, 0x25, 0x69, 0xdc, 0x49, 0xfb, 0xb5, 
    0x41, 0xcc, 0x00, 0x6d, 0x7e, 0x73, 0x01, 0x4e, 0xd6, 0xd7, 0xc2, 0x66, 0xe5, 0x8e, 0xc9, 0x50, 0x39, 0xf6, 0x53, 0x94, 0x90, 0x55, 0xee, 0xdf, 0x8d, 0xe0, 0xcb, 0x36, 0x2b, 0x9e, 0xc4, 0xfb, 
    0x82, 0xd6, 0xce, 0x01, 0xa1, 0xc3, 0xd2, 0xa4, 0x06, 0xd0, 0x02, 0xc0, 0x45, 0xc3, 0xe3, 0xe9, 0x31, 0xea, 0x6b, 0xbc, 0xa9, 0x1f, 0x0e, 0x9d, 0x83, 0x78, 0xfc, 0x9e, 0x78, 0xa2, 0xf4, 0xa8, 
    0x3e, 0xa2, 0xa1, 0x5a, 0x07, 0xc8, 0x75, 0xe9, 0x99, 0x43, 0xa4, 0x01, 0x17, 0x90, 0x0d, 0x03, 0x17, 0x32, 0x82, 0xac, 0x38, 0x26, 0x9f, 0xca, 0x69, 0x52, 0xf2, 0x78, 0xb2, 0x4f, 0xeb, 0x8e, 
    0xdc, 0xf1, 0x5d, 0xd6, 0x36, 0x97, 0x91, 0x70, 0xec, 0x40, 0xd5, 0xaa, 0x30, 0xa9, 0x07, 0x1f, 0x77, 0x77, 0xab, 0xb6, 0x2b, 0xc6, 0x78, 0x30, 0x08, 0x03, 0x7f, 0x9f, 0x1e, 0xd9, 0x7c, 0x4f, 
    0x03, 0xf3, 0x88, 0xd6, 0x88, 0xb0, 0x2b, 0x54, 0x1c, 0x2d, 0xd0, 0xae, 0xfc, 0x1b, 0x28, 0x5c, 0xdb, 0x3e, 0x0c, 0x6b, 0xe3, 0xe7, 0xb0, 0x8e, 0xf3, 0x4f, 0xad, 0xc8, 0x8a, 0x7a, 0xf9, 0xdb, 
    0xa4, 0xfe, 0x69, 0xf8, 0xdf, 0x1d, 0x36, 0xfc, 0x01, 0x38, 0xf6, 0x5b, 0xdb, 0x43, 0x73, 0xd4, 0x74, 0x42, 0xb3, 0xc3, 0x7c, 0x14, 0x6a, 0x72, 0x4d, 0xe3, 0x1d, 0x71, 0x56, 0x77, 0xb9, 0xfa, 
    0xa0, 0x9f, 0x31, 0x85, 0x0e, 0x5d, 0xc7, 0xd5, 0xf3, 0x9c, 0x34, 0x2c, 0x16, 0x92, 0x40, 0xc8, 0x11, 0x58, 0xd5, 0x87, 0x21, 0x78, 0x6d, 0x96, 0x47, 0x4b, 0xcb, 0x86, 0x99, 0xee, 0x35, 0xd7, 
    0xec, 0xdd, 0xfb, 0x9c, 0xcc, 0x1c, 0x08, 0x6e, 0x1a, 0xde, 0x52, 0xc8, 0x18, 0x49, 0x9b, 0x28, 0x2c, 0x86, 0xc3, 0x6d, 0x9c, 0x52, 0x6d, 0x94, 0xc1, 0x46, 0xa4, 0x5a, 0xb1, 0x3e, 0x83, 0x3d, 
    0xa9, 0x16, 0xe2, 0x25, 0xe3, 0xdc, 0xbe, 0x8a, 0xd1, 0xa7, 0x73, 0x7b, 0x55, 0xa2, 0x5a, 0x8e, 0x77, 0x10, 0x62, 0x26, 0x93, 0xaa, 0x5d, 0x49, 0x1a, 0x26, 0x96, 0x7c, 0xd9, 0x5d, 0x47, 0x9d, 
    0x8b, 0xf2, 0x9c, 0x36, 0x21, 0x62, 0x2d, 0x89, 0x6e, 0x9b, 0x4b, 0x99, 0x06, 0xf2, 0x52, 0x18, 0xf6, 0x9b, 0x16, 0xa4, 0x16, 0xd7, 0x47, 0xee, 0xca, 0x8b, 0x9a, 0xa0, 0x34, 0x4e, 0xfd, 0x51, 
    0x60, 0x4a, 0x50, 0x6b, 0xee, 0x71, 0x4e, 0x86, 0x8e, 0x3d, 0xbe, 0xba, 0xd5, 0x19, 0xbc, 0x51, 0xf4, 0x80, 0x0d, 0x63, 0xee, 0x41, 0x9d, 0xbe, 0xf0, 0x01, 0x9c, 0x9c, 0xfe, 0x20, 0x78, 0x54, 
    0x76, 0xcc, 0xcf, 0x90, 0xe2, 0xe6, 0xb2, 0x7a, 0xd4, 0x91, 0x06, 0x5b, 0x6a, 0x77, 0x73, 0xc1, 0x31, 0xba, 0x62, 0xef, 0x21, 0x98, 0xce, 0x73, 0x9d, 0x43, 0x4c, 0xdc, 0xb9, 0x92, 0x0a, 0x4a, 
    0xa3, 0x46, 0x51, 0xdb, 0xc3, 0xb0, 0x95, 0x16, 0x5f, 0xbc, 0xf2, 0x4d, 0x5f, 0xcc, 0x4e, 0x35, 0x5a, 0x95, 0x52, 0x2e, 0x28, 0xbe, 0x2b, 0x2c, 0x6f, 0x28, 0x04, 0xa6, 0x82, 0xa3, 0xba, 0x00, 
    0x0d, 0x19, 0xc4, 0x02, 0x0b, 0x91, 0x77, 0x29, 0x88, 0x13, 0x7c, 0xdd, 0xbf, 0xb2, 0xc2, 0x3b, 0x37, 0xb0, 0xf4, 0xc0, 0x34, 0x1f, 0xde, 0xe8, 0xa5, 0x6a, 0xe9, 0x7f, 0xe6, 0xd0, 0x9e, 0x8f, 
    0x05, 0x97, 0x14, 0xa8, 0xb0, 0x97, 0x14, 0x7f, 0x00, 0xa0, 0xb9, 0x1f, 0x3f, 0x79, 0xc7, 0x5d, 0x21, 0x70, 0x37, 0x6b, 0x9d, 0xbe, 0x01, 0x1e, 0x81, 0x61, 0x14, 0xc5, 0xf7, 0x42, 0x9f, 0xa9, 
    0x4b, 0x65, 0x22, 0x51, 0xc9, 0xa6, 0xa2, 0x28, 0xe7, 0x5f, 0xc4, 0x34, 0xd1, 0x6b, 0xbd, 0x58, 0x2d, 0x12, 0x46, 0x9e, 0x2d, 0x29, 0xe0, 0x8d, 0x73, 0x1e, 0xd6, 0xad, 0x63, 0xa5, 0x20, 0xe5, 
    0x54, 0x8d, 0x31, 0x5c, 0x10, 0x85, 0xf2, 0x84, 0x1b, 0x71, 0x40, 0x2a, 0x09, 0x0a, 0x04, 0xe7, 0x5d, 0x85, 0x54, 0xb7, 0xdf, 0x9e, 0x84, 0x14, 0x8c, 0x08, 0xdf, 0xc1, 0x4a, 0x90, 0x15, 0xb6, 
    0x97, 0x02, 0xfa, 0xb5, 0xeb, 0x57, 0xf8, 0xe6, 0xde, 0xb0, 0x7a, 0xa0, 0x44, 0x57, 0x47, 0xeb, 0xeb, 0x02, 0xe0, 0x7b, 0xc4, 0x84, 0xf4, 0x26, 0x9c, 0xac, 0xe9, 0x7b, 0x17, 0xbb, 0x91, 0x22, 
    0x2b, 0x18, 0xfa, 0xab, 0x14, 0xeb, 0xde, 0x8a, 0x6b, 0x5b, 0xa6, 0x21, 0x41, 0x7e, 0x14, 0x99, 0xea, 0x45, 0xc7, 0x06, 0x8c, 0x75, 0xca, 0xe2, 0xb1, 0x8e, 0x81, 0xce, 0x10, 0x2d, 0xe8, 0x8a, 
    0x5a, 0x67, 0xd3, 0x93, 0xab, 0x8c, 0xe0, 0x28, 0x88, 0xa8, 0xee, 0x2e, 0x26, 0xe6, 0xfa, 0xf2, 0xb5, 0xd4, 0x52, 0xa4, 0x88, 0xad, 0xdb, 0xff, 0x96, 0xaa, 0x0e, 0x3f, 0xa0, 0xfa, 0x9b, 0x0a, 
    0x65, 0x2a, 0x65, 0x59, 0xc6, 0xe4, 0x78, 0x19, 0x0f, 0x05, 0x1d, 0xae, 0x59, 0x96, 0x35, 0x4e, 0xba, 0xec, 0xde, 0xe4, 0xad, 0x17, 0x80, 0x6a, 0x91, 0xc4, 0x7a, 0x8f, 0x5a, 0xff, 0x2d, 0xd1, 
    0xfe, 0x96, 0x88, 0x2e, 0x73, 0x78, 0xd9, 0xfd, 0xbf, 0x8d, 0x7a, 0xec, 0xf8, 0xab, 0x69, 0x8e, 0x98, 0x0c, 0x5c, 0x52, 0x31, 0xfa, 0xbc, 0x5d, 0x61, 0x07, 0x8c, 0xca, 0x9b, 0x46, 0x1a, 0xb5, 
    0x73, 0x4f, 0x03, 0x12, 0x60, 0x09, 0x34, 0x56, 0x0e, 0xd0, 0xad, 0xc0, 0x1a, 0x97, 0xb5, 0xbd, 0x3a, 0x62, 0xf2, 0x72, 0xcd, 0x2f, 0x3d, 0x99, 0xd9, 0x3b, 0x7f, 0x82, 0x2e, 0x27, 0x07, 0xef, 
    0x3c, 0x51, 0x3e, 0xe1, 0x59, 0x24, 0xa5, 0xb6, 0xec, 0x56, 0x48, 0x8b, 0xf0, 0x92, 0x64, 0x04, 0xb7, 0x9a, 0x6e, 0x10, 0xdb, 0x0f, 0xcb, 0xdf, 0x97, 0xe6, 0x63, 0x7b, 0xb1, 0x23, 0xbe, 0xc7, 
    0x29, 0x26, 0xf2, 0xff, 0xe1, 0x5c, 0xf3, 0x91, 0xf5, 0x62, 0x49, 0x3c, 0xdf, 0x60, 0x36, 0x45, 0xc5, 0x42, 0xd1, 0x08, 0x17, 0x45, 0xcd, 0x96, 0xfe, 0x50, 0x79, 0x98, 0x03, 0xe4, 0xaf, 0xa3, 
    0xd6, 0x5b, 0x2a, 0x77, 0x57, 0xd2, 0xeb, 0x56, 0x7f, 0xf9, 0x43, 0x4d, 0xd1, 0x9c, 0xda, 0xac, 0x63, 0x27, 0xe9, 0x49, 0x7a, 0x79, 0xba, 0xfc, 0xb0, 0x52, 0x90, 0xec, 0xea, 0x3c, 0x62, 0x82, 
    0xab, 0x4e, 0xa0, 0x15, 0xbf, 0xef, 0xdc, 0x67, 0x4d, 0xda, 0x43, 0x44, 0x46, 0x35, 0x6b, 0xb6, 0x70, 0xed, 0xdf, 0x05, 0x12, 0xd4, 0x57, 0xbc, 0x87, 0x7a, 0x24, 0x73, 0x0c, 0x82, 0xb6, 0x51, 
    0x2d, 0xae, 0x7c, 0x48, 0xd3, 0x4f, 0x10, 0x82, 0xc0, 0xa7, 0xe6, 0xe5, 0xfb, 0x14, 0x97, 0xda, 0xd4, 0x2e, 0x52, 0x84, 0xe7, 0xbd, 0xa8, 0x08, 0x4d, 0x7b, 0x96, 0x66, 0x65, 0x14, 0xfa, 0xe4, 
    0xeb, 0xfd, 0x0e, 0xaf, 0xba, 0x0f, 0xb7, 0x42, 0x52, 0xc1, 0xa6, 0xea, 0x97, 0xdd, 0xce, 0x22, 0xdb, 0xd3, 0xec, 0x22, 0x07, 0x9f, 0x2a, 0x52, 0x42, 0x5a, 0xda, 0x26, 0x90, 0x07, 0x1e, 0x7a, 
    0x06, 0x6f, 0x52, 0xfc, 0x96, 0x0e, 0x76, 0xe9, 0xb6, 0x58, 0x1e, 0x4b, 0xee, 0x90, 0x13, 0x0f, 0xc5, 0xb3, 0x19, 0x6b, 0x23, 0x5a, 0x74, 0x02, 0x96, 0x6c, 0x8b, 0x4c, 0x2b, 0x02, 0xf2, 0x2e, 
    0xfb, 0x99, 0xab, 0x2b, 0x81, 0x30, 0xfa, 0x65, 0x0d, 0xca, 0x50, 0xe3, 0x32, 0x25, 0xc7, 0xdd, 0xa7, 0x81, 0xea, 0xc2, 0x78, 0x7c, 0x9c, 0x0d, 0x62, 0x34, 0x44, 0xfb, 0x17, 0x58, 0xb8, 0x5f, 
    0x55, 0x7d, 0x1b, 0x37, 0x52, 0x52, 0xfc, 0x70, 0xb3, 0xa6, 0x42, 0x2c, 0x74, 0x61, 0x87, 0xd7, 0x6c, 0x76, 0x32, 0xc9, 0xd5, 0x44, 0xaa, 0xf4, 0x2b, 0x2a, 0xf2, 0x3a, 0xe8, 0xfa, 0xde, 0x25, 
    0xb1, 0xc8, 0x2e, 0x15, 0x2a, 0x0d, 0xe8, 0xf3, 0x75, 0x4a, 0x02, 0x6a, 0xda, 0x7d, 0x12, 0x5b, 0x53, 0x73, 0x86, 0x5f, 0x12, 0x01, 0xa7, 0x51, 0x1f, 0x33, 0x3f, 0x88, 0x45, 0xb8, 0x99, 0xf8, 
    0xf4, 0x59, 0xbb, 0x9b, 0xba, 0xd6, 0xd5, 0x91, 0x4f, 0xbe, 0x27, 0xe1, 0xb0, 0x38, 0x14, 0x4b, 0xee, 0xe7, 0xaa, 0xf1, 0xdd, 0xd6, 0xcb, 0xa6, 0x99, 0x93, 0xf7, 0xb3, 0xd4, 0x35, 0x7a, 0x5f, 
    0x65, 0x3b, 0x5d, 0xff, 0x3d, 0x96, 0x33, 0xc2, 0x87, 0xed, 0xae, 0x8c, 0xb6, 0x39, 0xf8, 0xe0, 0x15, 0xc9, 0x49, 0xd7, 0x7f, 0x74, 0xeb, 0x81, 0x2b, 0x61, 0xb9, 0xde, 0x51, 0x03, 0x17, 0xc3, 
    0x31, 0xf1, 0x5c, 0x18, 0x78, 0x49, 0x5c, 0x18, 0xae, 0x95, 0xce, 0xe9, 0xb4, 0xf7, 0x85, 0x88, 0x82, 0xbd, 0xfa, 0x0f, 0xe1, 0xa2, 0xfd, 0x50, 0x02, 0x9c, 0x1a, 0x34, 0x87, 0x89, 0x4d, 0xd8, 
    0x99, 0x31, 0xab, 0x58, 0x3d, 0x35, 0x02, 0xd7, 0x10, 0xac, 0x13, 0x38, 0xae, 0xf1, 0x58, 0x00, 0xb5, 0xa8, 0x12, 0x5a, 0x91, 0x6e, 0x35, 0xd0, 0x5b, 0x0d, 0x5e, 0xa2, 0x1b, 0xbe, 0xae, 0xc8, 
    0x98, 0x8a, 0xb8, 0x0a, 0x33, 0x87, 0x06, 0xe0, 0xcc, 0xdd, 0xb4, 0xd2, 0xd2, 0xc3, 0x3b, 0xd3, 0x3d, 0x64, 0xc4, 0x07, 0x25, 0xde, 0x97, 0xa6, 0x56, 0x79, 0x0c, 0x01, 0xc7, 0x53, 0x6d, 0x5f, 
    0x94, 0x60, 0x64, 0xe2, 0x66, 0xa2, 0x06, 0xc8, 0xaf, 0x17, 0x96, 0xea, 0xb0, 0xdc, 0x1c, 0x16, 0x76, 0xed, 0x91, 0x90, 0x33, 0x4d, 0x2c, 0xaa, 0x2c, 0xc8, 0xe1, 0x55, 0x30, 0x27, 0x3d, 0xd4, 
    0x10, 0xc4, 0x3f, 0x0f, 0xfc, 0xac, 0x04, 0xbe, 0xaf, 0x5b, 0x24, 0xcc, 0xfd, 0x53, 0xee, 0xc1, 0x90, 0x23, 0x49, 0xe2, 0x6f, 0xa4, 0x80, 0x78, 0x28, 0xd9, 0x3e, 0xdd, 0x09, 0x93, 0x74, 0xaa, 
    0xed, 0xf3, 0x1a, 0x03, 0x22, 0x1e, 0x40, 0x83, 0x33, 0x1f, 0x86, 0x8c, 0xe4, 0x93, 0xf3, 0x6c, 0x9a, 0x88, 0xda, 0xd3, 0x81, 0x7a, 0xc9, 0xb6, 0x15, 0x4d, 0x27, 0x52, 0xa8, 0xa4, 0xef, 0x14, 
    0x9a, 0x87, 0xf3, 0x2c, 0x6a, 0x64, 0xad, 0x8e, 0x62, 0x33, 0x7e, 0xba, 0x1d, 0xda, 0xdd, 0x35, 0x40, 0x2b, 0xff, 0x2c, 0xfc, 0x8a, 0xba, 0x7f, 0xc3, 0x88, 0x0f, 0xbd, 0xb9, 0x0b, 0x32, 0x00, 
    0xe5, 0xa4, 0x4b, 0x8e, 0x58, 0xc8, 0x81, 0xa5, 0x81, 0x5c, 0xcb, 0xb2, 0x40, 0xa5, 0xbd, 0xff, 0x91, 0x23, 0xb8, 0x23, 0x03, 0xcf, 0x14, 0xa6, 0x7d, 0xba, 0x79, 0x06, 0x15, 0xdc, 0x63, 0x33, 
    0xb3, 0x96, 0x0d, 0x73, 0x69, 0x78, 0x27, 0x9c, 0x45, 0x16, 0x55, 0x69, 0x75, 0x62, 0x6e, 0x64, 0x96, 0x72, 0xfc, 0x26, 0x64, 0x88, 0x09, 0xb5, 0x74, 0x3a, 0xd2, 0x42, 0x7b, 0x1c, 0xc5, 0x00, 
    0x4d, 0x63, 0x37, 0xfc, 0x60, 0x51, 0x3c, 0xdd, 0xd6, 0x17, 0x2b, 0xeb, 0x00, 0x49, 0x15, 0xb1, 0xc2, 0x59, 0x6d, 0x36, 0x7f, 0x0d, 0x92, 0xa7, 0xd0, 0x51, 0xaf, 0xe6, 0xec, 0x5e, 0x87, 0x5c, 
    0x2a, 0xd3, 0x5d, 0x20, 0x30, 0x11, 0x1b, 0x4b, 0x22, 0xad, 0x5a, 0x97, 0xcc, 0x79, 0x60, 0x13, 0x59, 0x83, 0x23, 0xad, 0x5c, 0xec, 0xc0, 0x0e, 0xa5, 0x6c, 0xd4, 0xb0, 0xd3, 0x73, 0xf2, 0xde, 
    0xb9, 0x6d, 0x61, 0xd4, 0xb0, 0x7d, 0x12, 0xfe, 0xdb, 0xde, 0xfd, 0xc5, 0x52, 0x1d, 0x45, 0x87, 0x5d, 0x79, 0x15, 0xe3, 0xc5, 0xf1, 0x61, 0x2e, 0x40, 0xb0, 0xb6, 0x2a, 0xc7, 0x2d, 0x14, 0x38, 
    0x89, 0x76, 0x41, 0xa5, 0x97, 0xd9, 0x61, 0x68, 0xcf, 0x02, 0x84, 0x58, 0x05, 0xb7, 0xc7, 0xbe, 0xad, 0xf4, 0x8b, 0x64, 0x1d, 0xff, 0x1a, 0x1f, 0x33, 0x22, 0x3e, 0x3d, 0x03, 0xd7, 0x95, 0x54, 
    0xce, 0xfe, 0x27, 0x0f, 0x6a, 0xfc, 0x9b, 0x66, 0xe2, 0x94, 0x8b, 0xb2, 0x9d, 0xf6, 0xf2, 0x29, 0x49, 0x3f, 0x72, 0xa5, 0x34, 0xea, 0x41, 0xac, 0x22, 0x12, 0x83, 0xe2, 0xc5, 0xae, 0xcc, 0xb1, 
    0x68, 0xba, 0x9a, 0x1d, 0x32, 0x55, 0x03, 0x85, 0x5d, 0x32, 0x39, 0xb4, 0xf6, 0x4f, 0x98, 0xc9, 0xff, 0x22, 0x81, 0x5b, 0x17, 0xf5, 0xf6, 0x82, 0x64, 0x34, 0xfc, 0xe5, 0x76, 0x73, 0x8d, 0x8d, 
    0xea, 0xd3, 0x2c, 0xa0, 0x8c, 0x58, 0x9f, 0xf5, 0xc6, 0x11, 0xe5, 0xda, 0xff, 0x2c, 0x61, 0x3c, 0xa3, 0xbe, 0xd7, 0x49, 0x60, 0x49, 0x76, 0x89, 0xf6, 0x7b, 0x79, 0x77, 0x21, 0x4b, 0x1f, 0x25, 
    0xfd, 0x8c, 0x9a, 0x8f, 0x30, 0x6b, 0x04, 0x8d, 0xed, 0x74, 0x5c, 0xf7, 0x11, 0xb7, 0x76, 0x3e, 0x42, 0xdb, 0xfe, 0x97, 0xb8, 0x3c, 0x94, 0xc9, 0x81, 0x80, 0x8f, 0xb2, 0x9d, 0x0a, 0xe5, 0x87, 
    0x33, 0x47, 0x0b, 0x7a, 0xd3, 0xfa, 0x33, 0x12, 0xe9, 0x4a, 0x71, 0xbc, 0xa9, 0x9e, 0x14, 0xe8, 0x7d, 0x81, 0x15, 0xf7, 0xcc, 0x5e, 0xab, 0x12, 0x8d, 0xf8, 0xa1, 0x9f, 0x3d, 0x95, 0xe4, 0xbc, 
    0xa2, 0x1c, 0x08, 0x93, 0x74, 0xbf, 0xec, 0x70, 0x89, 0xe5, 0xc5, 0xdb, 0x07, 0xe4, 0xa1, 0xe7, 0x68, 0x8d, 0xdb, 0xcc, 0x2b, 0xa1, 0x93, 0x14, 0x88, 0x5a, 0xfa, 0x32, 0xe4, 0x07, 0x29, 0x43, 
    0xd3, 0x52, 0x0d, 0x00, 0x0e, 0x6e, 0x35, 0x6d, 0x68, 0xb0, 0x6f, 0x5f, 0x40, 0xe7, 0x20, 0x0f, 0x5f, 0x74, 0xee, 0x03, 0x3e, 0x70, 0xb9, 0x65, 0xa7, 0x89, 0xc1, 0x76, 0xba, 0xbc, 0x8b, 0xd5, 
    0xea, 0x80, 0x09, 0x4a, 0xf9, 0xc6, 0x44, 0x13, 0x47, 0x9d, 0x27, 0xbd, 0x0f, 0xfe, 0x5c, 0x59, 0x77, 0x36, 0x9a, 0x13, 0xb3, 0xec, 0x98, 0xc9, 0x3e, 0x39, 0xc5, 0xc1, 0xed, 0x6f, 0xee, 0x4d, 
    0xae, 0x9d, 0x08, 0x30, 0x81, 0x5c, 0xc1, 0xd8, 0x3a, 0x8f, 0x21, 0xc8, 0x68, 0x13, 0xf6, 0x65, 0x24, 0xe6, 0x2e, 0x1a, 0x5e, 0xab, 0xcd, 0x50, 0x0c, 0x88, 0x05, 0xe2, 0x76, 0x3f, 0x37, 0x64, 
    0x56, 0x6b, 0x8c, 0x44, 0xdc, 0x90, 0xa5, 0x6d, 0x81, 0x55, 0xba, 0x92, 0xfe, 0x8b, 0x74, 0x91, 0xba, 0xeb, 0x46, 0x3b, 0x88, 0xc5, 0xe4, 0xed, 0x0a, 0xb7, 0x06, 0xf8, 0x9f, 0xdf, 0x7b, 0x96, 
    0xb3, 0x4e, 0x6f, 0xd7, 0x94, 0x3f, 0x20, 0xa7, 0x39, 0xd9, 0x1c, 0x2b, 0xfa, 0x2b, 0xc0, 0x0e, 0xb0, 0x39, 0x1e, 0x70, 0xc1, 0x4d, 0x82, 0xe3, 0xa2, 0xcb, 0x97, 0x10, 0xc9, 0x8c, 0x40, 0x0f, 
    0x63, 0x26, 0xa7, 0xdf, 0x1b, 0xec, 0xae, 0x62, 0x9e, 0x5e, 0x9c, 0x05, 0x6c, 0xd1, 0xfd, 0xab, 0x7f, 0x6f, 0x81, 0xc9, 0x5e, 0xa2, 0xba, 0x61, 0x8f, 0x12, 0xb3, 0xa5, 0xb7, 0x76, 0xaf, 0x10, 
    0x34, 0x78, 0x43, 0xc3, 0xdf, 0x5b, 0xe2, 0x87, 0x6e, 0xad, 0x04, 0xf9, 0x40, 0x3b, 0xd6, 0x63, 0x0a, 0xb2, 0x9e, 0xd4, 0xdd, 0x33, 0x5f, 0x7e, 0xa8, 0xae, 0xa6, 0xed, 0x95, 0xa9, 0x0f, 0x81, 
    0x04, 0xdb, 0xb9, 0x82, 0x72, 0x88, 0x28, 0xde, 0x22, 0xac, 0x9f, 0xd2, 0xa0, 0x3c, 0x8b, 0xad, 0xdf, 0x61, 0x4a, 0x21, 0x64, 0x54, 0xb4, 0xfb, 0x98, 0x1c, 0x43, 0x26, 0xb4, 0x62, 0xae, 0x03, 
    0x78, 0x65, 0xc2, 0x7b, 0x79, 0x5b, 0xfc, 0xcc, 0x57, 0x68, 0xf2, 0x4b, 0xc7, 0x49, 0x32, 0xe8, 0xca, 0x94, 0xa7, 0x63, 0xd7, 0x98, 0x57, 0x3d, 0x97, 0xf2, 0x5d, 0xbd, 0x32, 0xa1, 0x32, 0x81, 
    0x42, 0x75, 0x46, 0x17, 0xbe, 0xf8, 0xaa, 0xe1, 0xc5, 0xea, 0x21, 0x76, 0x35, 0xcc, 0x5d, 0x1f, 0x55, 0xc5, 0xe5, 0x54, 0x6c, 0x54, 0xeb, 0x24, 0xc7, 0xc3, 0xb9, 0xdc, 0x12, 0x14, 0x7e, 0x06, 
    0x3a, 0xfc, 0x3d, 0x60, 0xa2, 0xd3, 0x19, 0x44, 0xa4, 0x67, 0x31, 0xf7, 0x50, 0x9d, 0x76, 0xf2, 0xd8, 0x5c, 0x6c, 0x31, 0xcf, 0xf3, 0xc4, 0xf8, 0x38, 0x5c, 0x78, 0x34, 0xc1, 0x7c, 0xd0, 0xe5, 
    0x41, 0xbf, 0xa7, 0x4b, 0xf0, 0x87, 0x63, 0xb9, 0xe4, 0x2f, 0x70, 0xc5, 0x65, 0xf3, 0xe1, 0x81, 0x5e, 0xb7, 0xf8, 0x17, 0x59, 0xf5, 0x75, 0x62, 0x12, 0x66, 0xcb, 0x3c, 0xb2, 0x85, 0x84, 0x88, 
    0x97, 0xb2, 0xe3, 0xb2, 0x20, 0xdf, 0x7c, 0xaa, 0x16, 0xde, 0x22, 0x1c, 0x4a, 0xa7, 0x8d, 0x32, 0x78, 0x58, 0xa7, 0xac, 0x13, 0x63, 0xe7, 0xa6, 0x34, 0xe1, 0x0d, 0xfc, 0xda, 0xf9, 0x55, 0xbb, 
    0xb3, 0xae, 0xd5, 0x8e, 0x5c, 0x3d, 0x47, 0x33, 0x67, 0x7b, 0x7b, 0x78, 0x52, 0xd0, 0x18, 0x7c, 0x6f, 0x1f, 0x5d, 0x45, 0xb4, 0xfd, 0x05, 0x03, 0x80, 0x3c, 0x6c, 0x1b, 0x33, 0x15, 0xd8, 0xaf, 
    0x05, 0x2f, 0xb0, 0x28, 0x74, 0x3e, 0x02, 0x6f, 0xe9, 0xdf, 0x0a, 0x27, 0x18, 0x92, 0x8e, 0x6d, 0x6d, 0xa3, 0x4d, 0x40, 0xea, 0x5f, 0xdf, 0xaa, 0xb6, 0xec, 0xf4, 0xec, 0xd5, 0xbe, 0x8a, 0x9b, 
    0x71, 0x3e, 0x6c, 0x9f, 0x5d, 0xc8, 0x74, 0x28, 0x8e, 0xcb, 0x77, 0xbe, 0xfe, 0x8e, 0x9a, 0xf2, 0x17, 0xa0, 0xa9, 0x04, 0xe2, 0x07, 0x9f, 0x7c, 0xbe, 0xb0, 0x9d, 0x0c, 0xcc, 0x55, 0xdc, 0xda, 
    0xea, 0x87, 0xfb, 0xf4, 0xe6, 0xc6, 0x9d, 0xd4, 0x89, 0xe6, 0xb1, 0x17, 0xea, 0xa8, 0x25, 0xc1, 0x04, 0x7b, 0x16, 0xd9, 0x3e, 0xa7, 0x5b, 0x1d, 0x6d, 0x4a, 0x2b, 0xcd, 0xfb, 0xa9, 0x3b, 0x9e, 
    0x86, 0xc3, 0x3b, 0xf9, 0x2f, 0xa0, 0x52, 0x24, 0xe6, 0x7c, 0x20, 0xbf, 0x9a, 0x59, 0xa3, 0xb7, 0xd0, 0xb8, 0xbb, 0xe7, 0x9e, 0x40, 0x77, 0xe5, 0x68, 0xca, 0x6f, 0x12, 0x34, 0x8d, 0xa6, 0x3a, 
    0xeb, 0x03, 0x34, 0xdc, 0xa5, 0x27, 0xd6, 0x59, 0x64, 0xfb, 0x00, 0x9b, 0x0b, 0x57, 0xe8, 0x02, 0x8e, 0x37, 0x7f, 0xd2, 0x4e, 0x3a, 0xd2, 0xae, 0xe9, 0x11, 0x1d, 0x6e, 0x4f, 0xc8, 0xa1, 0xa9, 
    0x1a, 0x20, 0xdd, 0xc5
};


static const BYTE g_XmsskeySha2_16_256[] = {
    0x00, 0x00, 0x00, 0x02, 0x88, 0xc1, 0x68, 0x51, 0x99, 0xd5, 0x3a, 0xe9, 0xfe, 0xf5, 0xb5, 0xe6,
    0x6b, 0xe1, 0xf1, 0x6f, 0xa6, 0x6b, 0x17, 0x17, 0x07, 0x48, 0xc6, 0x32, 0x53, 0x38, 0x58, 0x4d,
    0x60, 0xf0, 0x68, 0xf0, 0x48, 0xfa, 0xb0, 0x98, 0xbe, 0x99, 0x15, 0xff, 0xdd, 0x2d, 0x39, 0x7c,
    0x07, 0x3c, 0xda, 0x29, 0x03, 0x8f, 0x12, 0x1f, 0x51, 0x13, 0x6c, 0xa9, 0x22, 0x22, 0x91, 0x5e,
    0xb3, 0x9a, 0x27, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x7e, 0x0c, 0xc8, 0xad,
    0x83, 0xe5, 0x66, 0x84, 0xb4, 0xa5, 0xa6, 0x5b, 0xf4, 0xcc, 0x11, 0xea, 0xb1, 0x23, 0x22, 0x33,
    0x67, 0x81, 0x99, 0x81, 0x4f, 0x09, 0x94, 0xec, 0x43, 0xd9, 0xaa, 0x02, 0x65, 0x4b, 0x0c, 0x52,
    0x93, 0x72, 0x19, 0xd4, 0xe0, 0x82, 0x7f, 0xd4, 0x77, 0xd1, 0xbb, 0xf1, 0x37, 0x59, 0x97, 0x85,
    0x93, 0xf3, 0xed, 0xc8, 0x2f, 0xb8, 0xcd, 0xd8, 0xfc, 0x6e, 0x63, 0x6a
};

static const BYTE g_XmssSigSha2_16_256[] = {
    0x00, 0x00, 0x00, 0x01, 0xd3, 0x10, 0xec, 0xa7, 0x81, 0x3d, 0x18, 0x40, 0x98, 0xef, 0x8d, 0xf2, 0xe7, 0x02, 0x67, 0x3e, 0xcb, 0x05, 0x96, 0xa5, 0x29, 0x7a, 0x98, 0xc6, 0xa9, 0x92, 0xd1, 0xd3, 
    0x9e, 0x06, 0xd2, 0xc1, 0x6c, 0x43, 0x26, 0x01, 0x40, 0xbb, 0xee, 0xad, 0x6e, 0x85, 0x23, 0x5e, 0x94, 0x53, 0x2c, 0x24, 0xdc, 0x7e, 0xe1, 0x63, 0xb1, 0xea, 0xd5, 0x5c, 0x52, 0x5e, 0xd5, 0x40, 
    0xa6, 0x23, 0xed, 0xe4, 0x8d, 0x56, 0xc5, 0xf0, 0xb0, 0x09, 0x62, 0x6b, 0x39, 0x29, 0x50, 0x14, 0x4f, 0x84, 0x11, 0x6b, 0xe8, 0x7d, 0xe2, 0xd7, 0x62, 0x1e, 0xb9, 0x5c, 0x75, 0x50, 0xef, 0xef, 
    0xb4, 0xa3, 0x1c, 0x5a, 0x5f, 0x9c, 0xdf, 0x13, 0x8d, 0xa3, 0x9f, 0xfe, 0x83, 0xf2, 0xa6, 0x21, 0xbe, 0x4b, 0x0a, 0x1e, 0x0e, 0x73, 0xff, 0x7a, 0xd1, 0x1f, 0xf0, 0xe3, 0x1d, 0x4a, 0x02, 0xa4, 
    0x03, 0x29, 0x94, 0xdf, 0xe9, 0x30, 0x72, 0x24, 0xd4, 0x77, 0x70, 0x86, 0xff, 0xcd, 0xa7, 0xf9, 0xd9, 0x92, 0x49, 0xe8, 0xf0, 0x40, 0xc6, 0x03, 0xf4, 0xb8, 0xcc, 0x86, 0x86, 0x38, 0xfa, 0x0e, 
    0x26, 0xb6, 0x15, 0xf5, 0xb4, 0xb7, 0x51, 0xf9, 0x30, 0x33, 0x8b, 0x4f, 0x2e, 0xb6, 0xc2, 0xf8, 0x36, 0x97, 0xcf, 0xb3, 0x67, 0xce, 0x4f, 0xd3, 0x6d, 0x90, 0xda, 0x80, 0x7a, 0xfe, 0x6c, 0xf7, 
    0x5d, 0xf1, 0x1f, 0x59, 0x9f, 0x65, 0x53, 0x25, 0x11, 0x0a, 0x7a, 0xb2, 0x40, 0x49, 0xf2, 0xe3, 0x56, 0x97, 0x30, 0x31, 0x8c, 0xd9, 0x87, 0x6f, 0x22, 0x06, 0x7b, 0x9f, 0xc6, 0xb0, 0x62, 0x81, 
    0xa0, 0xd9, 0x23, 0x0b, 0x45, 0x42, 0xe7, 0x6d, 0xf8, 0xfe, 0xa5, 0x0c, 0x10, 0x39, 0xa6, 0x53, 0xee, 0x09, 0x2e, 0xf8, 0x06, 0x54, 0xd5, 0xf8, 0xbf, 0x0c, 0xc9, 0x1e, 0x2d, 0x96, 0x18, 0x37, 
    0x4f, 0xf2, 0xa3, 0x2d, 0x46, 0xb8, 0x79, 0x45, 0x91, 0x77, 0xb8, 0xe3, 0x18, 0x6a, 0x73, 0x19, 0x97, 0x3d, 0x75, 0x6b, 0x64, 0xb2, 0x72, 0x97, 0x61, 0x48, 0x4d, 0xec, 0xa4, 0x76, 0x69, 0xf5, 
    0x0d, 0x46, 0x32, 0xf9, 0x52, 0x94, 0xc6, 0x24, 0x88, 0xbb, 0x54, 0x45, 0x8c, 0xd6, 0x74, 0x2d, 0x49, 0xc9, 0x75, 0x11, 0xb6, 0x4e, 0xfb, 0xe7, 0x37, 0xed, 0x00, 0x24, 0x00, 0xd6, 0xda, 0x35, 
    0xbc, 0x9c, 0xe2, 0x64, 0xdb, 0xab, 0xa5, 0xc8, 0xf6, 0x30, 0xdd, 0xf1, 0xbb, 0x85, 0x67, 0xc7, 0xb6, 0x0f, 0x29, 0xd7, 0x01, 0xc8, 0x9b, 0x8d, 0x3f, 0x6f, 0x50, 0xa4, 0xb2, 0x54, 0x73, 0x46, 
    0x99, 0x1c, 0x94, 0xf9, 0xe8, 0x75, 0xaa, 0xd7, 0x4a, 0xd1, 0x71, 0xdd, 0x77, 0x90, 0xab, 0xae, 0xfb, 0x5b, 0x4c, 0xba, 0x72, 0x21, 0x07, 0x01, 0xea, 0xeb, 0x37, 0x3f, 0x3e, 0x1c, 0x23, 0x53, 
    0xe6, 0x11, 0x09, 0x38, 0x15, 0x11, 0xe7, 0xea, 0x29, 0x02, 0x41, 0xe9, 0x7f, 0x31, 0xae, 0x4e, 0x62, 0xa8, 0xf7, 0x82, 0xfc, 0x20, 0xbb, 0xcf, 0x1c, 0xbf, 0xae, 0xd5, 0x2b, 0xf0, 0x7c, 0xdf, 
    0x03, 0x6e, 0x1c, 0xec, 0x2d, 0x19, 0x5b, 0x07, 0xd0, 0xca, 0x90, 0xf6, 0x1e, 0x32, 0x44, 0x37, 0x8c, 0x55, 0x61, 0xc8, 0x75, 0x45, 0x8d, 0x28, 0x04, 0x80, 0x38, 0xae, 0x81, 0x35, 0x18, 0xa6, 
    0xbf, 0xab, 0xed, 0xb0, 0xfa, 0xad, 0x21, 0x87, 0x8b, 0x62, 0x82, 0x14, 0x10, 0x78, 0x79, 0xfc, 0x18, 0x17, 0x35, 0x42, 0x91, 0xbd, 0x92, 0x14, 0xb4, 0x32, 0xf3, 0xd5, 0x0a, 0xc2, 0x46, 0xba, 
    0x97, 0x23, 0x8e, 0xcc, 0x8d, 0xcc, 0x42, 0xae, 0x17, 0x74, 0x40, 0x67, 0xa6, 0x55, 0x2b, 0xc5, 0x80, 0x11, 0x6c, 0x44, 0xb1, 0x66, 0xc2, 0x2e, 0x6a, 0x20, 0xae, 0x67, 0x29, 0x64, 0xff, 0x36, 
    0x7e, 0x5c, 0xfd, 0xfc, 0xfd, 0xae, 0x6a, 0x7d, 0xe3, 0x08, 0x34, 0xa9, 0xc5, 0xca, 0xe4, 0x29, 0x60, 0xf5, 0x03, 0xf3, 0x3a, 0x3d, 0xbf, 0x22, 0x55, 0xb9, 0xc5, 0xf7, 0x97, 0x6b, 0xc9, 0x49, 
    0x50, 0x7d, 0xa6, 0x36, 0x70, 0x12, 0x83, 0x69, 0x87, 0xaf, 0xad, 0x9e, 0x1d, 0x48, 0x25, 0x6e, 0x81, 0x8f, 0xeb, 0x9f, 0xee, 0xc6, 0xb9, 0xd0, 0xa7, 0x24, 0xce, 0xec, 0x0a, 0x61, 0x82, 0xa1, 
    0x4b, 0x7f, 0xa8, 0xbd, 0xd5, 0x8d, 0x98, 0xc5, 0xef, 0x1a, 0xec, 0xe5, 0x1f, 0x64, 0x23, 0xcb, 0x62, 0x03, 0xdb, 0x76, 0xe3, 0x57, 0x40, 0x1e, 0x3c, 0x1f, 0x22, 0xae, 0x9f, 0xf8, 0x9f, 0x43, 
    0x86, 0x7a, 0xef, 0x27, 0x3b, 0x61, 0xee, 0xec, 0x05, 0x1f, 0xfe, 0x24, 0xeb, 0x61, 0x4b, 0x2e, 0x86, 0x9f, 0xc4, 0xe1, 0x33, 0xaf, 0x56, 0x32, 0xf0, 0x4a, 0xd4, 0xc5, 0xd5, 0xf9, 0xcc, 0xb4, 
    0x74, 0x1f, 0x58, 0x24, 0xe1, 0xe2, 0x12, 0x0a, 0x32, 0xff, 0x93, 0xe3, 0x65, 0xe9, 0xa8, 0x70, 0x7f, 0x9c, 0x2a, 0x6b, 0x25, 0x4a, 0x64, 0x10, 0x6e, 0x83, 0x5d, 0x04, 0x89, 0x61, 0xe0, 0x54, 
    0x9c, 0x5e, 0xd2, 0x63, 0x95, 0xd7, 0xec, 0xa9, 0x69, 0xce, 0x24, 0xe1, 0x8e, 0x89, 0xab, 0x9b, 0x24, 0xcf, 0x4f, 0xd7, 0xe5, 0x4e, 0x80, 0x8e, 0x6c, 0x78, 0xdc, 0xa5, 0x63, 0xd7, 0x70, 0xa3, 
    0xc1, 0xd1, 0x5c, 0x26, 0x59, 0x89, 0x0e, 0x5f, 0x38, 0x6a, 0x77, 0xbc, 0x70, 0xe2, 0x70, 0xb9, 0x99, 0x3b, 0x72, 0xa0, 0xa4, 0xda, 0xbf, 0xdf, 0xb3, 0x18, 0x89, 0xfa, 0x1d, 0xbf, 0x77, 0xcf, 
    0xa2, 0xba, 0xfb, 0xcc, 0x1e, 0xef, 0xd9, 0x8b, 0x64, 0x5d, 0x3b, 0x73, 0x31, 0x52, 0x5b, 0x96, 0xca, 0x9b, 0xca, 0x58, 0xff, 0x41, 0xc2, 0x8d, 0xbd, 0xa4, 0x5d, 0xaa, 0xbd, 0x4c, 0x78, 0xbe, 
    0x9f, 0x3c, 0xdc, 0x22, 0xcd, 0x97, 0x6e, 0xea, 0x36, 0x47, 0x63, 0xa5, 0xfb, 0xaa, 0x39, 0x7e, 0xcf, 0x24, 0x04, 0x51, 0x48, 0x03, 0xb9, 0xbd, 0x39, 0x37, 0x15, 0x5f, 0xa6, 0x4e, 0x54, 0x7b, 
    0xe3, 0x2f, 0x58, 0x21, 0xbd, 0x33, 0xdb, 0xd3, 0x04, 0x86, 0x17, 0x61, 0x0b, 0x18, 0x5c, 0x7f, 0x07, 0x12, 0x13, 0xd4, 0xea, 0x3b, 0x53, 0xee, 0xf7, 0xd2, 0xd3, 0x75, 0xfb, 0xdd, 0x02, 0xe1, 
    0xc4, 0x38, 0x25, 0xdb, 0x46, 0xe3, 0x05, 0x80, 0x03, 0x3a, 0x48, 0x9d, 0x42, 0x23, 0xd2, 0x4d, 0xe3, 0x27, 0x63, 0xee, 0xc7, 0xad, 0x1f, 0x1f, 0x25, 0xf9, 0x21, 0xf9, 0x3b, 0x37, 0xc0, 0x41, 
    0x9f, 0xe2, 0xe0, 0x13, 0xe6, 0x01, 0xdb, 0x08, 0xe5, 0x64, 0x36, 0xfd, 0x81, 0x78, 0x09, 0xe2, 0xea, 0x0e, 0x29, 0x09, 0x14, 0x8a, 0x6d, 0x1e, 0xfb, 0x59, 0xc0, 0xe9, 0x60, 0x6e, 0x18, 0x2e, 
    0xb8, 0x38, 0x1f, 0x70, 0xde, 0xb8, 0x1c, 0x3a, 0xd3, 0x05, 0xd2, 0xb3, 0x6f, 0x0c, 0xd2, 0x0e, 0x9c, 0x3a, 0x93, 0xa0, 0x6f, 0x94, 0x72, 0x94, 0x0b, 0xd3, 0x5e, 0x85, 0xe8, 0x05, 0xa6, 0xda, 
    0x7d, 0xef, 0x7a, 0xf6, 0x51, 0x99, 0xde, 0xde, 0xb1, 0x9d, 0xfa, 0x4d, 0x35, 0x48, 0x1a, 0xe8, 0xe1, 0xef, 0xd4, 0xbb, 0x2a, 0x17, 0x50, 0xdf, 0x25, 0x3c, 0xdc, 0x99, 0x33, 0xc2, 0xce, 0xeb, 
    0x0a, 0xb5, 0x4a, 0x2f, 0xa9, 0xb9, 0x83, 0x2c, 0x26, 0xae, 0x4d, 0x8b, 0xe0, 0x4e, 0x22, 0xb1, 0xb3, 0xf3, 0x4d, 0x5a, 0x82, 0xeb, 0x61, 0x17, 0x0a, 0xd5, 0xfd, 0x45, 0xca, 0xcf, 0x5a, 0xcd, 
    0xd1, 0xc2, 0xd0, 0x5a, 0x46, 0x8b, 0xcb, 0x1f, 0x3a, 0xc2, 0x6b, 0x1b, 0x3b, 0xaa, 0xd4, 0x93, 0x69, 0xce, 0xfb, 0x6e, 0x73, 0xab, 0xba, 0x56, 0x0e, 0x68, 0x0e, 0xd2, 0xbd, 0x7f, 0xf6, 0x45, 
    0x18, 0x74, 0x65, 0x82, 0x7e, 0x7b, 0x81, 0xfe, 0xab, 0x7d, 0xc8, 0x9e, 0xca, 0x86, 0xfc, 0x3a, 0xad, 0x6b, 0x7e, 0xb6, 0x1d, 0xb1, 0xdf, 0xb7, 0xd9, 0x48, 0xf9, 0x64, 0x84, 0xc0, 0xbc, 0xc7, 
    0x98, 0xa9, 0x07, 0xcd, 0x23, 0xdd, 0x93, 0x9a, 0x10, 0x49, 0x31, 0xdf, 0x0b, 0xcc, 0xac, 0x14, 0x9b, 0x87, 0xe8, 0xc7, 0xc8, 0x79, 0x49, 0x0c, 0x8c, 0xe0, 0x68, 0xa4, 0x61, 0x11, 0x23, 0xc1, 
    0x8c, 0xe4, 0x79, 0xe2, 0xaf, 0xd7, 0x19, 0xd2, 0xab, 0x03, 0x61, 0xe2, 0xae, 0x8a, 0xad, 0xf4, 0x14, 0xa7, 0xcd, 0x6c, 0xa7, 0x05, 0x03, 0x76, 0x19, 0x87, 0x6c, 0x99, 0xdb, 0xc2, 0xf0, 0x2d, 
    0x87, 0x35, 0x0f, 0x3a, 0x77, 0x79, 0x48, 0xd0, 0x05, 0x03, 0x64, 0x51, 0x54, 0x38, 0xec, 0xe8, 0x28, 0x5a, 0xfa, 0x3b, 0xd5, 0xb0, 0xb4, 0x2f, 0x09, 0xd8, 0x95, 0x66, 0xa3, 0xd3, 0xe3, 0x67, 
    0xf0, 0x42, 0x3e, 0xde, 0x3f, 0x86, 0x75, 0xc1, 0x6d, 0xfa, 0xe1, 0xa6, 0x62, 0x67, 0x6c, 0x71, 0xe4, 0x58, 0x7d, 0x4b, 0xba, 0xbc, 0xb6, 0xe5, 0xcd, 0xaa, 0xce, 0xbe, 0xae, 0xd0, 0xcd, 0x75, 
    0xad, 0xa2, 0x55, 0x90, 0x8c, 0x34, 0xa5, 0x10, 0x5d, 0x43, 0x7d, 0xd3, 0xaf, 0x0e, 0x18, 0x1f, 0xee, 0x6a, 0x18, 0xa6, 0xe2, 0x4c, 0x16, 0x71, 0x98, 0x14, 0x4d, 0x3c, 0xf8, 0xcf, 0x60, 0x37, 
    0x82, 0xd5, 0x11, 0xfe, 0x06, 0xc4, 0xf9, 0x9e, 0x39, 0xda, 0xef, 0xa9, 0x46, 0x73, 0x0f, 0x8e, 0x31, 0x9d, 0xed, 0x39, 0x06, 0x42, 0x22, 0x1e, 0x1b, 0xc1, 0xc4, 0x4b, 0xc3, 0x3e, 0x78, 0xd2, 
    0xb5, 0xc0, 0xff, 0x13, 0xfa, 0x92, 0xe7, 0x58, 0xb5, 0xd5, 0x86, 0xf0, 0x0e, 0x0c, 0x3e, 0x4d, 0x02, 0x19, 0xad, 0x2b, 0xf9, 0xf5, 0x3d, 0x10, 0x70, 0x18, 0x9c, 0x47, 0x60, 0xc6, 0x62, 0x1f, 
    0x43, 0xf4, 0x93, 0xa7, 0x25, 0xb9, 0xae, 0xde, 0xe7, 0x3d, 0x0f, 0x0d, 0xc6, 0xc9, 0xa8, 0xac, 0x60, 0xe0, 0x48, 0x55, 0x74, 0xaf, 0xce, 0x95, 0x54, 0xa9, 0x9d, 0x3f, 0x73, 0x33, 0x5b, 0x82, 
    0x06, 0x9e, 0x93, 0xd7, 0x7d, 0x15, 0x93, 0x1b, 0x49, 0x3f, 0xf5, 0x02, 0xdb, 0x91, 0xd3, 0x45, 0x8f, 0xcf, 0x4f, 0x52, 0xb3, 0xcf, 0xdc, 0x1e, 0x32, 0x88, 0x29, 0x99, 0x24, 0x7c, 0xb0, 0x0d, 
    0x6a, 0x6a, 0xc5, 0xe6, 0x39, 0x60, 0x33, 0xb9, 0x2b, 0x86, 0xae, 0x76, 0x76, 0xf8, 0x56, 0xe4, 0x51, 0x1f, 0x81, 0xea, 0x5c, 0x40, 0x02, 0xe4, 0x00, 0x1a, 0x55, 0x12, 0xbe, 0x53, 0xa6, 0x57, 
    0x44, 0xfa, 0x55, 0xc9, 0xaa, 0xa8, 0xf8, 0x95, 0x60, 0xc2, 0xaa, 0xae, 0x3b, 0x59, 0x9a, 0x8e, 0xf4, 0x35, 0xd6, 0x62, 0x04, 0xd9, 0x77, 0xc7, 0x3d, 0x30, 0x57, 0x6d, 0x01, 0xcd, 0xb0, 0x66, 
    0x57, 0x2a, 0xac, 0xeb, 0xd8, 0xf0, 0x1d, 0x8a, 0x63, 0x5f, 0x51, 0x78, 0xff, 0x5c, 0x39, 0x34, 0x3c, 0x16, 0x0d, 0x12, 0x78, 0x15, 0xbc, 0x1d, 0xe8, 0xa1, 0x5e, 0xac, 0x8e, 0x4d, 0x09, 0x46, 
    0x2a, 0x60, 0x6d, 0xf8, 0x82, 0x7b, 0xc5, 0x2a, 0x0f, 0x88, 0xdd, 0xd9, 0x96, 0x39, 0x19, 0x22, 0x82, 0x62, 0xd4, 0x23, 0x1a, 0x11, 0xb3, 0xc0, 0xe0, 0xa3, 0x7b, 0x43, 0x4c, 0xaf, 0x9e, 0xdc, 
    0xc3, 0x6a, 0xc9, 0x85, 0x0f, 0x6f, 0xdb, 0x67, 0x2e, 0xb2, 0x58, 0xa3, 0x22, 0xba, 0x1e, 0xf5, 0x14, 0x1f, 0x1c, 0x54, 0xc9, 0x22, 0x4f, 0x61, 0x84, 0xe4, 0xda, 0xc3, 0xc5, 0xcb, 0x41, 0x8d, 
    0xfe, 0xe9, 0xf4, 0x3c, 0x02, 0xc6, 0xc2, 0x18, 0x2a, 0xc9, 0x91, 0x9c, 0xbe, 0x2d, 0xff, 0x20, 0x5f, 0x97, 0xae, 0x6f, 0xad, 0xd2, 0x04, 0xaa, 0x59, 0x98, 0x4e, 0x22, 0x5c, 0xe6, 0xdb, 0xb5, 
    0x6a, 0xfb, 0x17, 0x15, 0x12, 0x3e, 0x7e, 0x16, 0x61, 0x4c, 0x57, 0x61, 0xf1, 0xce, 0x58, 0x0d, 0x02, 0xfb, 0xf7, 0x69, 0xb9, 0xf9, 0xc0, 0x64, 0x3f, 0xe0, 0xd8, 0x31, 0x76, 0xe5, 0x52, 0xab, 
    0xf4, 0x33, 0xf5, 0xca, 0x87, 0x3b, 0xb6, 0x2f, 0xa8, 0xe2, 0xec, 0x5b, 0xea, 0x9a, 0x34, 0x5b, 0x23, 0x81, 0x64, 0xb4, 0x74, 0xbc, 0xc0, 0x71, 0x1e, 0xe7, 0xb2, 0x83, 0x3e, 0x5f, 0x12, 0x19, 
    0xe6, 0x8b, 0xc2, 0xd5, 0x39, 0xf1, 0x12, 0xf6, 0x26, 0xa1, 0x8c, 0x06, 0xbc, 0xf6, 0xf9, 0x4e, 0x12, 0x6b, 0x29, 0x7e, 0xd0, 0xc8, 0x23, 0x94, 0xf1, 0xa2, 0x54, 0xb4, 0x06, 0xe2, 0x30, 0xc0, 
    0x6c, 0x55, 0xa7, 0x16, 0x53, 0xb3, 0x51, 0xcd, 0x6e, 0x65, 0x55, 0x6a, 0xc5, 0xca, 0xfd, 0xc7, 0x07, 0x87, 0xcb, 0x07, 0xd1, 0xd4, 0x05, 0xd9, 0x31, 0x25, 0x4c, 0xc2, 0x07, 0x9a, 0x66, 0xae, 
    0x07, 0x49, 0xe0, 0x70, 0xbd, 0x97, 0x2f, 0xdb, 0x2c, 0xae, 0x42, 0xe1, 0xb2, 0xbf, 0x29, 0xe1, 0xbf, 0x10, 0xb1, 0xe4, 0xeb, 0xa7, 0x45, 0x56, 0xed, 0x3c, 0x08, 0x24, 0x1c, 0x81, 0x4d, 0xa8, 
    0x5e, 0xc6, 0x58, 0x79, 0xdf, 0x69, 0x69, 0xb2, 0x5f, 0xc6, 0x03, 0x5c, 0x78, 0xa5, 0x86, 0x24, 0xf8, 0x05, 0xd3, 0xc4, 0xa6, 0xe0, 0x7c, 0xb0, 0x11, 0xfb, 0xd0, 0x2f, 0xe5, 0x61, 0x12, 0xb3, 
    0x7a, 0xe4, 0x0f, 0xd5, 0xb2, 0x2d, 0xf3, 0xbc, 0xe1, 0x52, 0x36, 0x83, 0x91, 0x5d, 0xbb, 0xb3, 0xd9, 0x5d, 0x34, 0x1d, 0xf6, 0xf6, 0xe6, 0x49, 0xca, 0xce, 0xb4, 0xf2, 0x02, 0x28, 0x0d, 0x8c, 
    0x0c, 0x0a, 0x64, 0xae, 0x0a, 0x19, 0x5a, 0x56, 0x1c, 0xc2, 0x25, 0x52, 0xf1, 0x82, 0x8b, 0xc2, 0x98, 0x5c, 0x9b, 0xc0, 0xa2, 0x58, 0x83, 0x0d, 0x3b, 0x1d, 0x00, 0x3c, 0x47, 0x30, 0xae, 0x34, 
    0x93, 0xfd, 0x5c, 0x0b, 0xbb, 0x6f, 0xd6, 0x52, 0x20, 0x48, 0x8a, 0xe0, 0x34, 0x56, 0xb7, 0x54, 0xb7, 0x7f, 0x86, 0xe4, 0xb3, 0x8b, 0x24, 0x46, 0x63, 0x59, 0x91, 0x8b, 0xc0, 0xdb, 0x25, 0xe6, 
    0xa3, 0x44, 0x4a, 0xbc, 0xb6, 0x3b, 0xd6, 0x5d, 0x5c, 0x6a, 0x9f, 0x6f, 0xd7, 0x5c, 0xd4, 0xd9, 0xe2, 0xeb, 0xb8, 0x65, 0xb0, 0xb2, 0xdd, 0x2d, 0xe3, 0x05, 0x48, 0xf7, 0x55, 0x1e, 0x30, 0x4e, 
    0x5f, 0xf9, 0xb9, 0x36, 0x97, 0x5b, 0x30, 0x47, 0x8c, 0x56, 0x15, 0xc5, 0x92, 0x44, 0x4f, 0x81, 0xa4, 0x2a, 0x1f, 0xdd, 0x63, 0xf0, 0xba, 0x66, 0x46, 0xee, 0x41, 0xf9, 0xa9, 0xae, 0x58, 0xe9, 
    0x60, 0x9f, 0xb0, 0xfb, 0x2c, 0x2c, 0x74, 0xd1, 0x24, 0x55, 0x31, 0x56, 0x74, 0x36, 0x8e, 0x00, 0xca, 0x73, 0x2e, 0x47, 0x61, 0xe3, 0xbf, 0xbe, 0x06, 0xe8, 0x86, 0xe8, 0x0a, 0x4d, 0x39, 0xac, 
    0x43, 0xe4, 0xb4, 0xc9, 0x75, 0x92, 0x78, 0xd4, 0xa1, 0xb8, 0x61, 0x82, 0xad, 0x2c, 0x85, 0x90, 0x2a, 0xef, 0xba, 0x5f, 0x62, 0xe9, 0x85, 0xaf, 0x2f, 0xd1, 0x44, 0xda, 0xe2, 0x0a, 0x09, 0x71, 
    0x16, 0x63, 0xe6, 0x6e, 0xa7, 0xf7, 0x97, 0xc2, 0x2e, 0xb2, 0x95, 0x14, 0x0b, 0xfc, 0xb1, 0x5f, 0x52, 0xaa, 0x4f, 0x62, 0x6b, 0xa6, 0xdc, 0x87, 0x31, 0x74, 0x3f, 0xbc, 0x39, 0x4b, 0xe1, 0xa0, 
    0x02, 0xe2, 0xad, 0x52, 0x79, 0x73, 0x02, 0xd3, 0x64, 0xcc, 0x3a, 0x84, 0x16, 0xed, 0xc7, 0x9f, 0x80, 0xf4, 0xb8, 0x04, 0x70, 0x98, 0xfc, 0xda, 0x09, 0xe6, 0x27, 0xaa, 0xd6, 0xd2, 0x8a, 0x0a, 
    0xde, 0xe8, 0xca, 0x39, 0x29, 0x2a, 0xd9, 0x9e, 0x7c, 0x2b, 0xa7, 0xa4, 0x40, 0x08, 0x17, 0xa0, 0x55, 0x38, 0x33, 0xa7, 0xcd, 0x53, 0x63, 0x78, 0x30, 0xe5, 0x6d, 0x52, 0xc4, 0x40, 0x9c, 0xeb, 
    0xa9, 0x2a, 0x9f, 0x6a, 0x4d, 0xbc, 0xc0, 0xe9, 0x5c, 0x11, 0xf6, 0x67, 0xc0, 0x22, 0xd0, 0x93, 0x7f, 0x42, 0xbe, 0x5e, 0x4c, 0x05, 0xb7, 0xf8, 0xd3, 0xff, 0x84, 0xf4, 0x1e, 0xd2, 0x6e, 0xff, 
    0xa6, 0x40, 0x6a, 0x36, 0x7b, 0xfe, 0x04, 0x9a, 0xaf, 0x6a, 0x19, 0xbd, 0xaa, 0xcc, 0x27, 0xee, 0x77, 0xa4, 0x78, 0xf7, 0x03, 0x9a, 0xb9, 0x20, 0x12, 0x97, 0xc3, 0xa6, 0xe3, 0x9c, 0x5d, 0x73, 
    0xc1, 0x19, 0xf7, 0xd6, 0x5c, 0xa8, 0x4a, 0xb8, 0x32, 0x93, 0x77, 0xe3, 0x2e, 0x63, 0x46, 0x2a, 0xd0, 0x7d, 0x5e, 0x44, 0x5f, 0x3f, 0xf1, 0x9c, 0xcf, 0xb2, 0xd6, 0x95, 0x36, 0xaa, 0x52, 0x90, 
    0x56, 0x72, 0x3f, 0xb6, 0x4e, 0x5b, 0xbb, 0x39, 0x00, 0x69, 0x71, 0x4e, 0x63, 0x18, 0x9e, 0x96, 0x34, 0xba, 0x6c, 0xfd, 0x3b, 0xaa, 0x65, 0x8d, 0x07, 0xe2, 0xa4, 0x18, 0x26, 0xc2, 0x82, 0xb2, 
    0x14, 0xf6, 0x5f, 0x52, 0x1c, 0xe0, 0x2a, 0xc1, 0xda, 0x6f, 0x76, 0xc5, 0x0c, 0xa9, 0x38, 0x74, 0xf1, 0x39, 0xb7, 0x9c, 0x96, 0x1e, 0x94, 0xfd, 0x82, 0x72, 0x29, 0xd5, 0xde, 0xe5, 0x90, 0x7d, 
    0xf1, 0xc1, 0x4a, 0x38, 0x01, 0xb9, 0x76, 0x3c, 0x67, 0x83, 0x01, 0x23, 0xea, 0xb5, 0xb1, 0x90, 0xb1, 0x68, 0x76, 0xff, 0x4c, 0x08, 0x21, 0xfd, 0x75, 0x46, 0x23, 0x66, 0x89, 0xc3, 0x4d, 0xce, 
    0x2a, 0x42, 0x1a, 0x34, 0x08, 0xf5, 0xb3, 0x51, 0xd2, 0x34, 0x48, 0x44, 0x75, 0x97, 0xf2, 0x28, 0x34, 0x92, 0x37, 0x0c, 0x32, 0x46, 0x28, 0x67, 0x35, 0x8f, 0x07, 0xf0, 0xc9, 0x12, 0x1e, 0xd1, 
    0x12, 0x45, 0xb2, 0x47, 0xed, 0xde, 0x59, 0x5d, 0xa8, 0x6e, 0x80, 0x2a, 0x5f, 0xb2, 0x44, 0xc3, 0x7f, 0xd9, 0xa8, 0x15, 0x07, 0xff, 0xf1, 0x2f, 0x3c, 0x40, 0xe6, 0x7b, 0xf5, 0xee, 0xab, 0x1b, 
    0x4d, 0x2e, 0x1c, 0x66, 0x02, 0x5c, 0xba, 0x1f, 0x3e, 0x3f, 0x54, 0xe0, 0x35, 0x1c, 0xb3, 0x00, 0xe6, 0x14, 0x59, 0x62, 0x54, 0x8a, 0x9b, 0x86, 0xf3, 0x3c, 0x69, 0xfa, 0x4b, 0x0c, 0x60, 0x99, 
    0x83, 0x6d, 0x4c, 0xf0, 0xdf, 0xf9, 0x46, 0x04, 0x5a, 0xba, 0x36, 0x63, 0xce, 0x22, 0x17, 0x6f, 0x47, 0x66, 0xc9, 0x7e, 0x4a, 0x8c, 0x9b, 0x9b, 0xc3, 0xa3, 0xfe, 0x45, 0x2c, 0xcb, 0xb0, 0x79, 
    0xab, 0x2d, 0x3d, 0x78, 0x32, 0xdd, 0xd5, 0x0c, 0x83, 0x31, 0xaf, 0x25, 0x46, 0xbe, 0xb8, 0x2b, 0xc6, 0xc1, 0x77, 0x2c, 0xab, 0xc9, 0x24, 0xd2, 0xfb, 0x69, 0xab, 0xfa, 0x88, 0x1a, 0x89, 0x57, 
    0x6f, 0x20, 0x89, 0x98, 0xa2, 0x82, 0x00, 0x82, 0x1a, 0xac, 0xdd, 0x70, 0x85, 0xcc, 0x56, 0x94, 0xd1, 0x37, 0xe4, 0x7b, 0x59, 0x87, 0x53, 0x62, 0x5c, 0x17, 0x3b, 0x03, 0x9b, 0xfe, 0x95, 0x54, 
    0x14, 0xe3, 0x98, 0x4a, 0xbc, 0xdb, 0xc7, 0xb5, 0x4b, 0xda, 0x0f, 0x3a, 0x99, 0x1f, 0xc4, 0x2c, 0x21, 0x2c, 0xc6, 0xa0, 0xac, 0x42, 0x0b, 0x50, 0x80, 0x52, 0x58, 0x66, 0xf5, 0x69, 0x02, 0x49, 
    0x50, 0x98, 0x89, 0xcb, 0xff, 0x2b, 0x95, 0x96, 0xa8, 0xe5, 0x22, 0xcc, 0xe9, 0x41, 0x81, 0xdd, 0x97, 0xc8, 0x85, 0x92, 0x9e, 0xb9, 0x28, 0x21, 0xb9, 0x51, 0x4e, 0xe9, 0xfd, 0xad, 0x06, 0x81, 
    0xc8, 0x27, 0xfa, 0x31, 0xc8, 0x6e, 0xee, 0xbd, 0x9a, 0xaa, 0x9a, 0xfa, 0x5e, 0xdb, 0x3e, 0xfc, 0x7f, 0x10, 0xb0, 0x6b, 0x3f, 0xb3, 0x6b, 0x30, 0xab, 0xc9, 0x0d, 0xc1, 0x49, 0x0f, 0x32, 0xb0, 
    0xfe, 0x0e, 0xfc, 0x9a, 0x93, 0xd9, 0x95, 0x2d, 0xb4, 0xbd, 0xbf, 0x43, 0x34, 0x43, 0x34, 0x4a, 0xee, 0x10, 0x57, 0x5b, 0xba, 0x5d, 0x70, 0xa9, 0xa4, 0x91, 0x61, 0x5d, 0xc5, 0x66, 0x0d, 0x10, 
    0xce, 0x86, 0xe4, 0x11, 0xef, 0x8a, 0xc1, 0x93, 0x56, 0x42, 0xe6, 0x0e, 0xf9, 0x60, 0xcf, 0xfc, 0x38, 0x6a, 0xda, 0xc7, 0xc1, 0x5e, 0xbf, 0x70, 0x25, 0xd9, 0x79, 0xbd, 0xa4, 0x23, 0xd8, 0xb6, 
    0xa2, 0x82, 0x4c, 0x3f, 0xb6, 0x35, 0x63, 0x34, 0xc2, 0x41, 0x7e, 0x06, 0x16, 0x5c, 0x6c, 0x05, 0x5f, 0x56, 0xfa, 0x3d, 0x43, 0x06, 0xcc, 0x6d, 0x8c, 0xb4, 0x79, 0xb8, 0xfc, 0x92, 0x5e, 0x77, 
    0x68, 0xe9, 0xa8, 0x08, 0xee, 0x31, 0xb3, 0xe7, 0x02, 0xa8, 0x3b, 0x33, 0x20, 0x63, 0x14, 0xe8, 0xbc, 0x44, 0x55, 0x7a, 0x8b, 0x91, 0x67, 0xa7, 0x6c, 0xf8, 0x0e, 0x1a, 0x70, 0x6e, 0x52, 0x82, 
    0x83, 0x09, 0x47, 0x24, 0x55, 0xcc, 0x24, 0x90, 0x8c, 0x8a, 0xd6, 0x43, 0xbe, 0xe9, 0xd1, 0xe9, 0xc1, 0x94, 0x40, 0x15, 0xb8, 0xf4, 0x10, 0x57, 0xa9, 0xfc, 0x20, 0x75, 0x89, 0x54, 0x05, 0xe0, 
    0x63, 0x68, 0x63, 0xe6
};


static const BYTE g_XmsskeySha2_20_256[] = {
    0x00, 0x00, 0x00, 0x03, 0xdc, 0x1e, 0xf6, 0x64, 0x3f, 0x14, 0xec, 0x6c, 0x75, 0xed, 0x10, 0xbd,
    0x14, 0xf2, 0x9f, 0x68, 0xad, 0xf4, 0x92, 0x8b, 0x53, 0x90, 0xcf, 0xf3, 0x9c, 0x19, 0x92, 0xd1,
    0x51, 0x68, 0x93, 0x81, 0xfa, 0x13, 0x45, 0x67, 0x59, 0xf3, 0x39, 0xdc, 0x37, 0x46, 0xc3, 0xfc,
    0x53, 0xb6, 0x56, 0x53, 0x56, 0xea, 0x83, 0x35, 0x48, 0xe3, 0x78, 0x9e, 0xf1, 0x90, 0xfd, 0xd6,
    0xf1, 0x47, 0x44, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x67, 0xbc, 0x4b, 0x91,
    0x86, 0x54, 0xb8, 0x07, 0xb2, 0xb4, 0x23, 0xd0, 0x12, 0x56, 0x2b, 0xfd, 0x83, 0x5b, 0x66, 0x60,
    0xba, 0x2b, 0xec, 0x41, 0x8d, 0x0a, 0x8b, 0x4f, 0xa9, 0x6b, 0xda, 0x1d, 0x0c, 0x38, 0xe8, 0xed,
    0xb1, 0xaf, 0x6a, 0xae, 0x6d, 0x53, 0x79, 0xac, 0xd7, 0x25, 0x07, 0x28, 0x22, 0x26, 0x4c, 0xa5,
    0xbb, 0x1e, 0x42, 0x3d, 0x5d, 0x01, 0xf0, 0xef, 0x7f, 0xa7, 0x83, 0x27
};

static const BYTE g_XmssSigSha2_20_256[] = {
    0x00, 0x00, 0x00, 0x01, 0x14, 0x0f, 0xfa, 0x56, 0x52, 0x55, 0xa0, 0xd3, 0x3e, 0x14, 0xd3, 0xe4, 0x07, 0x7b, 0x21, 0x07, 0x07, 0x9b, 0xdf, 0x4d, 0x39, 0x30, 0x65, 0x47, 0x69, 0x67, 0xeb, 0x80, 
    0x3e, 0x92, 0x45, 0x0e, 0x70, 0xee, 0x3e, 0x2d, 0x3f, 0x9c, 0x16, 0x3a, 0x7b, 0x4b, 0xb5, 0xef, 0xf3, 0xe6, 0x94, 0x41, 0x87, 0x56, 0x12, 0x07, 0xe9, 0xfb, 0x18, 0xaf, 0xb2, 0x8d, 0x9e, 0x5c, 
    0x7b, 0xfe, 0xd6, 0xd9, 0x43, 0x5a, 0xe4, 0x0e, 0xb1, 0xb6, 0xa0, 0xf4, 0x8e, 0xa9, 0x33, 0x14, 0x6e, 0xb0, 0xaf, 0xb5, 0x97, 0x4f, 0x19, 0x5d, 0x1f, 0x16, 0x52, 0xf9, 0x13, 0x72, 0x22, 0xcd, 
    0xd2, 0x14, 0x8a, 0x97, 0x45, 0xa1, 0x32, 0xab, 0x1f, 0x1f, 0xe2, 0xef, 0xb3, 0xc2, 0xb8, 0xc8, 0x31, 0x84, 0x50, 0xfb, 0x88, 0x1e, 0x60, 0xc2, 0x11, 0x1c, 0x94, 0x26, 0x34, 0x76, 0x1a, 0x7e, 
    0x7a, 0x9a, 0x9d, 0x1d, 0x42, 0x10, 0xc0, 0x69, 0x40, 0x15, 0xce, 0xa8, 0x83, 0xed, 0xea, 0x35, 0x4d, 0x75, 0x9e, 0x50, 0xbb, 0xa0, 0x64, 0xef, 0x59, 0x26, 0xae, 0xff, 0x55, 0xbe, 0xa2, 0x8b, 
    0x3a, 0x8b, 0x79, 0xf1, 0xb1, 0x88, 0xab, 0x55, 0x5c, 0x0e, 0x0b, 0x04, 0xd1, 0x9e, 0x21, 0xaa, 0xde, 0x92, 0x31, 0x36, 0xa9, 0x5b, 0x41, 0x07, 0xfc, 0xa1, 0x84, 0x4c, 0x4b, 0x0f, 0x02, 0xc1, 
    0xd3, 0x36, 0x1e, 0x1a, 0xa8, 0x98, 0x7e, 0xba, 0x95, 0x54, 0x38, 0xd5, 0x34, 0xa9, 0x58, 0x93, 0x14, 0x7f, 0xbe, 0xdb, 0x1f, 0xbf, 0x35, 0x69, 0xce, 0xe4, 0x95, 0xb6, 0x98, 0x6c, 0x29, 0x86, 
    0x30, 0x22, 0x00, 0x1a, 0x92, 0x48, 0x92, 0x2e, 0x03, 0x9a, 0x27, 0xf9, 0x04, 0xbc, 0xaf, 0x97, 0x8b, 0x2e, 0x79, 0x39, 0x9a, 0xab, 0x52, 0x42, 0x1a, 0xe9, 0xa4, 0x3b, 0xee, 0x0b, 0xb9, 0x9c, 
    0x55, 0x17, 0xf5, 0x61, 0xc6, 0x91, 0x34, 0xfc, 0xc1, 0x38, 0x03, 0x49, 0xba, 0x09, 0x54, 0x75, 0x1c, 0xe8, 0x17, 0xa4, 0xfb, 0x81, 0x9e, 0xdc, 0x39, 0x3b, 0xb2, 0x72, 0x9c, 0x27, 0x4c, 0xa2, 
    0xe1, 0x89, 0x76, 0x8a, 0x8e, 0x49, 0x2a, 0x65, 0x2e, 0x4b, 0xf8, 0xe3, 0x8d, 0x16, 0x94, 0xf8, 0x46, 0xe9, 0x24, 0xdb, 0xdb, 0x70, 0x4c, 0x99, 0xe3, 0x76, 0xac, 0x7a, 0x20, 0xde, 0xa5, 0x17, 
    0xf1, 0x0d, 0x23, 0xfd, 0x5c, 0x12, 0x33, 0xe4, 0x12, 0xe2, 0x45, 0xbb, 0x9e, 0x35, 0xc6, 0x1a, 0x8a, 0x53, 0x98, 0x4e, 0x0d, 0x21, 0x92, 0xbe, 0xd0, 0xf7, 0xb7, 0x87, 0x8d, 0x7e, 0x38, 0xd8, 
    0xc1, 0x7c, 0x16, 0x19, 0x46, 0xa4, 0x6e, 0x62, 0x70, 0xa3, 0xda, 0xab, 0xf4, 0x27, 0xac, 0xaa, 0x15, 0x7e, 0x6d, 0x46, 0xaf, 0xa9, 0x78, 0xb2, 0xa6, 0xb6, 0x3f, 0xb2, 0xe8, 0x64, 0x12, 0x95, 
    0x66, 0x7a, 0xd7, 0x1b, 0x5f, 0xa1, 0xa7, 0x53, 0x87, 0xdf, 0x47, 0x3f, 0xc0, 0xbf, 0x57, 0x2b, 0x87, 0x67, 0x12, 0x39, 0xf6, 0xce, 0x7e, 0xa5, 0xf5, 0x62, 0xfe, 0x39, 0x1b, 0xb5, 0x88, 0x51, 
    0x84, 0x3a, 0xc3, 0xc6, 0xfd, 0x3f, 0x73, 0x18, 0xb1, 0xe6, 0xfe, 0x5c, 0x1d, 0x4f, 0x54, 0xb2, 0x18, 0xae, 0xf3, 0x98, 0x5b, 0x41, 0x08, 0x5b, 0xa9, 0x2d, 0x78, 0xfc, 0x6a, 0xca, 0xe8, 0x2f, 
    0x2b, 0x11, 0xef, 0x53, 0x9d, 0x7e, 0x97, 0xa3, 0xb3, 0xeb, 0xb3, 0x06, 0x96, 0xdd, 0xd7, 0xf5, 0xba, 0xe4, 0xa6, 0x23, 0x61, 0xf6, 0xfa, 0x5f, 0x13, 0xfc, 0x0a, 0x6e, 0xa5, 0x7e, 0x60, 0x18, 
    0xf4, 0xd8, 0xa8, 0x0f, 0x57, 0xec, 0x87, 0x7a, 0x9a, 0xcb, 0xe4, 0xdc, 0x43, 0x3c, 0x18, 0x9c, 0x7c, 0x33, 0x9e, 0xab, 0x03, 0xe3, 0x3c, 0x99, 0xc3, 0xf2, 0xa8, 0xb9, 0x9d, 0x16, 0x99, 0xcb, 
    0x06, 0xba, 0x89, 0x0c, 0xe0, 0x6f, 0x87, 0x1a, 0x5d, 0x16, 0xdf, 0x71, 0x0c, 0x6d, 0x15, 0x23, 0x76, 0x8f, 0xc8, 0x2c, 0x6b, 0xcf, 0x11, 0xa5, 0x65, 0x8c, 0xd3, 0x70, 0x7f, 0x83, 0xd8, 0x28, 
    0x48, 0x09, 0x48, 0x8a, 0xf0, 0xe0, 0x3c, 0x5a, 0xdd, 0xc0, 0xa1, 0xa8, 0x0e, 0x70, 0x33, 0x33, 0x92, 0xf1, 0x5a, 0xa5, 0xed, 0x10, 0xd4, 0xdb, 0x73, 0x93, 0x89, 0x93, 0x17, 0x4a, 0xc6, 0x69, 
    0x2a, 0x4b, 0x20, 0x42, 0x75, 0xf5, 0xfe, 0x2d, 0x4b, 0xb1, 0x11, 0x85, 0x3f, 0x37, 0xc3, 0x71, 0xdd, 0xcb, 0x1a, 0x11, 0xff, 0x27, 0xd4, 0x73, 0xdc, 0x69, 0x6d, 0x8d, 0x7c, 0x8f, 0xfa, 0x44, 
    0xb8, 0x09, 0x5e, 0xf9, 0xb9, 0x33, 0x83, 0xa0, 0x12, 0xf5, 0x58, 0x71, 0x31, 0xbc, 0x15, 0x35, 0xd9, 0xa2, 0x1a, 0x5f, 0x00, 0x99, 0xc6, 0xbb, 0x5e, 0x4b, 0x61, 0x29, 0x94, 0xf4, 0x5b, 0x1f, 
    0xad, 0x35, 0x3b, 0xd8, 0x98, 0x4e, 0x6c, 0xd7, 0xac, 0xa9, 0x4e, 0x44, 0xa0, 0x4b, 0xfa, 0x50, 0xd6, 0x24, 0x9e, 0x74, 0x3f, 0xcb, 0x6a, 0xdf, 0xe8, 0xef, 0x59, 0x41, 0xb7, 0x4f, 0x95, 0xf4, 
    0x88, 0x49, 0x5b, 0x43, 0xf7, 0x33, 0x1d, 0x34, 0xc8, 0x45, 0x93, 0x7d, 0x13, 0x55, 0x94, 0xd7, 0xc1, 0x93, 0xaf, 0xa8, 0x04, 0xca, 0x3e, 0x3c, 0x9c, 0xa0, 0x1c, 0x60, 0xf2, 0x5f, 0x9e, 0x05, 
    0xc1, 0x9d, 0xa2, 0x0e, 0x3f, 0xc8, 0xd6, 0x1e, 0x60, 0x66, 0xf2, 0x7e, 0x9c, 0xfa, 0xaf, 0xfc, 0x80, 0xf2, 0x9f, 0xad, 0xa0, 0xfe, 0x7a, 0x82, 0xf9, 0x38, 0x94, 0xff, 0x02, 0x43, 0x6d, 0x27, 
    0x2c, 0x63, 0x8b, 0xff, 0xea, 0xa5, 0x3b, 0x57, 0xac, 0x01, 0x66, 0x8a, 0xbf, 0xf5, 0x40, 0xda, 0x92, 0x65, 0x96, 0x9a, 0x4f, 0x96, 0xf5, 0xab, 0x86, 0xd0, 0x2c, 0xe9, 0x5d, 0xc6, 0xb3, 0x60, 
    0x0d, 0x36, 0x8f, 0xca, 0xe2, 0x91, 0x5d, 0x89, 0xe9, 0xa6, 0xb0, 0x18, 0x07, 0x9d, 0xae, 0xcb, 0x84, 0xd7, 0xe1, 0xd1, 0x00, 0xf6, 0x4e, 0xf1, 0x01, 0x9c, 0x33, 0xc7, 0xb9, 0xf1, 0xee, 0x96, 
    0xb6, 0x2e, 0xc4, 0xe7, 0x8f, 0x04, 0x16, 0x18, 0x8d, 0xd8, 0xb7, 0xec, 0x65, 0xc2, 0x67, 0x50, 0x70, 0x82, 0x03, 0x78, 0x0f, 0xd4, 0x8e, 0x03, 0xe0, 0x10, 0x92, 0x8e, 0x31, 0xbc, 0xdc, 0x2b, 
    0xfa, 0x30, 0x7c, 0x23, 0xd0, 0x55, 0x30, 0x77, 0xea, 0x39, 0x23, 0x5f, 0x69, 0x63, 0xac, 0x5f, 0x29, 0x0e, 0x82, 0xa3, 0xb1, 0x11, 0xcb, 0xa9, 0xa9, 0xcf, 0x0d, 0x80, 0x1e, 0xa7, 0x85, 0x4b, 
    0x19, 0xce, 0x79, 0x00, 0x85, 0xcc, 0x5f, 0xc6, 0xfe, 0x17, 0xb3, 0x72, 0x1c, 0x9c, 0xb3, 0xdd, 0x62, 0x52, 0xa6, 0xc7, 0xf2, 0xb4, 0x05, 0xde, 0x91, 0x1b, 0xc5, 0xac, 0xaa, 0xa3, 0xdb, 0xfa, 
    0x32, 0xc0, 0x2a, 0xee, 0x4e, 0x49, 0x49, 0x09, 0xdc, 0x4c, 0x80, 0xa0, 0x09, 0xdc, 0xc5, 0xab, 0x98, 0xa1, 0x1f, 0xd0, 0xba, 0x78, 0xd0, 0x21, 0xf4, 0x09, 0xf9, 0x72, 0xa7, 0xbf, 0x17, 0xe5, 
    0xd9, 0x2d, 0x77, 0x4a, 0xb0, 0xfa, 0xee, 0xe1, 0x22, 0x1c, 0xfc, 0x91, 0xe5, 0x8a, 0xa1, 0x99, 0x10, 0x8c, 0x49, 0xfb, 0x50, 0xbf, 0x11, 0xa5, 0x65, 0x3a, 0x00, 0x85, 0xf3, 0xe0, 0x3e, 0x4a, 
    0xf5, 0x8a, 0x9d, 0xa0, 0x48, 0xea, 0x23, 0x50, 0x9f, 0x95, 0xa2, 0x6f, 0xeb, 0x3a, 0xfd, 0xb1, 0xf2, 0x35, 0x9a, 0x51, 0x58, 0x6f, 0x71, 0xc8, 0x31, 0x61, 0xa4, 0x40, 0xae, 0x15, 0x47, 0x04, 
    0xd3, 0x55, 0xa5, 0xa6, 0x58, 0x49, 0x47, 0x10, 0x09, 0x83, 0x51, 0xc6, 0xea, 0xa6, 0xe1, 0x3a, 0x51, 0x65, 0xeb, 0xcc, 0xe2, 0xd5, 0x7d, 0x7e, 0xc2, 0x0d, 0x19, 0x43, 0x85, 0x43, 0xbe, 0xc0, 
    0x9f, 0x1a, 0x5c, 0x1e, 0x93, 0x11, 0xb0, 0x40, 0x40, 0x8f, 0x02, 0x32, 0xec, 0xc9, 0x48, 0x89, 0x54, 0x1d, 0x88, 0x40, 0x00, 0xa6, 0x00, 0x3f, 0x00, 0x4e, 0x98, 0x47, 0x52, 0xbf, 0xac, 0x59, 
    0xf1, 0x88, 0x2d, 0x99, 0xce, 0x7b, 0x82, 0x18, 0xa4, 0x2f, 0xce, 0xd8, 0x1b, 0xe3, 0x78, 0xdd, 0x83, 0xc9, 0xe3, 0x2f, 0xc3, 0x74, 0xea, 0x3b, 0x3a, 0x6b, 0xf5, 0xb0, 0x7f, 0x13, 0x6a, 0x99, 
    0xa2, 0x9b, 0x1a, 0x28, 0x4f, 0xf7, 0x51, 0x94, 0x57, 0x25, 0x8d, 0x8e, 0x99, 0xb7, 0xf9, 0xf8, 0x30, 0xe8, 0x53, 0xa9, 0xf8, 0xf3, 0xe6, 0xfc, 0xa0, 0x23, 0x01, 0xed, 0xe8, 0xea, 0x2d, 0x52, 
    0x0b, 0x94, 0x96, 0x5a, 0x1a, 0x54, 0xd4, 0xf4, 0x97, 0xfb, 0x0c, 0xe8, 0x10, 0x18, 0xab, 0x5f, 0x4b, 0x92, 0x9e, 0x1f, 0xc8, 0xe5, 0x11, 0x72, 0xd4, 0x55, 0xa5, 0xd1, 0x7c, 0x89, 0x52, 0xa8, 
    0x67, 0x30, 0x92, 0x0a, 0x0c, 0x12, 0xde, 0x34, 0x54, 0xfc, 0x4e, 0xfa, 0xa2, 0xef, 0xbc, 0xea, 0x36, 0x17, 0x89, 0xa5, 0xb6, 0x70, 0xf5, 0x57, 0x7c, 0xd7, 0x65, 0xcc, 0xe0, 0xdf, 0x30, 0xe0, 
    0x41, 0xf6, 0x62, 0x3d, 0x1e, 0x03, 0xbc, 0xbf, 0x90, 0x2f, 0xc7, 0x09, 0x30, 0x9b, 0xc1, 0x55, 0x28, 0xc1, 0xd9, 0x15, 0x92, 0x8d, 0x17, 0x67, 0xb3, 0xec, 0x08, 0x2f, 0x20, 0xbb, 0x7d, 0x19, 
    0x62, 0xd9, 0xc5, 0xaa, 0x24, 0x64, 0xb5, 0x49, 0xb5, 0x1f, 0xa7, 0x87, 0x18, 0x70, 0x9e, 0xee, 0xec, 0xea, 0x0f, 0x6a, 0x0b, 0x96, 0x1a, 0xa5, 0x96, 0x75, 0xd6, 0x06, 0x97, 0xb5, 0xf6, 0x11, 
    0x0d, 0x74, 0xf4, 0x2d, 0xb2, 0x27, 0x3e, 0x3c, 0xb2, 0xe5, 0x81, 0x85, 0xbe, 0x48, 0x78, 0xe3, 0xfa, 0x54, 0x06, 0xed, 0xb2, 0xec, 0xa0, 0xa2, 0x35, 0x31, 0x0e, 0x64, 0xcd, 0xad, 0x92, 0xdd, 
    0x56, 0x66, 0xeb, 0x23, 0xec, 0x80, 0x55, 0x58, 0x0e, 0x89, 0x4c, 0xbc, 0x5e, 0x26, 0x57, 0x6e, 0x79, 0xe3, 0x49, 0x7c, 0x04, 0xe1, 0x7d, 0x35, 0x55, 0x2e, 0x92, 0xeb, 0xd7, 0xaf, 0xb7, 0x27, 
    0x72, 0x61, 0x82, 0x0d, 0xb2, 0x07, 0xba, 0xfd, 0x88, 0x6a, 0x07, 0x8d, 0xd7, 0x4c, 0x0a, 0x2b, 0x1e, 0x54, 0x62, 0x7b, 0x26, 0x09, 0x43, 0x43, 0x5a, 0xd0, 0x01, 0x4b, 0xed, 0x63, 0xe0, 0x4c, 
    0xc2, 0x62, 0x75, 0x5f, 0xe7, 0xc0, 0xb4, 0x59, 0x97, 0x07, 0x84, 0xae, 0x87, 0xf4, 0xc7, 0x20, 0xbb, 0x38, 0xae, 0x65, 0xc5, 0x84, 0x59, 0xc9, 0x84, 0x85, 0x0c, 0x8b, 0x41, 0x0a, 0x66, 0x5f, 
    0x7f, 0xec, 0xc9, 0x03, 0x8d, 0xf6, 0x36, 0x64, 0xe9, 0x4a, 0x66, 0xfa, 0x39, 0xc3, 0xae, 0x24, 0x4e, 0xa1, 0x52, 0x40, 0x74, 0x37, 0x13, 0x56, 0x78, 0x4d, 0x04, 0x11, 0xa2, 0xcb, 0x4f, 0xa4, 
    0x8c, 0x7a, 0x31, 0xb6, 0x39, 0xd1, 0xd9, 0x68, 0xef, 0x69, 0x1c, 0x17, 0x02, 0x48, 0x50, 0x22, 0x15, 0xa9, 0x7a, 0xc7, 0x99, 0xe0, 0xa9, 0x6b, 0xb0, 0xea, 0x12, 0x13, 0xad, 0x6e, 0xb7, 0x9c, 
    0xa9, 0x6b, 0x4c, 0xd0, 0x0e, 0x19, 0x33, 0x1c, 0x75, 0xad, 0xea, 0xbf, 0x3d, 0x4a, 0xe0, 0xcc, 0xe9, 0xe5, 0x26, 0x20, 0x8d, 0x6c, 0x54, 0x9f, 0x48, 0x62, 0x35, 0xec, 0x4d, 0x75, 0x36, 0x55, 
    0xcd, 0xd3, 0x51, 0x9a, 0x71, 0xf4, 0x93, 0x71, 0xe3, 0xd1, 0x2e, 0x3d, 0x25, 0x62, 0x72, 0x1e, 0x80, 0x1b, 0xbb, 0x85, 0xd6, 0x0e, 0x08, 0x07, 0x89, 0xf9, 0x46, 0x83, 0x99, 0x2a, 0xff, 0x47, 
    0x23, 0xe9, 0x2f, 0x5a, 0xbd, 0xf6, 0x99, 0xb9, 0x71, 0x99, 0x44, 0x6b, 0xd7, 0x28, 0x53, 0xed, 0xb7, 0x38, 0xc8, 0xe0, 0x57, 0x9a, 0xdf, 0x88, 0xe9, 0x67, 0x3a, 0x30, 0x2e, 0x88, 0xe5, 0xfc, 
    0x6d, 0x25, 0xcb, 0xd6, 0xbb, 0x10, 0x22, 0x0c, 0xed, 0xbe, 0x93, 0x93, 0xe9, 0x1d, 0x12, 0x93, 0xa8, 0x24, 0x59, 0x20, 0xef, 0x25, 0x68, 0x53, 0x55, 0x98, 0x7f, 0xd3, 0x41, 0x64, 0x71, 0xaa, 
    0x12, 0xf6, 0xfa, 0xca, 0x41, 0x20, 0x25, 0x67, 0xad, 0x9e, 0x46, 0x5b, 0xbf, 0x53, 0x4c, 0xad, 0x02, 0xdf, 0x45, 0x07, 0x3f, 0x91, 0x98, 0x1c, 0xf1, 0xdc, 0xe6, 0x64, 0x12, 0xb7, 0xb1, 0xc5, 
    0x0d, 0x82, 0xf8, 0xdd, 0x61, 0xe2, 0x3d, 0x6b, 0xea, 0x2e, 0x70, 0x94, 0x69, 0xd4, 0xec, 0x85, 0xe6, 0x80, 0x55, 0x23, 0x39, 0xa1, 0xf8, 0xfa, 0xc4, 0x5f, 0x0d, 0x7e, 0xa0, 0xe5, 0xe9, 0x06, 
    0x3a, 0x5b, 0x8f, 0x0e, 0x39, 0x29, 0xcb, 0xa4, 0x0a, 0xa5, 0xb3, 0xa3, 0xef, 0x22, 0x87, 0x09, 0x96, 0xa7, 0x93, 0x88, 0xb6, 0x89, 0xb0, 0x98, 0x3e, 0xf1, 0xac, 0xfb, 0x25, 0xf5, 0x59, 0x08, 
    0xae, 0xc6, 0xa8, 0xa6, 0x69, 0xc4, 0xba, 0x76, 0x07, 0xc5, 0xbb, 0xd1, 0xf6, 0xe4, 0x16, 0xa8, 0x73, 0x4e, 0x0d, 0x91, 0xaa, 0x9f, 0xe3, 0xff, 0xd9, 0xaf, 0x76, 0xda, 0x68, 0xbe, 0xb4, 0xa1, 
    0xa2, 0x72, 0x0e, 0xd1, 0x4d, 0x14, 0x0d, 0x05, 0xf7, 0x02, 0x41, 0x67, 0x6e, 0xd3, 0xa2, 0xa0, 0x88, 0xb6, 0xe2, 0xbb, 0x33, 0x58, 0x06, 0x65, 0x0b, 0xa7, 0xce, 0x72, 0x8f, 0x90, 0x23, 0x19, 
    0x0d, 0xfc, 0x6b, 0x6c, 0x6e, 0x15, 0xe5, 0xdf, 0x4f, 0xa5, 0xa9, 0x74, 0x5a, 0x95, 0x15, 0x02, 0xf1, 0x55, 0xb8, 0x0e, 0xbc, 0xd4, 0x6e, 0x9e, 0x20, 0x97, 0x00, 0x98, 0x28, 0x51, 0x3e, 0x13, 
    0xd6, 0x12, 0xff, 0xa1, 0xf6, 0xae, 0x55, 0x41, 0x7a, 0x6d, 0xc1, 0x10, 0xa8, 0x56, 0x60, 0xef, 0xa4, 0x33, 0x8b, 0x4d, 0x84, 0xef, 0xee, 0x0c, 0xf2, 0xdd, 0xba, 0x54, 0xb8, 0x42, 0xec, 0xd6, 
    0x14, 0x61, 0x91, 0xfa, 0x56, 0xfb, 0xf4, 0xe4, 0xc6, 0x76, 0xe7, 0xf9, 0xc3, 0xd2, 0xc5, 0xa5, 0xa3, 0x37, 0xda, 0xf9, 0x04, 0xf0, 0x90, 0xda, 0x14, 0xa0, 0xc9, 0x69, 0x11, 0xe2, 0x73, 0x29, 
    0x2f, 0xfc, 0xe0, 0x24, 0x18, 0xec, 0x8c, 0x06, 0xe5, 0xa1, 0xb4, 0xf4, 0x25, 0x9f, 0xc7, 0xb0, 0x5b, 0xac, 0xae, 0x07, 0x1e, 0x34, 0x15, 0x58, 0x74, 0x4e, 0xb1, 0xab, 0x9c, 0xa3, 0xe2, 0x48, 
    0x7f, 0xc7, 0x35, 0xda, 0x31, 0x2e, 0x45, 0xea, 0x63, 0x6f, 0x4f, 0x8e, 0xd1, 0xa5, 0x94, 0xb3, 0x6d, 0x5a, 0x56, 0x86, 0x27, 0x95, 0x4b, 0x1e, 0x6f, 0x6f, 0xe9, 0x9e, 0xb6, 0x24, 0xce, 0xeb, 
    0xfb, 0x65, 0x64, 0x4d, 0x71, 0x15, 0x68, 0x22, 0x59, 0x23, 0x79, 0x61, 0xac, 0xa4, 0x8e, 0x16, 0x29, 0x2d, 0xee, 0xee, 0x9f, 0x1e, 0xe2, 0xef, 0x4c, 0x62, 0xb7, 0x14, 0x96, 0xca, 0xc3, 0x23, 
    0xc4, 0xcf, 0xf5, 0xfb, 0xbd, 0xf9, 0x66, 0x90, 0x0f, 0x0a, 0xf3, 0x77, 0x86, 0xb9, 0x47, 0x49, 0xa6, 0x0e, 0xa8, 0x25, 0x69, 0xc7, 0x38, 0x09, 0x75, 0x80, 0x64, 0x30, 0xa6, 0x20, 0x7a, 0x88, 
    0x17, 0xdd, 0xde, 0x60, 0xf5, 0x5f, 0xb7, 0x6e, 0x42, 0xab, 0xcc, 0x3e, 0xdd, 0x5f, 0x73, 0x98, 0x08, 0xcc, 0x9a, 0x38, 0xf0, 0x87, 0x9e, 0xee, 0x1c, 0xec, 0xd1, 0x48, 0x23, 0x10, 0x36, 0xdb, 
    0x99, 0x1d, 0x70, 0xc1, 0xa9, 0x36, 0x74, 0xc0, 0x66, 0xea, 0x7c, 0x30, 0xdb, 0xa8, 0xc7, 0xa5, 0xb5, 0xb6, 0xf8, 0x77, 0x38, 0xcb, 0xd6, 0x46, 0x71, 0x2a, 0xc7, 0x1a, 0x70, 0xde, 0xf9, 0xe0, 
    0x25, 0x6a, 0xb8, 0xc3, 0xaf, 0x81, 0xe6, 0x61, 0xf5, 0x87, 0x7a, 0xad, 0x84, 0x81, 0x88, 0x76, 0xa5, 0xc7, 0xa2, 0x08, 0x6b, 0x13, 0xec, 0x4a, 0xda, 0xf0, 0xe4, 0xa0, 0x1c, 0xef, 0xaa, 0x4f, 
    0x22, 0xf9, 0xb9, 0x7d, 0x86, 0x45, 0x44, 0x3a, 0x76, 0x33, 0xa2, 0x97, 0xe4, 0x46, 0x20, 0xe1, 0x7e, 0x88, 0x00, 0x44, 0x0a, 0x0f, 0xc9, 0xeb, 0xf1, 0xb7, 0x38, 0x43, 0x64, 0x9b, 0xf8, 0xa5, 
    0x9b, 0x8d, 0x4c, 0x97, 0x1a, 0xfe, 0xc2, 0xc7, 0xbb, 0x41, 0xcf, 0x6a, 0x53, 0x7e, 0x65, 0x12, 0x7b, 0xe7, 0xee, 0x77, 0x0c, 0xc5, 0x16, 0x25, 0xfc, 0x05, 0x3a, 0x52, 0x1b, 0x5d, 0x0f, 0xe8, 
    0xc2, 0x39, 0x9c, 0x3c, 0x25, 0x7a, 0x68, 0x10, 0x09, 0xa8, 0x27, 0x2f, 0xd4, 0x82, 0xd5, 0x8a, 0xf7, 0xbd, 0x1e, 0x01, 0x51, 0x10, 0x88, 0x2e, 0x29, 0x1c, 0x09, 0x9b, 0x39, 0xcb, 0xe5, 0x04, 
    0xc8, 0x8c, 0x8f, 0xdf, 0x3a, 0x53, 0x1e, 0xb5, 0xed, 0xcc, 0x6b, 0x07, 0xbd, 0x39, 0xc4, 0x6e, 0x00, 0x86, 0x5c, 0xe7, 0xed, 0xd4, 0x9d, 0x44, 0xa3, 0x2b, 0x32, 0x28, 0x1f, 0x12, 0xd3, 0x86, 
    0x04, 0x2a, 0x82, 0x3a, 0xf9, 0x31, 0xcb, 0xa6, 0x34, 0x16, 0x1d, 0x87, 0xa8, 0x8d, 0xa1, 0xe7, 0xef, 0xe9, 0xb2, 0x25, 0xab, 0xcf, 0xa4, 0xe5, 0x61, 0x81, 0xa5, 0x24, 0x2b, 0x91, 0xd6, 0x62, 
    0x70, 0xd4, 0xbb, 0x53, 0xc4, 0x0a, 0x8a, 0x79, 0xd2, 0x47, 0x44, 0x33, 0x88, 0xca, 0x3a, 0xcb, 0xaf, 0x77, 0xc4, 0x08, 0xac, 0xac, 0xe7, 0x2e, 0x30, 0xf5, 0x89, 0xe8, 0x92, 0x3a, 0xcd, 0x9e, 
    0x98, 0x23, 0x35, 0x9b, 0x11, 0xc9, 0x6e, 0x51, 0x23, 0x8f, 0x89, 0x7c, 0xd6, 0xaf, 0x55, 0x42, 0xf9, 0xaf, 0xe9, 0xab, 0x43, 0xd9, 0xc4, 0x84, 0x35, 0x30, 0x2d, 0x65, 0x4a, 0x5b, 0x7c, 0x5f, 
    0xb6, 0x95, 0x69, 0x41, 0x11, 0xe6, 0x47, 0x8d, 0x7f, 0x97, 0xf8, 0xf1, 0x42, 0xe0, 0xf7, 0x3f, 0x9a, 0x2e, 0xd9, 0x4b, 0x16, 0xff, 0xef, 0xf1, 0x3d, 0xd7, 0xba, 0x3c, 0xe7, 0x99, 0x43, 0x4c, 
    0xbe, 0xe0, 0xe7, 0x4e, 0x56, 0xad, 0x81, 0xb3, 0xa7, 0xbd, 0xd9, 0x94, 0x60, 0x35, 0x8e, 0x7d, 0x5a, 0xa8, 0xfb, 0x2c, 0x19, 0xdb, 0x80, 0x9e, 0x72, 0xd0, 0x96, 0x75, 0x93, 0x04, 0xef, 0x2d, 
    0x71, 0x9e, 0xe3, 0x3b, 0xc5, 0x4c, 0x5b, 0x31, 0xe0, 0x0b, 0xd8, 0xfd, 0x51, 0xb3, 0x05, 0x5f, 0xfb, 0x88, 0x75, 0x16, 0x83, 0x1a, 0x28, 0xf4, 0x93, 0xfd, 0x17, 0x9c, 0x8f, 0xd7, 0x7a, 0x2d, 
    0x1b, 0xcc, 0xd0, 0x77, 0x98, 0x04, 0xd3, 0xdb, 0x46, 0x16, 0x45, 0x31, 0x97, 0x24, 0x9b, 0xce, 0x6a, 0xad, 0x92, 0x6c, 0x57, 0x59, 0x03, 0xfc, 0x8b, 0xa9, 0xb4, 0x64, 0x0f, 0xb5, 0x75, 0x4c, 
    0x30, 0x12, 0x58, 0xc1, 0x8e, 0xb1, 0xa1, 0xc7, 0xc1, 0x00, 0x71, 0x2e, 0x8f, 0xbf, 0xcb, 0xc3, 0xfd, 0x75, 0x47, 0x32, 0x04, 0xa5, 0xd7, 0x96, 0x8c, 0x6f, 0xf9, 0xaf, 0xcc, 0x21, 0x77, 0x56, 
    0x20, 0xef, 0xa1, 0xdb, 0xed, 0xe2, 0x6e, 0x48, 0x87, 0xf3, 0x2a, 0x66, 0x6a, 0x61, 0x56, 0x5b, 0x94, 0x2c, 0xbf, 0xdc, 0x8f, 0x06, 0xbc, 0xaa, 0xa7, 0xfa, 0x2a, 0x52, 0xd5, 0x8c, 0xee, 0xf3, 
    0xdb, 0x36, 0xc8, 0x52, 0x79, 0x8e, 0x66, 0xf3, 0x85, 0xa6, 0xb4, 0xf7, 0xd8, 0x63, 0xa0, 0x51, 0xa7, 0x51, 0xfc, 0x21, 0x80, 0x27, 0x1a, 0x58, 0xb6, 0x67, 0xdb, 0xf1, 0xb2, 0xd1, 0x9b, 0xae, 
    0xef, 0x24, 0xa6, 0x61, 0x2f, 0xa8, 0xab, 0x76, 0x9e, 0x59, 0x8a, 0x8c, 0x53, 0x64, 0x9a, 0x92, 0x6e, 0xe1, 0xce, 0xcb, 0xb0, 0xa3, 0x0a, 0x28, 0xf4, 0x78, 0xf7, 0x55, 0x2f, 0x3e, 0x49, 0xe8, 
    0x25, 0xcf, 0x15, 0x20, 0x24, 0x27, 0xb4, 0x7c, 0xe1, 0x4d, 0x6c, 0x04, 0xcb, 0x04, 0x9d, 0xbd, 0x71, 0xbc, 0x19, 0x66, 0xf1, 0x41, 0xc3, 0xd7, 0x70, 0xc6, 0xef, 0x52, 0x09, 0x55, 0xae, 0x34, 
    0xa1, 0xb0, 0x73, 0x31, 0x56, 0x40, 0x69, 0x19, 0xbc, 0xb5, 0x49, 0xd1, 0xd2, 0x50, 0xf6, 0xfa, 0x67, 0x2d, 0x64, 0xdd, 0x57, 0xe4, 0x7c, 0x98, 0xe1, 0xfe, 0xa3, 0x20, 0xaf, 0x8b, 0xc7, 0xf1, 
    0x22, 0xc5, 0xcd, 0xc9, 0xf9, 0x03, 0xc8, 0x3a, 0x87, 0x22, 0xcb, 0x84, 0x95, 0x91, 0xe2, 0x02, 0xb1, 0xfb, 0x47, 0x34, 0x97, 0x38, 0xf3, 0x03, 0x06, 0x92, 0x9c, 0x6b, 0x58, 0xe8, 0xae, 0x35, 
    0x4d, 0x64, 0x19, 0x42, 0xb5, 0xbc, 0xc8, 0x5a, 0xdc, 0x1c, 0x61, 0xd3, 0x79, 0x4e, 0xaf, 0x84, 0xda, 0xb0, 0x41, 0xeb, 0xae, 0x96, 0xad, 0xab, 0xc8, 0xd1, 0xb9, 0xde, 0x94, 0xc8, 0x5b, 0x92, 
    0xdf, 0x9e, 0x3e, 0x97, 0x5d, 0xb9, 0xd4, 0x54, 0x21, 0xa8, 0xbe, 0x21, 0x2f, 0x0b, 0x8e, 0x0d, 0xcc, 0xf3, 0x1a, 0xb4, 0xf5, 0xc2, 0x69, 0x97, 0x34, 0x5a, 0x0f, 0xd3, 0xcc, 0xff, 0x0a, 0xa5, 
    0x2d, 0xa5, 0x74, 0x52, 0xd3, 0xea, 0xc9, 0x8d, 0xb5, 0xab, 0xae, 0x60, 0x92, 0x1e, 0xc4, 0x8c, 0x2e, 0xf0, 0xfe, 0x10, 0xaa, 0xb8, 0x6f, 0x75, 0x78, 0x3d, 0x49, 0x50, 0x45, 0x00, 0x3c, 0x6f, 
    0x5f, 0x24, 0x26, 0x20, 0xbd, 0x46, 0xf5, 0x85, 0x00, 0x22, 0x43, 0x8a, 0xda, 0x4e, 0xa8, 0xcc, 0x45, 0xd5, 0x19, 0x69, 0x09, 0x62, 0x9f, 0xe2, 0x22, 0xfb, 0x36, 0x26, 0xb1, 0xef, 0x76, 0x7d, 
    0x9d, 0x4a, 0x16, 0x3b, 0x04, 0x49, 0x79, 0xf4, 0x9d, 0x27, 0x10, 0x14, 0x58, 0x11, 0x83, 0xd5, 0x12, 0xcb, 0xa3, 0x29, 0x59, 0x8c, 0x2a, 0x56, 0x8e, 0x5f, 0xde, 0xc4, 0x20, 0xdf, 0x5f, 0x70, 
    0x6b, 0xe4, 0x39, 0x64, 0x05, 0xc3, 0x32, 0xe2, 0xc7, 0x95, 0x29, 0xd5, 0xf5, 0xaf, 0x6e, 0x16, 0x2a, 0x44, 0x87, 0x32, 0xe4, 0x41, 0x25, 0xdc, 0xf8, 0xf9, 0x84, 0xc7, 0x51, 0x21, 0x8e, 0x75, 
    0xe7, 0x6d, 0x12, 0x26
};


static const BYTE g_XmsskeySha2_10_512[] = {
    0x00, 0x00, 0x00, 0x04, 0x08, 0xf8, 0x09, 0x87, 0xaa, 0x8f, 0x38, 0x5f, 0x70, 0x69, 0x30, 0x14,
    0x36, 0xb4, 0x0d, 0xf7, 0xaf, 0xfa, 0x65, 0x9c, 0x96, 0xb6, 0xbc, 0xaa, 0x81, 0x9a, 0xc3, 0x78,
    0x98, 0x91, 0xb6, 0xb1, 0xe6, 0xc9, 0x62, 0x30, 0xb7, 0xb7, 0x5c, 0x04, 0x88, 0xc3, 0x48, 0x80,
    0x4b, 0x02, 0x1d, 0x70, 0x9b, 0xc8, 0xa6, 0x44, 0xd7, 0xcb, 0x81, 0xd8, 0x97, 0xdd, 0x88, 0x00,
    0x68, 0x52, 0x10, 0xb3, 0x0b, 0xfa, 0xb0, 0x43, 0xb8, 0xef, 0x30, 0x2a, 0x43, 0x66, 0xa6, 0x26,
    0x67, 0x53, 0xa0, 0x31, 0x6e, 0x7b, 0x3b, 0x3e, 0x48, 0x3e, 0xd3, 0x7a, 0x12, 0x72, 0x73, 0xcb,
    0xff, 0xfa, 0xca, 0xc9, 0x6c, 0x79, 0x5f, 0xb1, 0x76, 0x7a, 0x26, 0x13, 0x92, 0x25, 0x83, 0x7e,
    0x09, 0xcb, 0x10, 0x28, 0x01, 0x25, 0x8e, 0xd3, 0x95, 0xed, 0xb5, 0x16, 0xc4, 0x33, 0x3a, 0xed,
    0x4c, 0x42, 0x70, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3e, 0x8a, 0x35, 0x01,
    0xd2, 0x83, 0x7c, 0xf5, 0x95, 0x6d, 0xff, 0x89, 0xb9, 0x93, 0x22, 0xa2, 0xa2, 0x07, 0xe3, 0xc5,
    0xd6, 0x6b, 0xeb, 0x29, 0xe2, 0xd2, 0x33, 0x1b, 0xa2, 0x2c, 0xae, 0xbb, 0x9b, 0x24, 0xa0, 0xc9,
    0xc0, 0xa2, 0xac, 0x08, 0xaf, 0xda, 0x53, 0x32, 0x4a, 0xab, 0xa4, 0x0c, 0xde, 0xdb, 0x51, 0xcf,
    0x49, 0x8a, 0x02, 0x1a, 0xb4, 0xa3, 0x79, 0xd4, 0x8a, 0xb8, 0x8d, 0xa9, 0x3d, 0x2f, 0x52, 0x68,
    0x06, 0x95, 0xe4, 0xea, 0x14, 0x6e, 0x93, 0x48, 0x23, 0x08, 0x60, 0xdb, 0xab, 0x7c, 0xd8, 0x51,
    0x57, 0x83, 0xcf, 0xb8, 0x9b, 0x40, 0x10, 0x32, 0x72, 0xbf, 0xc1, 0x00, 0x3e, 0xf5, 0x18, 0x5f,
    0x3e, 0xc4, 0x3c, 0x00, 0x5c, 0x00, 0x90, 0xc5, 0xe5, 0xa9, 0x4a, 0xc4, 0xce, 0x8d, 0xd9, 0x09,
    0xca, 0x0e, 0xa1, 0x0b, 0x6a, 0xc2, 0x7e, 0x66, 0x1d, 0xf9, 0x78, 0x95
};

static const BYTE g_XmssSigSha2_10_512[] = {
    0x00, 0x00, 0x00, 0x01, 0xce, 0xf4, 0xb6, 0x74, 0x73, 0xb1, 0x45, 0xb0, 0xca, 0xb1, 0x42, 0xd7, 0xb8, 0x2c, 0x7a, 0x94, 0xde, 0x4c, 0x54, 0x3f, 0x21, 0x01, 0x73, 0x5e, 0x9a, 0x89, 0x5f, 0x34,
    0x4c, 0xe5, 0xa6, 0x65, 0xf4, 0x14, 0x7e, 0xda, 0xc1, 0xd2, 0x82, 0x37, 0xc3, 0x8c, 0xfb, 0x8e, 0xc5, 0x12, 0x70, 0xcf, 0x53, 0xd8, 0x39, 0x90, 0xdd, 0x61, 0xe0, 0xea, 0x12, 0xeb, 0x58, 0x8b,
    0xc5, 0x65, 0x1b, 0x40, 0xbd, 0x49, 0x22, 0x0a, 0x0d, 0xce, 0xb6, 0x7d, 0xf1, 0x3f, 0xed, 0xe0, 0x04, 0xe8, 0xbd, 0x37, 0x41, 0x2c, 0x6a, 0xd8, 0xa9, 0x7c, 0xd4, 0xd8, 0xb9, 0x85, 0x2c, 0x3f,
    0x3a, 0x62, 0x91, 0x73, 0x94, 0x8e, 0x6f, 0xb2, 0xdc, 0x44, 0xb9, 0x6a, 0x30, 0xa2, 0xb4, 0x05, 0xd4, 0x4d, 0x59, 0xf7, 0x74, 0xb8, 0xca, 0x7a, 0x7b, 0xaa, 0xca, 0x2b, 0x63, 0xbd, 0xf5, 0xe2,
    0x46, 0x84, 0x65, 0xcb, 0x63, 0x4b, 0xef, 0x6c, 0x71, 0xb1, 0xde, 0x00, 0xc4, 0xe9, 0x91, 0x92, 0xd5, 0x82, 0x24, 0xf5, 0xd3, 0x91, 0xaf, 0xc1, 0x38, 0xf8, 0x07, 0x50, 0x62, 0x5c, 0xa4, 0x4e,
    0x8b, 0x5d, 0x54, 0x1a, 0x3e, 0x86, 0xfb, 0x1b, 0xb6, 0xef, 0xe4, 0xcf, 0x76, 0xa8, 0x8b, 0x7c, 0xea, 0xbe, 0x57, 0x63, 0x9f, 0xa3, 0x72, 0xcf, 0x56, 0x49, 0x74, 0xcb, 0x03, 0xdb, 0x12, 0x63,
    0x06, 0x5b, 0x87, 0xa8, 0xcc, 0x9b, 0xce, 0xc9, 0xe2, 0xae, 0xf2, 0xa6, 0xa3, 0x86, 0x86, 0x69, 0xc7, 0x5a, 0x79, 0x42, 0xff, 0x66, 0x48, 0xee, 0x06, 0xe3, 0xbf, 0x58, 0x96, 0xf9, 0xba, 0xaa,
    0x89, 0xe7, 0x52, 0x15, 0x00, 0x37, 0xaa, 0xa1, 0xc3, 0x2a, 0x69, 0x5c, 0x61, 0xcd, 0xa8, 0x52, 0x38, 0x6f, 0xcd, 0x5e, 0x23, 0x6a, 0x6d, 0x32, 0x05, 0x28, 0x7f, 0x04, 0x56, 0x7a, 0xcd, 0x18,
    0xcb, 0x11, 0x4c, 0xe1, 0x09, 0xf3, 0x33, 0xb0, 0x4d, 0xfd, 0x30, 0x26, 0x3c, 0xae, 0x38, 0x28, 0x84, 0x9d, 0x2b, 0xfe, 0xa3, 0x9b, 0x92, 0x6c, 0xce, 0xc0, 0xd9, 0x61, 0x80, 0xab, 0x90, 0x89,
    0xf3, 0xe5, 0xf0, 0x16, 0x8e, 0x52, 0xd3, 0xb7, 0x66, 0xe5, 0x9d, 0xc8, 0xa5, 0x1c, 0x1f, 0x94, 0x01, 0xbf, 0x27, 0x8c, 0x1e, 0x12, 0xe3, 0x52, 0xe3, 0xde, 0xaa, 0xb7, 0x5e, 0x51, 0xa7, 0xd6,
    0xde, 0xe1, 0x45, 0x5a, 0xfe, 0x94, 0x2e, 0x48, 0x6d, 0x7b, 0xfa, 0x2c, 0x07, 0x61, 0xc3, 0x29, 0xe9, 0x4e, 0x93, 0xd3, 0xd8, 0x6a, 0xc2, 0x9f, 0x96, 0xdb, 0xab, 0x47, 0x9e, 0xae, 0x8a, 0xd3,
    0x1c, 0x65, 0x82, 0x09, 0x4d, 0x12, 0xf7, 0x19, 0xed, 0x69, 0xce, 0x1e, 0xae, 0xbb, 0x80, 0xfe, 0x0d, 0xaa, 0x25, 0x99, 0x75, 0x46, 0x4f, 0xb4, 0xc4, 0xd7, 0x35, 0x4e, 0x1c, 0xfc, 0xed, 0xe2,
    0xf7, 0x06, 0x69, 0x37, 0xb9, 0x71, 0x4f, 0x3c, 0x77, 0xfa, 0x7c, 0x61, 0xdf, 0xe3, 0x7e, 0xc1, 0x60, 0x97, 0x52, 0xde, 0xe1, 0x5c, 0x6b, 0xdb, 0xd2, 0xb2, 0xba, 0xb4, 0xcd, 0xab, 0x7f, 0x6b,
    0x8a, 0xbb, 0xb2, 0x3e, 0xf1, 0x31, 0xbe, 0x57, 0x64, 0xe7, 0x22, 0x9f, 0x55, 0x52, 0xf4, 0x78, 0xd7, 0xf5, 0x84, 0x6d, 0x67, 0x6a, 0x60, 0x69, 0xe1, 0x5e, 0x22, 0x10, 0x1d, 0x22, 0xe8, 0xc3,
    0xbd, 0xaf, 0x77, 0x76, 0x9b, 0x84, 0x4c, 0xa3, 0xfd, 0x22, 0x9d, 0x78, 0xc6, 0xcf, 0x9c, 0xd2, 0xfd, 0xcc, 0x3c, 0x5a, 0xdf, 0x9b, 0xb2, 0x8f, 0x55, 0x8e, 0xbc, 0x70, 0xd1, 0x0f, 0x7c, 0x5a,
    0x90, 0x11, 0xe7, 0xc3, 0x3d, 0x42, 0xf7, 0xc1, 0x38, 0x84, 0x9d, 0x03, 0x07, 0x1c, 0xc1, 0x1e, 0xf1, 0x4d, 0x6d, 0x8b, 0xff, 0x7f, 0x3e, 0x87, 0xe4, 0x18, 0x3b, 0x5a, 0xda, 0xe8, 0x48, 0x57,
    0x03, 0x6b, 0x1b, 0xe6, 0xe1, 0x4d, 0x61, 0x59, 0x6d, 0xcc, 0xbe, 0x05, 0x6c, 0xdf, 0x39, 0x6f, 0xff, 0xda, 0xe7, 0x32, 0xdf, 0x38, 0x27, 0x47, 0x8e, 0xbd, 0xd5, 0x08, 0x02, 0xff, 0x9c, 0x14,
    0x8c, 0xd2, 0x8d, 0x30, 0xa5, 0x52, 0x95, 0x8e, 0x5b, 0x55, 0x00, 0x48, 0x96, 0xdb, 0x28, 0x6a, 0x3c, 0x8d, 0x69, 0x26, 0x34, 0x01, 0xb7, 0xe0, 0xcc, 0xed, 0x1f, 0xca, 0xc7, 0x08, 0xbe, 0x0b,
    0xb7, 0x76, 0x86, 0x6a, 0xe6, 0xb4, 0xb0, 0x3f, 0xf4, 0x6a, 0x62, 0x5a, 0x46, 0x70, 0x66, 0x4a, 0x2e, 0x02, 0xb6, 0x3f, 0x5f, 0x2a, 0xb8, 0x69, 0x3b, 0x4c, 0xf3, 0x88, 0x9b, 0x9f, 0x31, 0x56,
    0x8e, 0xb2, 0x92, 0x68, 0xaa, 0xc6, 0xc1, 0x6c, 0xe9, 0xc4, 0x12, 0x15, 0xc0, 0xb9, 0xd8, 0x2b, 0x4b, 0x12, 0xe1, 0xbf, 0x79, 0x73, 0x7f, 0x80, 0x57, 0x68, 0x78, 0xa4, 0x33, 0x01, 0xea, 0x4b,
    0xe5, 0x4a, 0x7e, 0x91, 0x5c, 0x89, 0xcd, 0x6f, 0xee, 0x00, 0x52, 0x7a, 0xd3, 0xd4, 0xb1, 0xdc, 0x4e, 0x62, 0xf5, 0x7e, 0x12, 0x7f, 0x01, 0x5c, 0x62, 0x2e, 0x99, 0xa5, 0x56, 0x8c, 0x7a, 0x56,
    0x9b, 0xb8, 0x47, 0x90, 0x06, 0x41, 0xfe, 0x93, 0xd7, 0xb8, 0x67, 0xf5, 0x65, 0x78, 0xc2, 0xab, 0xf7, 0xb1, 0xd9, 0x8c, 0x6b, 0xdf, 0xc4, 0x31, 0xa3, 0x19, 0xe2, 0xaf, 0x03, 0xf9, 0x16, 0xa7,
    0x96, 0xd8, 0x3d, 0x19, 0x22, 0x6a, 0x72, 0x89, 0x8e, 0xc3, 0xce, 0xea, 0x14, 0xca, 0x43, 0x14, 0x05, 0x66, 0xe6, 0x9f, 0xf7, 0xc7, 0xc8, 0x8c, 0x91, 0x01, 0xfc, 0xc0, 0x15, 0x68, 0x33, 0x84,
    0x29, 0xb0, 0x7d, 0x73, 0x83, 0x6c, 0x5f, 0xac, 0x3b, 0xd8, 0xf3, 0x82, 0x3a, 0x3f, 0x1b, 0x71, 0xd9, 0xdb, 0x90, 0xe2, 0x86, 0x45, 0x6b, 0x28, 0x03, 0xff, 0x48, 0x6d, 0x0c, 0x9e, 0x6b, 0x93,
    0xd0, 0xf7, 0xd6, 0xb6, 0xf6, 0xef, 0x57, 0x90, 0xfc, 0x5a, 0x26, 0xbc, 0x1d, 0x05, 0xfc, 0x2a, 0xd1, 0x8e, 0x56, 0xe8, 0xee, 0xdd, 0xb1, 0x37, 0xe3, 0x7e, 0xe1, 0x24, 0x99, 0xd9, 0x61, 0xf6,
    0x05, 0x34, 0x49, 0x67, 0x8e, 0xed, 0x1d, 0xa5, 0xe1, 0x77, 0x10, 0x2a, 0xcc, 0x81, 0x5e, 0x03, 0x56, 0x89, 0xae, 0xd0, 0xfa, 0x60, 0x3f, 0x6d, 0x30, 0x12, 0x58, 0xb1, 0x5c, 0xde, 0x07, 0xd8,
    0xda, 0xf7, 0x83, 0xec, 0x62, 0x16, 0x0b, 0x89, 0xd0, 0x3a, 0x9d, 0x38, 0x4f, 0xf4, 0xcc, 0x0d, 0x86, 0x94, 0xf4, 0x96, 0xc2, 0x48, 0x3f, 0xb6, 0x36, 0xc0, 0xcd, 0xf4, 0xa5, 0x5a, 0x6e, 0x23,
    0xce, 0xd4, 0x81, 0x7a, 0xd1, 0xe5, 0xd6, 0x2f, 0xf7, 0xcd, 0xcf, 0x0d, 0xa2, 0x0c, 0x5e, 0xe5, 0x59, 0xec, 0x10, 0xe5, 0x28, 0x4d, 0x47, 0xb7, 0xc4, 0xb8, 0xbf, 0x1b, 0x76, 0xa8, 0x3a, 0x2e,
    0xca, 0xd6, 0x1a, 0x0e, 0x16, 0x71, 0xc3, 0x09, 0x99, 0x8e, 0xa5, 0xfb, 0x13, 0xf6, 0xc9, 0x28, 0x45, 0x3a, 0x8f, 0x1e, 0xfc, 0x52, 0xa2, 0x33, 0x6e, 0x4b, 0x9d, 0xcc, 0xf8, 0x96, 0xff, 0x6a,
    0xd9, 0x4e, 0x74, 0x29, 0xb5, 0x28, 0xaf, 0x99, 0xb1, 0x17, 0x63, 0xc7, 0xe7, 0xaf, 0x77, 0xca, 0xb1, 0x67, 0x3e, 0x5e, 0xf3, 0x8f, 0x00, 0x33, 0xb5, 0x2c, 0x05, 0xf7, 0x1b, 0x1a, 0x3f, 0x2b,
    0xf6, 0xd5, 0xc5, 0x80, 0xef, 0x46, 0xc4, 0x50, 0x2f, 0xc8, 0xff, 0x8b, 0xe1, 0x05, 0x53, 0xf1, 0x4b, 0x77, 0x5a, 0xd8, 0x2b, 0x35, 0x44, 0xdc, 0x73, 0x88, 0xf2, 0x2b, 0x34, 0x0b, 0xa6, 0x6d,
    0x24, 0x7d, 0x33, 0x1b, 0xdd, 0x12, 0xf0, 0x6f, 0xb9, 0x81, 0xc3, 0x18, 0x3d, 0x41, 0x2d, 0xaa, 0xf2, 0x1f, 0xa0, 0x94, 0x4c, 0x8a, 0x09, 0x83, 0xfb, 0xcf, 0x3b, 0x19, 0x73, 0xff, 0xa9, 0x1d,
    0x0a, 0xad, 0xbd, 0x2f, 0xcb, 0x34, 0xc3, 0xda, 0xaa, 0x0d, 0x97, 0xd8, 0x6b, 0x0f, 0x91, 0x7f, 0x1c, 0x2f, 0xbd, 0xb9, 0xfd, 0x2f, 0x32, 0x9d, 0xf0, 0x40, 0x26, 0x48, 0xf2, 0xbe, 0x35, 0x9f,
    0x32, 0xdd, 0x10, 0x14, 0x8f, 0x43, 0xd9, 0x23, 0x0b, 0x4c, 0x54, 0xfb, 0x92, 0xcb, 0x95, 0x1f, 0xfa, 0x83, 0xdb, 0x40, 0x91, 0xa3, 0xcc, 0xe8, 0x4f, 0x1a, 0x50, 0xee, 0x2e, 0x5c, 0x14, 0x9b,
    0xc5, 0x34, 0xd6, 0x65, 0x67, 0x5b, 0x66, 0x58, 0xde, 0xa4, 0x6c, 0x08, 0x91, 0x3b, 0xf4, 0x14, 0x9b, 0xbc, 0xb7, 0x36, 0x77, 0x1a, 0x4c, 0x7c, 0x2d, 0xf1, 0x66, 0x97, 0xc3, 0x14, 0x0a, 0x2d,
    0x57, 0x0d, 0x3e, 0xe6, 0x91, 0xd4, 0x84, 0xdd, 0x13, 0xae, 0xe8, 0xee, 0xd6, 0xc6, 0x8e, 0x48, 0x47, 0x77, 0x23, 0x29, 0xca, 0xb5, 0xb5, 0xf5, 0x56, 0x91, 0x2d, 0xf4, 0x51, 0x81, 0x12, 0xed,
    0x4d, 0x5e, 0x14, 0x1b, 0x51, 0xfd, 0xa7, 0x62, 0x27, 0x87, 0x40, 0xcf, 0x59, 0x10, 0xd0, 0x2a, 0x3c, 0x83, 0x56, 0xd6, 0xe5, 0x86, 0xdf, 0x56, 0x05, 0x21, 0xbd, 0xee, 0x94, 0x8f, 0xb9, 0xb2,
    0x89, 0x94, 0xb7, 0x54, 0xa3, 0xd9, 0x0a, 0x3f, 0x97, 0xb3, 0x0d, 0xde, 0x5e, 0x3b, 0x51, 0x52, 0x83, 0x10, 0x3d, 0xa9, 0x5e, 0x02, 0xe4, 0x90, 0xf6, 0xbc, 0x19, 0x71, 0x26, 0xb8, 0xe3, 0xbe,
    0x80, 0xbe, 0x45, 0x66, 0xea, 0xc3, 0xa3, 0x56, 0xcc, 0x6a, 0x64, 0x76, 0x54, 0x10, 0x4a, 0xff, 0x2c, 0x54, 0x05, 0x06, 0x73, 0x41, 0x0c, 0x4b, 0x53, 0xf0, 0x1e, 0x10, 0x66, 0x41, 0x5c, 0xa8,
    0x97, 0xc8, 0x1d, 0xef, 0x7a, 0x0d, 0xa2, 0x1e, 0xe6, 0xb1, 0x14, 0x0f, 0x6d, 0x28, 0xb8, 0x3a, 0xb2, 0x7d, 0x36, 0x57, 0x8f, 0x58, 0x03, 0xfd, 0x37, 0x87, 0x6b, 0x94, 0x33, 0x68, 0xbd, 0x6a,
    0x2d, 0xd2, 0xcc, 0x06, 0xf3, 0xf8, 0xdb, 0xfd, 0x0e, 0x79, 0xca, 0x63, 0xf1, 0x84, 0x5f, 0x1f, 0x3c, 0x23, 0x73, 0x1e, 0xc8, 0xf9, 0x10, 0xc7, 0xd5, 0x14, 0x61, 0xc5, 0x24, 0xf0, 0x2e, 0xf9,
    0x22, 0x5f, 0x06, 0x71, 0x2c, 0xc0, 0x81, 0x23, 0xb5, 0x16, 0xf5, 0x1e, 0x3a, 0x07, 0x79, 0xaa, 0xe8, 0x87, 0x3d, 0xed, 0xb0, 0x9b, 0xaf, 0x74, 0x20, 0xb1, 0x44, 0x85, 0x0c, 0x8f, 0x4c, 0x62,
    0xe6, 0x9a, 0xda, 0x94, 0x53, 0xb5, 0x35, 0xe3, 0x3b, 0x9f, 0xdb, 0x77, 0x02, 0x15, 0xe5, 0x64, 0x15, 0x07, 0x3e, 0xe2, 0xe9, 0x49, 0x8b, 0x15, 0xd1, 0xe8, 0x55, 0x6f, 0xfb, 0x9a, 0x0d, 0xc2,
    0x07, 0x9a, 0xfb, 0xd8, 0xe2, 0x55, 0x0e, 0x19, 0xa4, 0xfe, 0xef, 0x5d, 0x90, 0x5d, 0x37, 0x0a, 0x36, 0xf6, 0x58, 0xc0, 0xf3, 0xec, 0x5e, 0xf9, 0xc3, 0xe1, 0x01, 0x5c, 0x94, 0x9c, 0xf3, 0xa7,
    0xf4, 0xa7, 0x8b, 0xa6, 0xdf, 0x39, 0xd4, 0xeb, 0x34, 0x66, 0x22, 0xc3, 0x7c, 0x0d, 0xd6, 0x08, 0x00, 0x07, 0x3a, 0x8d, 0xfe, 0xc7, 0x39, 0x61, 0x7f, 0x94, 0x81, 0xcb, 0x86, 0x59, 0x61, 0xe8,
    0x03, 0x23, 0xd1, 0x3c, 0xaf, 0x99, 0x85, 0x25, 0x82, 0xe9, 0xeb, 0xb9, 0x3d, 0xe9, 0xbf, 0x2b, 0x74, 0xb0, 0xf9, 0x35, 0xbf, 0x83, 0xad, 0x96, 0x2b, 0x1f, 0xd5, 0x7f, 0x33, 0xce, 0x82, 0xdb,
    0x31, 0xc0, 0xbe, 0x6e, 0xad, 0x7f, 0x71, 0xc9, 0x18, 0x94, 0x84, 0x5a, 0xf6, 0x9c, 0x50, 0x72, 0x18, 0xac, 0xc4, 0xfa, 0x50, 0xf7, 0xff, 0xe7, 0x26, 0x36, 0xde, 0x95, 0xba, 0x81, 0x1f, 0xf9,
    0xbd, 0xcb, 0xef, 0xd4, 0xd7, 0x9e, 0xc0, 0x87, 0x4d, 0xea, 0xc3, 0x96, 0xe8, 0xb6, 0x85, 0x3d, 0x82, 0xbb, 0xb0, 0x7a, 0xbd, 0x3d, 0x4d, 0xc3, 0xdf, 0x12, 0xc8, 0x33, 0x82, 0x76, 0x76, 0xa2,
    0x74, 0x01, 0x50, 0x6b, 0x7c, 0xe6, 0x6c, 0x63, 0xa7, 0x53, 0x9b, 0x1a, 0xa2, 0x09, 0xcc, 0x4e, 0x92, 0xe0, 0xd9, 0x5c, 0xe5, 0x46, 0x29, 0xd1, 0xd9, 0xf0, 0xd5, 0x3b, 0xc1, 0xfe, 0xd1, 0x2c,
    0x42, 0x8b, 0x6b, 0x79, 0x6f, 0xdf, 0xfd, 0x5a, 0xb2, 0x5e, 0xb9, 0x47, 0x2b, 0x1e, 0x85, 0x40, 0x08, 0xc4, 0x7f, 0x65, 0xe4, 0xa5, 0x4d, 0x6b, 0x00, 0x63, 0xc3, 0x42, 0x46, 0xb0, 0x5d, 0xfc,
    0x68, 0xa5, 0x17, 0xc1, 0x15, 0x3e, 0x6f, 0x90, 0x9c, 0x3e, 0x19, 0xa5, 0x80, 0xc3, 0x45, 0xf8, 0xdf, 0x32, 0xda, 0xd1, 0xff, 0x7a, 0x86, 0x0e, 0xbd, 0x10, 0xf0, 0x91, 0x8a, 0x04, 0x6e, 0xd5,
    0x27, 0xf2, 0x82, 0x43, 0xfa, 0xf6, 0xc1, 0x47, 0x18, 0x78, 0x23, 0x09, 0x3b, 0x40, 0xd9, 0x6e, 0xa7, 0x12, 0x34, 0x01, 0x58, 0x65, 0x85, 0xd6, 0x5d, 0x1c, 0xd7, 0x7c, 0x90, 0x08, 0x22, 0xc0,
    0x12, 0xfa, 0xbb, 0x76, 0xcc, 0x1d, 0xb5, 0x6d, 0x14, 0xe2, 0xff, 0x2a, 0xac, 0x88, 0x22, 0x45, 0x02, 0x39, 0xda, 0xef, 0xad, 0xd8, 0x8e, 0x1e, 0x18, 0x3d, 0x14, 0x04, 0xd1, 0x80, 0x6b, 0xa2,
    0x6f, 0x7f, 0xad, 0x93, 0xf5, 0xcc, 0xb1, 0x4e, 0x3a, 0x5c, 0x80, 0x0b, 0xac, 0x67, 0xc2, 0xbc, 0x0b, 0xec, 0xd3, 0x9e, 0x90, 0x04, 0x40, 0x13, 0xe3, 0xd1, 0x7d, 0x81, 0x49, 0xce, 0xa3, 0xa1,
    0xc7, 0x71, 0x70, 0x48, 0x84, 0x1c, 0x2f, 0xcb, 0xb6, 0x52, 0x3c, 0x8a, 0x6f, 0x76, 0x92, 0x4d, 0x12, 0x57, 0x1c, 0x66, 0x11, 0xab, 0x0b, 0xc8, 0x16, 0xe0, 0x42, 0xa7, 0x6e, 0xc2, 0xfe, 0x43,
    0xfb, 0x75, 0x8b, 0x71, 0xb2, 0x5f, 0x4b, 0xa2, 0x1d, 0xc2, 0xcb, 0x55, 0x01, 0xa5, 0xbb, 0xee, 0x7d, 0x44, 0x35, 0xe4, 0x75, 0x42, 0xdb, 0xdb, 0x3f, 0x70, 0x18, 0xc3, 0x74, 0xde, 0x79, 0x8f,
    0x9b, 0x6e, 0xb8, 0xc0, 0xb4, 0xce, 0x95, 0x76, 0xd8, 0xdd, 0xef, 0x0b, 0x67, 0x51, 0xfc, 0x29, 0x44, 0x2e, 0x43, 0xe2, 0xc0, 0xd4, 0xb5, 0x9d, 0x72, 0xd1, 0x43, 0x43, 0x91, 0xab, 0xd0, 0xd7,
    0x57, 0x51, 0x9b, 0x81, 0xbb, 0x75, 0xc7, 0xb7, 0x0f, 0x0a, 0x52, 0x12, 0x95, 0xb5, 0x1a, 0xca, 0x15, 0xb0, 0x36, 0xce, 0xf0, 0x05, 0x18, 0x8f, 0x1b, 0xb1, 0xff, 0x0f, 0xe2, 0x7f, 0xaf, 0x52,
    0x5e, 0xa4, 0xe2, 0x36, 0xa0, 0x26, 0xb0, 0x13, 0x9f, 0xa7, 0xb5, 0x53, 0xbd, 0xe8, 0x3f, 0xb4, 0x63, 0xf1, 0x40, 0x4c, 0x09, 0xef, 0xc7, 0x0a, 0xbc, 0x81, 0xa0, 0x73, 0xd5, 0x8c, 0x3f, 0xaf,
    0x06, 0xe8, 0xa3, 0x69, 0x17, 0x2c, 0x8e, 0x26, 0xb7, 0xe9, 0xf6, 0xd2, 0x4d, 0x7d, 0xb4, 0x23, 0x38, 0x72, 0x64, 0x68, 0x09, 0x14, 0x40, 0x2b, 0xbf, 0x54, 0x4b, 0x14, 0xb5, 0x67, 0x7a, 0xf6,
    0xfe, 0xb9, 0x85, 0x0b, 0x31, 0xeb, 0x03, 0x0e, 0x82, 0xe3, 0xfa, 0x6c, 0xdf, 0x96, 0x07, 0x95, 0xaa, 0xa8, 0x9b, 0xa1, 0x76, 0x58, 0xfd, 0x21, 0x2b, 0xeb, 0x35, 0x92, 0x0f, 0xfb, 0x9f, 0xb6,
    0x26, 0x5d, 0x7d, 0x43, 0x73, 0x21, 0xb8, 0x90, 0x43, 0x24, 0x43, 0x10, 0x5d, 0xf1, 0x19, 0x3b, 0x02, 0x02, 0xe2, 0xc0, 0xec, 0xc6, 0xbe, 0x09, 0x24, 0x06, 0xbc, 0x11, 0xdc, 0x18, 0x0d, 0x52,
    0x8c, 0xe0, 0x33, 0x02, 0xe0, 0x38, 0x32, 0xbd, 0x7d, 0x91, 0x74, 0x83, 0x82, 0x90, 0x84, 0x38, 0x51, 0x36, 0xaa, 0x2f, 0x90, 0xc6, 0x06, 0x58, 0x4a, 0x2c, 0x22, 0xb8, 0xb0, 0xfb, 0xfc, 0x17,
    0x1f, 0x6f, 0x0f, 0xff, 0xe6, 0xa7, 0x51, 0x07, 0xd8, 0x44, 0x57, 0xad, 0xf8, 0xc1, 0xe5, 0x0c, 0xbf, 0x6c, 0xd0, 0xa1, 0xaa, 0xd6, 0x52, 0xf3, 0x65, 0xbd, 0x28, 0x1b, 0xe3, 0x7c, 0x91, 0xcd,
    0x71, 0x95, 0x11, 0x2e, 0x26, 0x38, 0x7a, 0xd7, 0x3e, 0xbb, 0xdb, 0x22, 0x71, 0x18, 0x39, 0x2d, 0x72, 0xbb, 0x06, 0x70, 0xcf, 0x7b, 0xbe, 0xc3, 0x85, 0x18, 0x29, 0x89, 0xdf, 0xfb, 0x8e, 0x29,
    0xf5, 0x2a, 0x6d, 0x18, 0x1a, 0x58, 0xf1, 0x15, 0x5c, 0xac, 0xc1, 0xa0, 0xa0, 0x2e, 0xbd, 0x2e, 0xbf, 0x00, 0xd6, 0xdd, 0xe2, 0xa8, 0x03, 0x77, 0xe8, 0x01, 0x49, 0x9b, 0x6b, 0x63, 0x82, 0x3f,
    0x68, 0x71, 0x7d, 0xde, 0x52, 0xad, 0x42, 0xe7, 0xf4, 0x70, 0xdf, 0x0b, 0x6f, 0x86, 0x64, 0x9d, 0x1b, 0xdc, 0x0f, 0x1e, 0x1b, 0x08, 0xc0, 0xa6, 0xfa, 0xad, 0xbe, 0x57, 0xf5, 0xd2, 0x17, 0xea,
    0x87, 0x7d, 0x96, 0x35, 0xac, 0x0e, 0xb4, 0x4e, 0xbb, 0x37, 0x5d, 0x77, 0x42, 0x49, 0x79, 0x47, 0xd0, 0xd3, 0x00, 0x2d, 0xd9, 0xc2, 0x69, 0x3f, 0x64, 0x4f, 0x85, 0xb1, 0xcb, 0x9b, 0xde, 0x72,
    0xa8, 0xee, 0x60, 0xdf, 0xcc, 0x12, 0xd3, 0xed, 0x33, 0xf4, 0x67, 0x7b, 0x84, 0xb0, 0x9f, 0x2a, 0xa1, 0x9e, 0xfb, 0xaf, 0xab, 0xd5, 0xae, 0x88, 0x45, 0xb9, 0x8a, 0x8c, 0xc3, 0x88, 0xa2, 0x96,
    0xac, 0x3c, 0xb7, 0xbc, 0x15, 0x1a, 0x8e, 0x9c, 0xc2, 0xc0, 0x17, 0x77, 0xfa, 0xf3, 0xff, 0x7a, 0x4f, 0xfb, 0xe9, 0x1f, 0xb7, 0xe0, 0x86, 0xf4, 0x2b, 0x70, 0xf5, 0x2c, 0xbd, 0x58, 0x79, 0xa9,
    0x84, 0x59, 0x9c, 0x44, 0x81, 0xde, 0x15, 0xd8, 0x9f, 0x67, 0xbb, 0x04, 0xdc, 0xf8, 0x94, 0x8e, 0x69, 0x6d, 0x93, 0x82, 0x83, 0x67, 0x14, 0x35, 0x2a, 0xde, 0xa0, 0x4d, 0x42, 0x20, 0x45, 0x6c,
    0x1c, 0xe6, 0xd9, 0x62, 0xef, 0x8c, 0x71, 0x68, 0xd9, 0x08, 0x45, 0xf7, 0x25, 0x75, 0x0a, 0xa6, 0x28, 0x94, 0x02, 0xcd, 0x60, 0xf2, 0xa8, 0x42, 0x8c, 0xd7, 0xf6, 0xa6, 0x60, 0x85, 0xd0, 0x0e,
    0x0e, 0xc2, 0x8c, 0x27, 0x9e, 0x11, 0xdc, 0x77, 0x5c, 0x00, 0x5f, 0xd0, 0x3a, 0x07, 0xa5, 0xdb, 0x87, 0xf5, 0xc7, 0x26, 0x98, 0x5a, 0x14, 0x20, 0xc6, 0xc6, 0x2d, 0x8d, 0xe2, 0x6d, 0xc9, 0x24,
    0x16, 0xed, 0xa0, 0x48, 0xeb, 0xc5, 0x9d, 0x77, 0xb7, 0x99, 0x71, 0x0d, 0xe2, 0x53, 0x3a, 0x7b, 0xd5, 0xf2, 0x1d, 0x7c, 0x87, 0xfa, 0xf8, 0xdf, 0x93, 0x6b, 0xd3, 0xdd, 0x17, 0x4d, 0x43, 0xdc,
    0x82, 0xd5, 0xca, 0x46, 0x03, 0x42, 0xa6, 0xfa, 0xa7, 0xc6, 0x5c, 0xff, 0x0f, 0x92, 0x99, 0xe5, 0xec, 0x21, 0x38, 0x7d, 0x96, 0x3f, 0xe4, 0xd2, 0xd5, 0xbc, 0x1a, 0x3c, 0x91, 0x03, 0xd3, 0x5c,
    0xce, 0x29, 0x77, 0x26, 0x5a, 0x65, 0xd5, 0x3f, 0x07, 0x1c, 0x65, 0x40, 0x46, 0x1f, 0x28, 0x18, 0x4c, 0x70, 0xba, 0x72, 0xb8, 0x20, 0xf7, 0x87, 0x83, 0x7b, 0x53, 0x7a, 0xdf, 0xd6, 0xb3, 0x28,
    0xc6, 0xbf, 0xc9, 0x38, 0x33, 0xa2, 0xe0, 0x43, 0xb2, 0xc0, 0x93, 0x99, 0x53, 0x16, 0x7b, 0x53, 0x55, 0x38, 0xf2, 0x27, 0xc9, 0x18, 0x0a, 0x27, 0x35, 0xc6, 0x65, 0x62, 0x75, 0x72, 0xea, 0xe1,
    0x32, 0x10, 0x68, 0xad, 0xe2, 0xf3, 0x84, 0x9e, 0x9d, 0xe9, 0xbf, 0x65, 0xbd, 0xd5, 0xf9, 0x87, 0x9c, 0xda, 0x61, 0x2b, 0x6a, 0x8b, 0x99, 0x32, 0x32, 0x00, 0x45, 0xf6, 0x8a, 0xd7, 0x7d, 0x89,
    0x8d, 0xee, 0x62, 0x8e, 0xdc, 0x72, 0xe3, 0xf9, 0xe0, 0x08, 0xe1, 0x12, 0x18, 0xbe, 0x9f, 0x5d, 0xc1, 0xd1, 0x0a, 0x18, 0x08, 0xa7, 0xb9, 0x28, 0xe2, 0xf4, 0x99, 0x9f, 0xa4, 0x54, 0x7f, 0x7d,
    0xca, 0xd2, 0xcc, 0xde, 0x40, 0xf8, 0xbc, 0xad, 0x1d, 0x14, 0x03, 0xa4, 0xb3, 0x8d, 0x6d, 0x6f, 0xef, 0x84, 0xec, 0x9a, 0x9d, 0x03, 0x9c, 0x52, 0x41, 0xc5, 0xd0, 0x57, 0x60, 0x00, 0x09, 0xef,
    0xb7, 0xbb, 0xf9, 0x6f, 0xf6, 0x80, 0x98, 0xe0, 0xbc, 0xeb, 0xa7, 0x93, 0xd1, 0x2e, 0x7d, 0x0e, 0x73, 0x2b, 0x69, 0xdd, 0x6f, 0x17, 0x5b, 0x25, 0x89, 0xb9, 0x06, 0x9f, 0x1f, 0xfe, 0x5e, 0x82,
    0x4d, 0x68, 0x21, 0x80, 0x30, 0x33, 0x76, 0x3f, 0x72, 0xe6, 0x94, 0xc0, 0x68, 0x3a, 0xdb, 0x7b, 0x3e, 0xc7, 0x91, 0x6f, 0x17, 0x17, 0x6b, 0xb9, 0xb4, 0x29, 0xe6, 0x70, 0x62, 0xea, 0x73, 0x25,
    0x98, 0x38, 0x7c, 0x10, 0x2b, 0x90, 0xbe, 0x88, 0x20, 0x41, 0xac, 0x96, 0x80, 0x70, 0x0b, 0x2b, 0x1b, 0xfe, 0xad, 0x3b, 0x8b, 0xaf, 0xd5, 0xa8, 0xa0, 0x44, 0xc6, 0x43, 0xa9, 0xe9, 0xbd, 0x31,
    0x09, 0x71, 0xa7, 0x03, 0x2c, 0x16, 0x05, 0xcc, 0x9d, 0x6d, 0x59, 0xc1, 0x41, 0xb0, 0x78, 0xa5, 0x6e, 0x1c, 0xb6, 0xc3, 0x9b, 0xb0, 0xa2, 0xc4, 0xae, 0x48, 0x0d, 0x5b, 0x00, 0x35, 0x02, 0xf0,
    0x11, 0x88, 0x90, 0xec, 0x2e, 0x16, 0x60, 0xd0, 0x19, 0xa3, 0xe1, 0x07, 0x5d, 0x89, 0x50, 0xb0, 0xe5, 0xe9, 0xf2, 0x0f, 0xd7, 0xe3, 0xb9, 0x56, 0xdb, 0xb9, 0xfa, 0x20, 0xb0, 0x08, 0xc9, 0xf8,
    0x6d, 0xed, 0xa4, 0x1d, 0xa0, 0xdc, 0x47, 0xd4, 0xf2, 0xc6, 0x89, 0x44, 0x04, 0x30, 0x11, 0x66, 0x4f, 0xdd, 0xc4, 0xce, 0x65, 0x90, 0x23, 0x17, 0xef, 0x73, 0x76, 0x7a, 0xf3, 0xe2, 0x43, 0x55,
    0xdf, 0x0f, 0xd0, 0xec, 0x37, 0x5d, 0x18, 0x6b, 0x09, 0xa6, 0x7e, 0x66, 0x6d, 0xde, 0x5c, 0x1f, 0xbc, 0x48, 0x01, 0x72, 0xa3, 0x8e, 0x53, 0x2d, 0x62, 0x06, 0x6a, 0x84, 0x64, 0xb8, 0x49, 0x5b,
    0x16, 0x0a, 0x3e, 0xe1, 0x0b, 0x94, 0xe3, 0xe0, 0x55, 0xb9, 0x0f, 0x64, 0xe2, 0x9a, 0xae, 0x82, 0xef, 0xe4, 0xf4, 0x7c, 0x7a, 0xb8, 0x43, 0x1a, 0x5d, 0x3a, 0xc7, 0x83, 0x1c, 0x35, 0x23, 0xb0,
    0xc3, 0xb1, 0x93, 0x6b, 0xb1, 0x18, 0xd7, 0x15, 0xe7, 0x30, 0x77, 0x0a, 0xf0, 0xdc, 0xbc, 0x85, 0x6f, 0xca, 0x27, 0x75, 0x50, 0xd2, 0x9b, 0x78, 0xc2, 0x91, 0xee, 0xf6, 0x6d, 0x9b, 0x66, 0x90,
    0x9b, 0x11, 0x71, 0x8a, 0xdb, 0x5b, 0x42, 0x4e, 0x03, 0xdd, 0x55, 0xa7, 0xeb, 0x9d, 0x9b, 0x11, 0x5b, 0x7a, 0x05, 0x2f, 0xe1, 0xd5, 0xdd, 0xaf, 0xaa, 0x92, 0xf5, 0xa5, 0x59, 0x41, 0xf6, 0x10,
    0xe5, 0x29, 0x83, 0xa4, 0x92, 0x2e, 0x33, 0x28, 0xb8, 0x9d, 0x60, 0xc2, 0xc5, 0xa9, 0x1b, 0xe0, 0x3b, 0x79, 0x27, 0x21, 0xeb, 0xe5, 0xf0, 0x14, 0x7f, 0xc7, 0x53, 0xc6, 0xdf, 0xf4, 0xf3, 0x35,
    0xc1, 0xb6, 0x56, 0xa2, 0x61, 0xde, 0x2c, 0x6b, 0xb7, 0x59, 0x13, 0x5b, 0x29, 0xcb, 0xaf, 0x2b, 0x25, 0x06, 0x2a, 0x9e, 0xe7, 0x65, 0x5c, 0xbb, 0x3c, 0x2b, 0x1c, 0xbc, 0xe3, 0x15, 0xbf, 0xf7,
    0x40, 0x06, 0xca, 0xac, 0x6a, 0x9c, 0xc3, 0x07, 0x48, 0x87, 0xfc, 0x39, 0x23, 0x0b, 0x18, 0xe1, 0x86, 0x2b, 0x9f, 0xa2, 0xc2, 0xc0, 0x7b, 0x0e, 0x66, 0x21, 0xfc, 0xeb, 0x97, 0xbb, 0x9a, 0x6b,
    0x6e, 0x3c, 0x14, 0x5c, 0xa9, 0x0b, 0xa4, 0x2c, 0x93, 0x5f, 0x51, 0x73, 0xdd, 0x14, 0xe1, 0x2d, 0x3d, 0x92, 0x14, 0x07, 0x92, 0x66, 0x01, 0xe0, 0xa4, 0xcc, 0x90, 0xdf, 0x8b, 0xae, 0x00, 0x07,
    0x8e, 0xa5, 0xf1, 0x25, 0x0e, 0x47, 0x20, 0x06, 0xd5, 0x66, 0x7e, 0x17, 0x8f, 0xec, 0x9c, 0x6d, 0x3a, 0xae, 0x51, 0x87, 0x38, 0x39, 0x6f, 0x3f, 0x60, 0xf6, 0x89, 0x3b, 0x0e, 0xd1, 0x9e, 0xad,
    0xe4, 0x4b, 0xa3, 0x8b, 0x99, 0x86, 0xb3, 0x28, 0x78, 0xfd, 0x3d, 0xf1, 0xe1, 0xf9, 0x7b, 0xe0, 0x6c, 0x89, 0xe6, 0x7e, 0x50, 0x09, 0xa7, 0xb6, 0x32, 0x9d, 0xfb, 0x96, 0xa1, 0x43, 0xad, 0xd3,
    0x65, 0xc2, 0xae, 0xc0, 0xa8, 0x29, 0x95, 0x05, 0x44, 0x3c, 0x4f, 0x39, 0x1c, 0x51, 0x7e, 0xe6, 0x7c, 0x17, 0x6c, 0xcc, 0xad, 0x47, 0x33, 0xd1, 0x19, 0xa1, 0x6d, 0x5c, 0x81, 0x97, 0xef, 0x14,
    0x64, 0x22, 0x40, 0x22, 0x30, 0x00, 0x5a, 0xbd, 0xb2, 0x91, 0xc0, 0xd0, 0x84, 0x8c, 0x6e, 0x2f, 0xa4, 0x15, 0xd7, 0x3f, 0x07, 0x09, 0xa9, 0x14, 0x34, 0x09, 0xdb, 0x26, 0x8e, 0x69, 0xf3, 0x61,
    0x36, 0xef, 0x49, 0x6c, 0x66, 0x42, 0x13, 0x2d, 0x3a, 0xc0, 0x2a, 0xa0, 0xe3, 0xa7, 0x57, 0xea, 0x1e, 0xba, 0xb4, 0x94, 0xc3, 0x7b, 0x18, 0x0d, 0x03, 0x36, 0xe9, 0x72, 0x51, 0xcb, 0x87, 0x9e,
    0xd4, 0x8f, 0x06, 0x84, 0x3b, 0xd1, 0x4a, 0xb1, 0x83, 0xa4, 0x57, 0xa7, 0x19, 0x46, 0x6f, 0x95, 0x14, 0xcd, 0xf6, 0x65, 0x23, 0xe9, 0xe0, 0x29, 0x34, 0x0f, 0xc0, 0xc1, 0xd3, 0x87, 0x62, 0xbd,
    0x28, 0x0c, 0x8b, 0x3c, 0xac, 0xd5, 0x89, 0xa8, 0x0d, 0x2b, 0x09, 0xec, 0xa9, 0xe8, 0xd0, 0x7a, 0x8d, 0x47, 0x44, 0x4b, 0x12, 0x45, 0x1a, 0xda, 0x01, 0x7b, 0x70, 0x1e, 0x8d, 0x36, 0x0b, 0xd9,
    0x6b, 0x1a, 0x12, 0x40, 0x55, 0x32, 0x90, 0xc6, 0xbd, 0x3e, 0x1c, 0x0e, 0xa4, 0xaf, 0x1b, 0x22, 0xc4, 0x73, 0x90, 0x26, 0x22, 0xda, 0x19, 0xe2, 0xea, 0x1b, 0xaf, 0x13, 0x72, 0x6f, 0x0b, 0xed,
    0x8c, 0x1f, 0x91, 0x5e, 0x40, 0x37, 0x51, 0x66, 0x33, 0xc8, 0xab, 0x7b, 0xf8, 0x3c, 0x9e, 0x93, 0x45, 0x25, 0xa7, 0x0f, 0x2d, 0xdc, 0x03, 0xdf, 0x5f, 0x9c, 0xed, 0x37, 0x2a, 0xcc, 0x3d, 0x1a,
    0x3a, 0x38, 0xe7, 0x10, 0x1d, 0x58, 0xeb, 0xe5, 0xeb, 0xa5, 0x23, 0xfc, 0x17, 0xa4, 0x9f, 0x62, 0x86, 0xe6, 0xe8, 0x8c, 0xd1, 0x3c, 0x72, 0x86, 0x43, 0xbb, 0x55, 0x6e, 0x3a, 0xc9, 0xe8, 0x8d,
    0x88, 0x37, 0xef, 0xbe, 0x7c, 0x13, 0x56, 0x83, 0x0b, 0x82, 0x49, 0xf0, 0x7b, 0x0a, 0xf6, 0x1d, 0x43, 0xa9, 0xdc, 0x00, 0x51, 0xc4, 0xf3, 0xe0, 0x90, 0x23, 0x29, 0x74, 0x63, 0x7e, 0xcd, 0xa4,
    0x5a, 0x66, 0xeb, 0x9b, 0x41, 0xe0, 0x1a, 0x51, 0xc1, 0xa3, 0x3f, 0x16, 0x18, 0xf2, 0xec, 0x7b, 0x19, 0x4b, 0x1f, 0x81, 0x91, 0x91, 0x48, 0x8a, 0xdf, 0xbf, 0xa1, 0x3c, 0x75, 0x0c, 0x69, 0x2f,
    0xbc, 0xbf, 0xb3, 0x5f, 0x50, 0x1f, 0x30, 0x35, 0xb9, 0x92, 0x46, 0xe3, 0xce, 0x82, 0x60, 0x6f, 0x93, 0x91, 0x51, 0x85, 0xd6, 0xb6, 0xc2, 0xc9, 0x58, 0xa7, 0x85, 0xc0, 0xa5, 0xc0, 0xf4, 0xb3,
    0xac, 0x19, 0xeb, 0x17, 0x89, 0x0a, 0x5f, 0x7a, 0x95, 0x5e, 0x12, 0xde, 0x70, 0xee, 0xec, 0x68, 0x19, 0xb9, 0x7e, 0xb1, 0x9b, 0x52, 0xb2, 0xc6, 0xc3, 0x68, 0x79, 0x1b, 0x90, 0x80, 0xf0, 0xd8,
    0x8f, 0xd9, 0xdf, 0xd1, 0xb0, 0x78, 0x4e, 0x83, 0x20, 0x79, 0x61, 0xf1, 0x21, 0xdb, 0x1e, 0x18, 0xf4, 0x52, 0xd6, 0xde, 0x2b, 0x06, 0x4d, 0x65, 0x41, 0x21, 0xff, 0xf1, 0xac, 0x10, 0x3a, 0xd7,
    0x7c, 0x12, 0x70, 0x67, 0x75, 0x39, 0x71, 0x81, 0x80, 0x5e, 0x7a, 0x47, 0x59, 0xef, 0x86, 0xbd, 0x7e, 0xbd, 0x51, 0x8b, 0x36, 0xd4, 0xc3, 0x7c, 0x80, 0xca, 0x31, 0x97, 0x90, 0x09, 0x17, 0xbb,
    0x8c, 0xc2, 0x08, 0xd8, 0x38, 0xb1, 0xfa, 0xe6, 0xdb, 0x16, 0xe0, 0x82, 0x57, 0x9e, 0x1a, 0x0c, 0x75, 0x2e, 0xf2, 0x59, 0xf9, 0xb4, 0xa8, 0xa9, 0xed, 0x02, 0x4c, 0x30, 0x71, 0xff, 0xfd, 0x5e,
    0xc0, 0x3c, 0xc5, 0xf1, 0x77, 0x07, 0x3e, 0xeb, 0x12, 0xa5, 0xbb, 0xc5, 0xfd, 0xf5, 0xfd, 0x2f, 0xbc, 0x00, 0xb9, 0x52, 0x74, 0x1a, 0x8b, 0xc1, 0xce, 0xed, 0x64, 0x92, 0x56, 0xb1, 0x59, 0x09,
    0xce, 0xd0, 0x9e, 0x9e, 0x3a, 0x25, 0xb8, 0x98, 0x6d, 0x04, 0x78, 0x77, 0x65, 0x53, 0xfa, 0x57, 0x77, 0xa1, 0xc2, 0x9a, 0x41, 0x95, 0xd3, 0xb2, 0xe5, 0x3e, 0xbb, 0x79, 0xfc, 0x05, 0x2f, 0xfe,
    0x79, 0x3c, 0x3d, 0x3c, 0xf2, 0x78, 0xec, 0xb7, 0x17, 0x4f, 0xe2, 0x95, 0x90, 0x78, 0x5f, 0xb2, 0x78, 0xe4, 0xe4, 0x05, 0x97, 0x02, 0x37, 0xd5, 0xe9, 0xe9, 0xe3, 0xd7, 0x60, 0xc3, 0x8c, 0x1c,
    0xaa, 0xb9, 0xe1, 0x22, 0x53, 0x29, 0xdb, 0x83, 0x4b, 0x83, 0xaa, 0xa4, 0x1a, 0x8f, 0xf6, 0x00, 0xcd, 0x6f, 0xbf, 0x3f, 0xb9, 0x21, 0x43, 0x11, 0x88, 0x11, 0xba, 0x90, 0xf9, 0x0b, 0x3c, 0x94,
    0x4b, 0x3f, 0xb3, 0x24, 0x4b, 0xac, 0x77, 0xed, 0xa4, 0x48, 0xae, 0xa4, 0x96, 0xf7, 0xe6, 0x86, 0x73, 0xa0, 0x07, 0xb0, 0x5d, 0x55, 0x94, 0x80, 0x12, 0x25, 0xcd, 0xfd, 0x4f, 0xa1, 0x48, 0x8b,
    0x57, 0x0c, 0xc0, 0xf3, 0x63, 0x3b, 0x43, 0xbb, 0xcd, 0x68, 0xab, 0x5e, 0xc9, 0xa2, 0x98, 0x5e, 0x15, 0xda, 0xbd, 0x65, 0xef, 0xdb, 0xf7, 0xf2, 0x69, 0xa4, 0x53, 0xa8, 0xa8, 0x9e, 0x82, 0xf9,
    0xaf, 0x27, 0x86, 0x04, 0x4f, 0xd3, 0xae, 0x53, 0x37, 0xc0, 0xd3, 0xe7, 0x1b, 0x85, 0x9c, 0x2c, 0x4b, 0x18, 0x58, 0x59, 0xfc, 0xb4, 0x8e, 0x5b, 0x90, 0xf6, 0xa0, 0xaa, 0x68, 0x1a, 0x1d, 0xf0,
    0xf5, 0xea, 0xb2, 0x1d, 0x8e, 0x13, 0xab, 0x66, 0x09, 0xf6, 0x01, 0xa5, 0xa1, 0x73, 0xa4, 0x66, 0x48, 0xd4, 0x1d, 0x9c, 0x0c, 0x03, 0x0a, 0x28, 0x22, 0xc8, 0x79, 0xd4, 0x83, 0x17, 0xe8, 0xd7,
    0x08, 0x75, 0x58, 0x84, 0x00, 0xab, 0xdf, 0x94, 0x73, 0x56, 0x9a, 0xac, 0x9e, 0x62, 0x0c, 0xd6, 0xc6, 0xa9, 0xd2, 0x99, 0x71, 0xfc, 0x69, 0xb5, 0xf0, 0xaf, 0x99, 0x56, 0xb3, 0xa6, 0x82, 0xfe,
    0xd3, 0xe3, 0xb8, 0xa3, 0x57, 0x98, 0xe0, 0x92, 0x27, 0xed, 0x69, 0x42, 0x8a, 0xc3, 0x37, 0x0a, 0x16, 0xfd, 0x08, 0x6d, 0xb1, 0x27, 0xbc, 0xbd, 0x2b, 0x34, 0x99, 0xa9, 0xe7, 0x62, 0x8d, 0x4a,
    0xbf, 0x34, 0x28, 0xc6, 0xf6, 0x39, 0x1d, 0x03, 0xfe, 0x3a, 0x67, 0xb5, 0x69, 0x40, 0x06, 0xf6, 0x2a, 0x33, 0x54, 0x4f, 0x8a, 0xad, 0x7c, 0xdb, 0x62, 0xfc, 0x2a, 0x2d, 0xf4, 0x54, 0x51, 0x18,
    0xab, 0x83, 0x43, 0xc0, 0x17, 0x7e, 0xd0, 0xc3, 0x44, 0x64, 0x97, 0x7b, 0x95, 0x99, 0x39, 0xd2, 0x70, 0x8e, 0x92, 0xec, 0x73, 0xfe, 0x11, 0xf0, 0x4d, 0xe9, 0x48, 0x39, 0x8a, 0x8a, 0xf7, 0xe3,
    0xa4, 0x60, 0xc4, 0x11, 0x2e, 0x17, 0x21, 0x25, 0xf0, 0xc0, 0x30, 0x07, 0x85, 0x86, 0x12, 0x0f, 0x92, 0x02, 0x70, 0x73, 0xd1, 0x75, 0x39, 0x73, 0x5a, 0xd4, 0xed, 0x16, 0xfd, 0xab, 0x3c, 0x82,
    0x89, 0xf6, 0xd0, 0xab, 0x10, 0x8d, 0x8c, 0x28, 0x12, 0x9e, 0x45, 0x99, 0x4f, 0x94, 0x77, 0x22, 0x0c, 0xa5, 0xff, 0x45, 0xd8, 0xfd, 0x3e, 0x06, 0xdd, 0xe3, 0xfa, 0x57, 0x70, 0x50, 0x6f, 0x5b,
    0x9a, 0x8c, 0xf3, 0xe4, 0xc0, 0xd9, 0x04, 0x80, 0x48, 0xf9, 0xea, 0xed, 0xa5, 0x57, 0xa1, 0x47, 0x9d, 0x84, 0x49, 0x1a, 0x53, 0xed, 0x48, 0x5d, 0x96, 0x7a, 0x73, 0xc9, 0x01, 0x3b, 0x56, 0x32,
    0xed, 0x83, 0xdc, 0xdb, 0x1b, 0x4f, 0x64, 0x57, 0xbf, 0x3a, 0xc9, 0x62, 0xf1, 0xec, 0xbd, 0xeb, 0x8c, 0x71, 0xe7, 0xe5, 0xac, 0x24, 0x83, 0xa6, 0x65, 0xa0, 0xe5, 0xb3, 0x69, 0xe8, 0x76, 0xc3,
    0xcd, 0x0c, 0xc3, 0x4a, 0xad, 0xa0, 0xae, 0x5c, 0x44, 0x2c, 0x42, 0x87, 0xd7, 0xf9, 0xb1, 0x59, 0x4a, 0x4f, 0xe7, 0x80, 0x5d, 0xd2, 0x9e, 0xa6, 0x5f, 0x59, 0x08, 0xfa, 0x07, 0x66, 0xbf, 0xf5,
    0xb6, 0x07, 0x9e, 0xcf, 0x93, 0xd3, 0xfa, 0x87, 0x93, 0xc6, 0xa9, 0x0d, 0x5a, 0xdb, 0xd7, 0x80, 0x98, 0x63, 0x1c, 0x50, 0xeb, 0x93, 0x09, 0x6b, 0xe6, 0x96, 0xe4, 0xb4, 0x8c, 0x38, 0xd2, 0xff,
    0xae, 0x92, 0xfe, 0x38, 0x51, 0xa7, 0xcb, 0xb9, 0xe0, 0xeb, 0xe7, 0x7e, 0xc8, 0x21, 0x4b, 0xc2, 0xdf, 0x9e, 0x1a, 0x35, 0x1b, 0x95, 0x03, 0x95, 0x8d, 0x18, 0xf4, 0xd5, 0x78, 0xc0, 0xb9, 0x77,
    0x1a, 0x74, 0xdc, 0x6b, 0x2e, 0xc8, 0x00, 0x86, 0xf6, 0x42, 0x47, 0x5d, 0x1b, 0x3a, 0x12, 0x51, 0xa5, 0x01, 0x1b, 0x6d, 0xeb, 0xc8, 0x1b, 0x59, 0x7a, 0x2b, 0xbe, 0x61, 0x56, 0xc7, 0x41, 0x94,
    0xa1, 0x6c, 0x40, 0xb5, 0x9e, 0x9b, 0xab, 0x01, 0x46, 0x3d, 0xfa, 0x76, 0xc6, 0x18, 0x3b, 0x77, 0x27, 0x23, 0x52, 0xbd, 0x94, 0x1e, 0xb6, 0x97, 0x09, 0xde, 0xa5, 0x58, 0x9b, 0x80, 0x16, 0x3f,
    0x25, 0x57, 0x15, 0x47, 0xc3, 0x47, 0xc2, 0xee, 0x59, 0x0e, 0x23, 0xdd, 0x3a, 0xa6, 0xd5, 0xdb, 0xd5, 0x06, 0x39, 0x56, 0xd8, 0x4d, 0x2d, 0x51, 0xcf, 0xe9, 0x7f, 0x1c, 0x07, 0x53, 0x75, 0x7e,
    0xe3, 0x82, 0x50, 0x6b, 0x79, 0x68, 0x95, 0x4f, 0xe8, 0xe9, 0x4d, 0x19, 0xa1, 0x8b, 0x64, 0x90, 0x96, 0x32, 0x02, 0xff, 0x30, 0x52, 0xad, 0xa4, 0x18, 0xa8, 0xba, 0x2b, 0x6b, 0x02, 0x96, 0x5c,
    0x64, 0x53, 0x61, 0xbc, 0xbe, 0xdd, 0x33, 0x69, 0x47, 0xc5, 0xda, 0xc7, 0xdd, 0xc7, 0x1d, 0xca, 0xad, 0xe8, 0xdf, 0x9e, 0xd1, 0x96, 0xb3, 0x05, 0x95, 0xca, 0x88, 0x56, 0xca, 0x76, 0x24, 0x94,
    0xa8, 0x42, 0x0f, 0xc6, 0x2e, 0x2e, 0x54, 0x13, 0x08, 0x2b, 0xe3, 0xfe, 0x05, 0x80, 0x27, 0x02, 0xc5, 0xce, 0xcd, 0x65, 0xdd, 0x7d, 0xd2, 0x6d, 0xb4, 0x27, 0xbd, 0x8b, 0x79, 0x3e, 0x88, 0xc5,
    0xac, 0xff, 0xce, 0xfc, 0x39, 0x8d, 0x40, 0x26, 0x6c, 0xc5, 0x92, 0x16, 0xf3, 0xa6, 0x53, 0x19, 0x1f, 0x88, 0x45, 0xd4, 0x91, 0x97, 0x26, 0xe4, 0x7e, 0xb2, 0xa3, 0xcf, 0xf4, 0xc6, 0x3e, 0xd0,
    0x91, 0x8b, 0x73, 0x55, 0x92, 0x06, 0x73, 0xea, 0xb8, 0x5f, 0x4b, 0xa0, 0xad, 0x00, 0x1a, 0x10, 0x03, 0x6e, 0x9a, 0xba, 0x42, 0x3e, 0xd7, 0x94, 0xb8, 0x9b, 0xc9, 0x72, 0x49, 0xad, 0xc2, 0x6b,
    0x52, 0xc8, 0x88, 0x6f, 0xa7, 0x1c, 0xdc, 0x7d, 0x29, 0x22, 0x69, 0xc1, 0xe2, 0x46, 0x85, 0x15, 0xf4, 0xdf, 0x80, 0x88, 0x10, 0x77, 0x28, 0xa6, 0x31, 0x26, 0xfb, 0x05, 0x39, 0x07, 0x8e, 0x7d,
    0xdc, 0x6d, 0xe4, 0x4c, 0x82, 0x18, 0x38, 0xca, 0x1e, 0xce, 0xdc, 0xe1, 0xb1, 0xeb, 0x4f, 0xa4, 0x5b, 0x0c, 0x4b, 0x19, 0xc3, 0x9b, 0x7d, 0x05, 0xca, 0xe0, 0x2e, 0x3a, 0xe5, 0x2f, 0x79, 0x1a,
    0x04, 0xed, 0x17, 0x81, 0x5e, 0x91, 0x75, 0x19, 0x4c, 0xb9, 0x3b, 0xcd, 0x80, 0x87, 0x31, 0xea, 0x59, 0x49, 0x58, 0xbf, 0x1c, 0xfa, 0x0c, 0x8c, 0x0f, 0x96, 0x10, 0x94, 0xf1, 0x1a, 0x42, 0x39,
    0x85, 0xe4, 0x81, 0x88, 0xc0, 0x1e, 0xa8, 0x91, 0x40, 0x2d, 0x51, 0xbb, 0x03, 0x7d, 0xd9, 0x89, 0xf9, 0xe9, 0x07, 0x3b, 0xd7, 0x09, 0x20, 0x3e, 0xa0, 0x1e, 0x43, 0x5c, 0xcc, 0xac, 0xbe, 0x07,
    0x8e, 0xb2, 0xa5, 0xe2, 0x38, 0x52, 0x0b, 0x59, 0xb9, 0x05, 0xa0, 0x5c, 0x61, 0xf1, 0x6a, 0x4f, 0xcb, 0xc4, 0x89, 0xea, 0xc3, 0x51, 0x13, 0x31, 0x85, 0x0f, 0x09, 0xb0, 0xf6, 0x56, 0x94, 0xc5,
    0x27, 0x8d, 0x71, 0x6e, 0x7d, 0x03, 0x52, 0x38, 0x1e, 0x8b, 0x5c, 0x27, 0x83, 0x24, 0x50, 0x0c, 0x65, 0x52, 0xb0, 0x18, 0xec, 0x74, 0x19, 0xc6, 0xbd, 0x4d, 0x2b, 0xcb, 0x28, 0xe2, 0xee, 0x45,
    0xc5, 0x29, 0xbe, 0x72, 0x7a, 0x3e, 0x27, 0xa4, 0x35, 0xbd, 0x87, 0x1c, 0x9f, 0xfa, 0x98, 0xc8, 0xab, 0x67, 0x10, 0x4a, 0x3b, 0xcb, 0x2f, 0xfb, 0xc4, 0x39, 0x96, 0xf0, 0x66, 0x3a, 0xd9, 0xfc,
    0xc1, 0xe7, 0xe6, 0x79, 0x90, 0xcb, 0x3d, 0xe3, 0xbc, 0x36, 0x2e, 0x77, 0x12, 0xb6, 0xbb, 0xc8, 0xa2, 0x8d, 0xaf, 0x75, 0xe3, 0x9d, 0x61, 0x61, 0xd9, 0x46, 0x81, 0x22, 0x33, 0xbf, 0x92, 0xea,
    0x63, 0x92, 0x67, 0x29, 0x04, 0x29, 0x94, 0xb8, 0x47, 0x8c, 0x06, 0x46, 0x4b, 0x51, 0x69, 0x51, 0x53, 0xf6, 0xb2, 0x40, 0xdb, 0xc5, 0x7a, 0xc4, 0xee, 0x33, 0x00, 0x61, 0x29, 0xf4, 0x11, 0xbc,
    0x7e, 0xf5, 0x50, 0xdd, 0xdd, 0xb0, 0xee, 0xac, 0xf9, 0x31, 0xc5, 0x03, 0x25, 0x60, 0x03, 0xc2, 0x84, 0x34, 0x29, 0x81, 0x5e, 0xfd, 0xf4, 0x38, 0x52, 0x69, 0x10, 0x4e, 0x10, 0x35, 0xc5, 0x0a,
    0x2f, 0xc3, 0x67, 0xb2, 0x9b, 0xed, 0x5a, 0x23, 0xc0, 0x59, 0x7c, 0xde, 0xf8, 0x26, 0xcb, 0xd6, 0x7f, 0x93, 0x1c, 0x29, 0xbd, 0x8b, 0x1c, 0xbf, 0x8d, 0xef, 0x60, 0x58, 0x67, 0xfe, 0xdd, 0x0c,
    0xce, 0x01, 0x2e, 0x4f, 0x50, 0xfe, 0x0c, 0x1e, 0xb5, 0x91, 0x33, 0xcd, 0xc8, 0x54, 0x10, 0x66, 0xce, 0x21, 0xd1, 0xe3, 0x7a, 0xbc, 0x96, 0x1d, 0x4e, 0x87, 0x31, 0x9d, 0x2e, 0xfd, 0xd4, 0x3c,
    0x56, 0x38, 0x97, 0xd4, 0x26, 0x0f, 0x09, 0x6f, 0x10, 0xba, 0xe1, 0xda, 0x31, 0xaf, 0xad, 0x01, 0x83, 0x07, 0xdb, 0x01, 0xed, 0xd9, 0xf7, 0xb6, 0x3a, 0x62, 0x8b, 0x08, 0x42, 0xa1, 0x30, 0x24,
    0x52, 0x8f, 0x36, 0x06, 0x7e, 0xf2, 0x2b, 0xaa, 0x96, 0x7e, 0x45, 0x49, 0x0d, 0x06, 0x73, 0x2d, 0x66, 0xb9, 0xf4, 0x0c, 0x57, 0xb1, 0xeb, 0x04, 0xe2, 0x82, 0x50, 0x55, 0x9a, 0xb4, 0x92, 0x4b,
    0x23, 0x92, 0x47, 0xa4, 0xd6, 0x3c, 0x5d, 0x07, 0xe8, 0x07, 0xf6, 0xbc, 0x8e, 0x97, 0x89, 0x5f, 0x7c, 0xd5, 0x6a, 0x07, 0x4d, 0xa7, 0xe2, 0x73, 0xc1, 0xdb, 0x75, 0x72, 0x79, 0x8d, 0xdf, 0x12,
    0x9d, 0xd7, 0xb4, 0x19, 0x2e, 0x42, 0x20, 0x82, 0x67, 0x4c, 0x46, 0xbb, 0xf1, 0x44, 0xe6, 0xc0, 0x84, 0xd2, 0x84, 0x24, 0xd2, 0x70, 0x5a, 0x5d, 0x5b, 0x28, 0xd8, 0x3a, 0x16, 0x15, 0x1b, 0x46,
    0xa3, 0x9d, 0xe4, 0xea, 0xda, 0x2b, 0x9b, 0xea, 0xd2, 0xae, 0xff, 0x72, 0x16, 0xc9, 0xcd, 0x9f, 0x65, 0x51, 0x5e, 0x94, 0xf6, 0x2f, 0x86, 0xb0, 0x75, 0x30, 0x6e, 0xf8, 0x8c, 0x1c, 0x84, 0xfc,
    0x3f, 0x69, 0xf1, 0xf0, 0xe5, 0x6d, 0x1c, 0x6c, 0x66, 0xb9, 0x8e, 0x63, 0xce, 0xcd, 0x8c, 0x4b, 0x4e, 0x20, 0xe4, 0x32, 0xa1, 0xd8, 0x80, 0xdc, 0xee, 0x53, 0xe9, 0xe9, 0x7d, 0xb0, 0xb7, 0xa4,
    0xfc, 0xc9, 0x29, 0xa4, 0x04, 0x7b, 0x0f, 0x9a, 0x0b, 0x98, 0x64, 0xa9, 0x16, 0xfd, 0xce, 0x7d, 0x2b, 0xc3, 0xfe, 0x9a, 0x96, 0xcb, 0x53, 0x92, 0xa4, 0xa1, 0x83, 0x68, 0x45, 0x56, 0xd2, 0x49,
    0xec, 0xc8, 0xd8, 0x68, 0x13, 0xcb, 0x52, 0xd1, 0x11, 0x7c, 0x27, 0x12, 0x7d, 0xa2, 0x92, 0xe6, 0xd5, 0x20, 0x52, 0xe3, 0x00, 0xbb, 0x95, 0x08, 0x1a, 0xd7, 0x82, 0x03, 0xda, 0x5d, 0xd8, 0x64,
    0xa1, 0x74, 0xf4, 0x77, 0xde, 0xf6, 0x83, 0xaa, 0x78, 0xfc, 0x4c, 0x98, 0xdd, 0xeb, 0x15, 0xfe, 0x09, 0xf6, 0x7a, 0x84, 0xea, 0x3f, 0x3d, 0x94, 0xda, 0xb9, 0x7b, 0x8c, 0x70, 0x5b, 0xec, 0x5a,
    0x4d, 0xb5, 0xe3, 0x1a, 0xfb, 0xc4, 0x72, 0x91, 0xac, 0xd3, 0xd7, 0x00, 0x62, 0x1c, 0x2f, 0x17, 0xc7, 0x86, 0xa7, 0xd0, 0x19, 0x8b, 0x62, 0x15, 0xa1, 0x24, 0x54, 0xac, 0x13, 0x1f, 0x1c, 0x64,
    0x53, 0x03, 0xe7, 0x54, 0xdf, 0x60, 0xc1, 0xa2, 0xe9, 0x0f, 0xc2, 0x1c, 0x6d, 0xcd, 0xef, 0x51, 0xb2, 0x13, 0xda, 0xf0, 0xc4, 0x82, 0xbb, 0x83, 0x29, 0xad, 0x2f, 0x88, 0x8f, 0x61, 0x9e, 0xf2,
    0xab, 0xa8, 0x34, 0x68, 0xcb, 0x55, 0xed, 0x5a, 0x08, 0x7c, 0x58, 0xe3, 0xb9, 0x1a, 0x58, 0x24, 0xc4, 0x01, 0x58, 0xe4, 0x28, 0xe6, 0x4c, 0x11, 0x04, 0x87, 0x77, 0x61, 0x81, 0xf9, 0x82, 0xde,
    0x0f, 0xcc, 0xf4, 0x72, 0x70, 0xed, 0x32, 0xf5, 0x94, 0x87, 0x15, 0x84, 0xc7, 0x24, 0x57, 0xb7, 0xca, 0x27, 0x0f, 0xc8, 0xee, 0x9d, 0x11, 0x9c, 0xa0, 0x11, 0x8f, 0x4a, 0xaa, 0x74, 0x32, 0xb5,
    0x40, 0x39, 0x24, 0x95, 0x24, 0x77, 0x3d, 0xdc, 0x7d, 0xc5, 0xb2, 0x89, 0xbd, 0xd3, 0xb9, 0x21, 0x1c, 0xf1, 0xf7, 0x86, 0xe1, 0xd5, 0x2b, 0xfa, 0xb2, 0x8e, 0x12, 0x52, 0x85, 0x1f, 0xa2, 0x6e,
    0x90, 0xa7, 0xf3, 0xc5, 0xdb, 0xac, 0x23, 0x8b, 0xd3, 0x41, 0x9d, 0xcc, 0xcf, 0x17, 0xe8, 0x98, 0xfd, 0xa2, 0xd0, 0xce, 0x91, 0x2d, 0x11, 0x8a, 0xe7, 0x1e, 0xd5, 0x42, 0xe0, 0x70, 0x3b, 0x92,
    0x9d, 0xfe, 0x57, 0x24, 0xf0, 0x9d, 0xc6, 0x8a, 0x8c, 0x25, 0xd9, 0x1a, 0xe9, 0x43, 0x63, 0xe3, 0xf5, 0x7a, 0xcf, 0x60, 0x90, 0x78, 0x6c, 0x07, 0x01, 0xb4, 0x3d, 0xad, 0x9d, 0xee, 0x78, 0x1c,
    0xdb, 0xbf, 0x00, 0x53, 0x8f, 0x60, 0xd1, 0xf3, 0xd9, 0x8c, 0xd3, 0x78, 0x04, 0x10, 0x79, 0x96, 0x49, 0x04, 0xc2, 0x98, 0xa0, 0xb3, 0x60, 0x40, 0x86, 0x35, 0x75, 0xa1, 0x6a, 0x66, 0xff, 0x0a,
    0xe7, 0xed, 0x6f, 0x4e, 0xbd, 0x83, 0x64, 0x7e, 0x54, 0x2d, 0x93, 0x98, 0xfb, 0x72, 0x53, 0x30, 0x56, 0x9d, 0x6a, 0x97, 0x8c, 0xe4, 0x98, 0x88, 0x5c, 0x26, 0x27, 0x89, 0x64, 0xb3, 0xda, 0xbf,
    0x1e, 0xc0, 0xe7, 0x7e, 0x7b, 0x9d, 0xb9, 0x3a, 0xab, 0xe7, 0xd4, 0x44, 0xa5, 0x6f, 0x5e, 0x24, 0x8b, 0x85, 0x99, 0x4e, 0x34, 0xf3, 0xd5, 0x2c, 0xc9, 0x3a, 0xf2, 0x3c, 0xe7, 0x3b, 0x74, 0x2f,
    0xb2, 0x88, 0x44, 0xdd, 0x8e, 0x4d, 0x07, 0xd0, 0xed, 0x41, 0xef, 0x91, 0x16, 0x69, 0x92, 0xb8, 0x32, 0x49, 0x56, 0x32, 0xf4, 0xc3, 0x31, 0x26, 0x70, 0x17, 0xfb, 0xf9, 0x06, 0xc3, 0x77, 0x9d,
    0x51, 0x37, 0x64, 0x4d, 0x45, 0xc0, 0x42, 0xaf, 0xf8, 0x52, 0x9a, 0x43, 0xe1, 0xd4, 0x3e, 0x4e, 0xa2, 0xb3, 0x26, 0xa6, 0xc8, 0x8c, 0x09, 0xd0, 0xd0, 0x66, 0xef, 0xc4, 0x3f, 0x57, 0xa4, 0x71,
    0xd5, 0xac, 0x54, 0x16, 0xd6, 0x76, 0x7f, 0x97, 0x75, 0x60, 0x11, 0xc6, 0x0c, 0xe1, 0xbe, 0x5e, 0x94, 0x05, 0xc0, 0x20, 0x4c, 0xfe, 0x02, 0xca, 0x3d, 0x96, 0xac, 0x2d, 0x6c, 0x80, 0x53, 0xab,
    0x12, 0x2d, 0x44, 0xaa, 0x65, 0x9a, 0xc0, 0x03, 0xe0, 0xa7, 0x34, 0xfb, 0x7f, 0xcc, 0x26, 0x82, 0xf9, 0xb5, 0x19, 0x64, 0x0d, 0x18, 0xc6, 0x0f, 0xc8, 0x9f, 0x74, 0x49, 0x5b, 0x4a, 0x0d, 0xfa,
    0x01, 0xea, 0x46, 0x3c, 0x0f, 0x8d, 0x6e, 0x24, 0x14, 0x7b, 0xc7, 0x1e, 0x4a, 0xef, 0x16, 0xc3, 0x31, 0x7a, 0xee, 0x1e, 0x77, 0xab, 0x7f, 0x99, 0x99, 0x4b, 0xbb, 0x98, 0xf3, 0x61, 0xea, 0x40,
    0xa4, 0x2b, 0x45, 0x4e, 0x10, 0x24, 0x9a, 0x4e, 0xb5, 0x3b, 0x80, 0x9c, 0x3f, 0x7c, 0xfd, 0xe3, 0xda, 0x3e, 0x86, 0xe3, 0x9c, 0x6a, 0x3c, 0x3f, 0x84, 0x1d, 0x85, 0x57, 0xd2, 0xe6, 0x3d, 0x6c,
    0x47, 0x34, 0xe9, 0x0d, 0x4c, 0x7e, 0x14, 0x14, 0xea, 0x34, 0x4f, 0x8c, 0x76, 0x47, 0x64, 0xcc, 0x85, 0xe8, 0xc0, 0xa3, 0x35, 0x24, 0x8e, 0xae, 0xcb, 0xad, 0xde, 0x42, 0xb4, 0x65, 0x00, 0xe6,
    0x47, 0xdd, 0xad, 0x26, 0x4c, 0xd5, 0xb5, 0x2d, 0x67, 0xe3, 0x46, 0xa0, 0x54, 0x8a, 0xf5, 0x9b, 0x75, 0xad, 0x7e, 0x17, 0x6d, 0x12, 0xb0, 0x6f, 0x2f, 0xbb, 0x0f, 0xab, 0x02, 0xb3, 0x0c, 0xfd,
    0x06, 0xee, 0xa0, 0x8f, 0x57, 0x13, 0x05, 0xda, 0xe9, 0x2b, 0x27, 0x0a, 0x6b, 0x82, 0x2d, 0xd7, 0x03, 0xe1, 0x7a, 0xae, 0x83, 0x9a, 0xc2, 0x76, 0xb4, 0x12, 0x9b, 0x1e, 0xbc, 0x16, 0x69, 0xc2,
    0x67, 0x09, 0x1b, 0x7d, 0x27, 0x35, 0x55, 0x5b, 0x11, 0xe7, 0x7a, 0x68, 0xfb, 0x67, 0x57, 0xf8, 0x39, 0xe1, 0x42, 0x52, 0x88, 0x5d, 0x83, 0xc8, 0xa0, 0xa5, 0x44, 0x39, 0x3c, 0xad, 0x39, 0xea,
    0x11, 0x67, 0x3a, 0x38, 0x2c, 0xa1, 0xbb, 0x1e, 0xd7, 0xfa, 0x18, 0xa3, 0x75, 0x00, 0xb5, 0x15, 0x27, 0x7a, 0x77, 0x94, 0x77, 0x3c, 0x20, 0xcb, 0xdb, 0xf5, 0x5c, 0x34, 0x4c, 0xb3, 0x86, 0xa9,
    0x88, 0x25, 0x2c, 0x9e, 0x62, 0x24, 0xcf, 0xbd, 0x15, 0x6c, 0xd1, 0xc5, 0x6a, 0x44, 0x01, 0xe9, 0xef, 0x4a, 0x66, 0x4b, 0x49, 0x6f, 0x34, 0x2e, 0xad, 0x82, 0x74, 0x47, 0xb2, 0x24, 0xf0, 0xd9,
    0x63, 0x51, 0xad, 0xd0, 0x89, 0xb2, 0x0e, 0x9a, 0x6d, 0x31, 0x47, 0xb6, 0xe5, 0x04, 0x6c, 0x7b, 0x72, 0x84, 0x15, 0xfa, 0x1a, 0x48, 0x08, 0x3f, 0xbf, 0xcd, 0x3b, 0x2c, 0x02, 0x15, 0x53, 0x1f,
    0x78, 0xb6, 0xee, 0x91, 0xcd, 0x51, 0x8c, 0x87, 0xa6, 0x84, 0x94, 0x84, 0x9d, 0x55, 0xda, 0xb3, 0xb4, 0x04, 0xc9, 0x2f, 0xde, 0xf2, 0xb0, 0x5e, 0xf2, 0x20, 0x08, 0x68, 0x09, 0xd6, 0x64, 0x35,
    0xcf, 0x9a, 0x0b, 0xf2, 0x9f, 0xa4, 0xb4, 0xca, 0x6d, 0xa8, 0x8a, 0x02, 0x17, 0xe3, 0xad, 0x2a, 0x76, 0xce, 0x19, 0xe6, 0x59, 0xec, 0x8c, 0x4f, 0x39, 0xc6, 0x20, 0xbf, 0xba, 0x13, 0xcb, 0x86,
    0x53, 0x8e, 0xc5, 0x6b, 0xc2, 0xf5, 0x8e, 0x5b, 0xf7, 0x02, 0x70, 0xbd, 0x63, 0xce, 0x4c, 0xb4, 0xb4, 0x9a, 0x45, 0xfb, 0xda, 0x87, 0xf2, 0xf0, 0x40, 0x62, 0x1a, 0x64, 0x89, 0x9d, 0x04, 0x09,
    0xcf, 0x79, 0xba, 0x24, 0xd3, 0xb3, 0xe8, 0x85, 0xbc, 0x54, 0x15, 0xc2, 0xaa, 0x32, 0x34, 0x07, 0x52, 0x37, 0x56, 0xde, 0xff, 0x43, 0x1f, 0xd3, 0xda, 0xaa, 0xd9, 0xfe, 0x4b, 0xa5, 0x04, 0xe0,
    0x23, 0x55, 0x11, 0x66, 0xf7, 0x13, 0xd2, 0xf0, 0xfa, 0x7d, 0x0b, 0xbb, 0xbc, 0x4c, 0x2a, 0x6c, 0xc8, 0x61, 0xe2, 0x3e, 0xbb, 0x14, 0xf2, 0x6d, 0x8b, 0x1e, 0x75, 0x49, 0x2e, 0xdb, 0x1b, 0x13,
    0x67, 0x4d, 0xc0, 0x13, 0x4a, 0x66, 0xed, 0xc7, 0xe7, 0x66, 0x30, 0x09, 0xba, 0x2d, 0xe9, 0x42, 0xd9, 0x0a, 0x54, 0x6c, 0xa0, 0xb3, 0xaf, 0x8a, 0x7a, 0x64, 0x25, 0xeb, 0x1e, 0xf2, 0xbf, 0x30,
    0x4e, 0x0e, 0x83, 0xce, 0x91, 0x56, 0xef, 0x65, 0xde, 0x5b, 0xff, 0xf1, 0x0b, 0x61, 0xef, 0xcd, 0x0a, 0x82, 0x0a, 0x8f, 0x57, 0x6b, 0x42, 0x96, 0xf5, 0x52, 0x32, 0x11, 0xaa, 0xb6, 0x58, 0xcb,
    0xda, 0x7a, 0x56, 0xf2, 0x67, 0x42, 0x3f, 0xbd, 0x61, 0xf8, 0x43, 0x88, 0x79, 0x31, 0xe0, 0x21, 0xe2, 0x0b, 0x93, 0x49, 0x8a, 0x1b, 0x54, 0x59, 0xfe, 0x6d, 0x27, 0x60, 0x1d, 0x70, 0x7c, 0xfd,
    0x73, 0xc5, 0x88, 0xa0, 0xe8, 0x37, 0x36, 0x7c, 0xd8, 0xd3, 0xa9, 0x57, 0xdf, 0xc0, 0xef, 0x94, 0x22, 0x8a, 0x7f, 0x2f, 0x35, 0xb3, 0xcf, 0xf8, 0x58, 0xe0, 0x5a, 0x16, 0xd5, 0x02, 0xfa, 0xcc,
    0x6c, 0xec, 0xe1, 0x13, 0xfc, 0xeb, 0x9e, 0xd1, 0x11, 0x46, 0xcf, 0x20, 0x31, 0x6c, 0xba, 0xb5, 0x28, 0xe7, 0x32, 0xd1, 0xe1, 0xc2, 0x35, 0x7a, 0x03, 0xf5, 0x11, 0x20, 0x22, 0x8c, 0x8f, 0x36,
    0x3d, 0x12, 0x1c, 0xff, 0x05, 0x5d, 0xf0, 0x93, 0x0b, 0xeb, 0xb7, 0x3f, 0x85, 0x9c, 0x74, 0x30, 0x0e, 0xff, 0xe7, 0x5e, 0x49, 0x8f, 0x3c, 0xbf, 0x02, 0x46, 0x65, 0x9a, 0x0b, 0x95, 0x93, 0xe7,
    0x82, 0xa6, 0x32, 0x10, 0x9b, 0xf8, 0x49, 0x36, 0xeb, 0x42, 0xbf, 0xfd, 0x12, 0x2d, 0x0c, 0xe5, 0x45, 0x50, 0x13, 0x8a, 0xb5, 0xa3, 0x53, 0xa5, 0xbb, 0xa1, 0xa0, 0x12, 0x43, 0xd8, 0x2b, 0xab,
    0x74, 0xf1, 0x30, 0x87, 0x3e, 0xeb, 0xa4, 0x6a, 0xfa, 0xe0, 0x07, 0x17, 0xff, 0xd2, 0x31, 0xc4, 0x8f, 0xb7, 0x51, 0xab, 0xe4, 0x61, 0x94, 0x19, 0xc6, 0xc5, 0x7c, 0x6a, 0x44, 0x43, 0xc9, 0x7b,
    0x02, 0xda, 0x06, 0xca, 0xcd, 0x07, 0x09, 0x2c, 0x2b, 0xf6, 0x19, 0xc9, 0x82, 0xd6, 0x7c, 0x95, 0x55, 0x8b, 0xc3, 0xfc, 0xc0, 0xe3, 0xac, 0x0c, 0x60, 0xa2, 0x1c, 0x11, 0x8f, 0x16, 0x73, 0x09,
    0x75, 0x72, 0xb9, 0xe6, 0x1f, 0x3c, 0xa8, 0x06, 0xa0, 0xb7, 0xcb, 0xd3, 0x59, 0x5e, 0x9c, 0x5f, 0xc7, 0x86, 0x2c, 0xd2, 0x15, 0xf8, 0x96, 0x5e, 0xca, 0x87, 0x21, 0x84, 0x5c, 0xce, 0xa2, 0xb0,
    0x90, 0xee, 0x63, 0x66, 0xca, 0xf9, 0x6f, 0x9a, 0x65, 0x59, 0xf5, 0x11, 0xc4, 0xe7, 0x21, 0x30, 0xb3, 0x9c, 0xb7, 0x00, 0xff, 0xf7, 0x13, 0x18, 0xb1, 0xbd, 0x4b, 0x19, 0x72, 0xff, 0x96, 0x80,
    0x28, 0x73, 0xb4, 0xec, 0x6a, 0x4f, 0x72, 0x14, 0x26, 0x1e, 0x93, 0xa3, 0x0a, 0xf5, 0x72, 0x06, 0xb2, 0x1d, 0x19, 0xdb, 0xfc, 0xe3, 0x43, 0x9e, 0x4e, 0xfd, 0x06, 0x79, 0xae, 0x4e, 0x4f, 0x9d,
    0xf0, 0x0b, 0xee, 0x70, 0x2a, 0xd0, 0xcd, 0x5e, 0xf0, 0xa5, 0x9c, 0x5a, 0x15, 0x81, 0xcf, 0xdc, 0x70, 0x79, 0x6d, 0xd1, 0x1e, 0x2f, 0x2b, 0x8f, 0xd6, 0xe4, 0x1a, 0xc7, 0xc2, 0xc7, 0x65, 0x7a,
    0x6e, 0x42, 0x2c, 0x5b, 0xf7, 0xeb, 0x77, 0xe3, 0x84, 0xa3, 0x51, 0xa9, 0x7c, 0x8c, 0x2f, 0x4a, 0x35, 0x88, 0x46, 0x4f, 0x43, 0xdd, 0x6d, 0x76, 0xa7, 0x74, 0x5d, 0x81, 0x54, 0x1e, 0xc8, 0x4a,
    0x03, 0x10, 0x5c, 0xb9, 0x6e, 0xc9, 0x2b, 0x13, 0x62, 0xb0, 0x1b, 0x19, 0xe0, 0x3b, 0xd2, 0x5b, 0x73, 0x28, 0x01, 0x25, 0xe4, 0x90, 0x82, 0xbe, 0xfe, 0x6a, 0x21, 0xf6, 0x2f, 0x4d, 0xf1, 0xbe,
    0xf4, 0x45, 0x70, 0xe3, 0xb4, 0x59, 0x9a, 0x2a, 0xed, 0x6c, 0x5e, 0xac, 0x2a, 0x93, 0xa9, 0xd5, 0x1f, 0xa4, 0xb5, 0xcf, 0xc1, 0xec, 0x81, 0x32, 0x68, 0x8a, 0x34, 0x7c, 0x86, 0xb4, 0x3b, 0x04,
    0xd2, 0x25, 0x25, 0x88, 0xa2, 0x96, 0xcf, 0x7f, 0x7f, 0x48, 0x3e, 0xb2, 0x40, 0x3b, 0x39, 0x21, 0x2c, 0x7b, 0x6d, 0xc4, 0xf7, 0x68, 0x8d, 0x39, 0x12, 0xfc, 0x22, 0x3d, 0xbc, 0xa5, 0x7f, 0x0c,
    0xeb, 0xdf, 0x8c, 0x1c, 0xa5, 0x07, 0x31, 0xb0, 0x6e, 0x13, 0x67, 0x1a, 0x55, 0x76, 0xc8, 0x66, 0x41, 0x76, 0x54, 0xe7, 0x07, 0x0f, 0xea, 0xd8, 0x03, 0x58, 0xba, 0xe5, 0x8f, 0x37, 0x2b, 0xde,
    0xcd, 0xd7, 0xdc, 0xaf, 0xcc, 0x38, 0xff, 0x07, 0x18, 0xf0, 0xaa, 0xc3, 0xa0, 0xe3, 0x7f, 0xb0, 0x66, 0xd6, 0xd7, 0x68, 0x97, 0x63, 0xd3, 0x40, 0xb4, 0x89, 0x09, 0x71, 0xc3, 0x1b, 0x17, 0x92,
    0xcf, 0x26, 0x96, 0xf2, 0x18, 0x83, 0x4d, 0x4b, 0x30, 0xf8, 0xa9, 0xd5, 0x21, 0x8e, 0x09, 0x8c, 0xd6, 0x4b, 0x7c, 0x63, 0x7e, 0x40, 0xac, 0x3b, 0x04, 0xc4, 0x05, 0xc5, 0xa7, 0xab, 0x0e, 0x15,
    0x71, 0xe3, 0x5d, 0xe1, 0x40, 0x03, 0x5b, 0x9d, 0x33, 0x42, 0xa9, 0x82, 0xe7, 0x23, 0x7c, 0x77, 0x84, 0xb3, 0xa5, 0xa3, 0xa1, 0x67, 0xfb, 0x3a, 0xac, 0x3f, 0x62, 0xc7, 0x8f, 0xde, 0x9e, 0xc4,
    0xbe, 0x0a, 0x8b, 0x5a, 0x43, 0xdc, 0x8b, 0x0a, 0x4a, 0x27, 0xa5, 0x10, 0x1f, 0x88, 0x55, 0xcb, 0x32, 0x40, 0x64, 0x9c, 0xb9, 0xa2, 0xeb, 0x60, 0xff, 0x84, 0x23, 0xd7, 0x64, 0x99, 0xfe, 0x7a,
    0x99, 0x13, 0xc8, 0x35, 0xb2, 0x1b, 0x91, 0xc9, 0x9a, 0x5c, 0xac, 0x64, 0x0a, 0x94, 0x31, 0xfc, 0x22, 0x02, 0xf2, 0x75, 0xce, 0xe7, 0xc6, 0x35, 0xb1, 0x59, 0x30, 0x53, 0xb6, 0x12, 0x42, 0x18,
    0x3a, 0x37, 0x8e, 0x34, 0x21, 0x40, 0x25, 0xa9, 0xee, 0x42, 0xa8, 0x8c, 0x5a, 0xa3, 0x3b, 0x9d, 0x95, 0xb8, 0x0d, 0xff, 0xbc, 0x52, 0x50, 0x69, 0xe7, 0x70, 0xcc, 0x44, 0xe2, 0x08, 0x11, 0x37,
    0x88, 0x17, 0xbc, 0x8d, 0xfa, 0x5c, 0xe2, 0xc4, 0x0a, 0x36, 0xc5, 0x84, 0xab, 0xfb, 0x1a, 0x57, 0xad, 0x6c, 0x5c, 0x99, 0x9d, 0x7f, 0x81, 0x43, 0xd3, 0xba, 0xfa, 0x05, 0x05, 0x1a, 0x7c, 0x8e,
    0x63, 0x33, 0x2b, 0xa8, 0xee, 0x23, 0x3c, 0xe8, 0x72, 0x7e, 0xd1, 0x6a, 0xce, 0xe2, 0xe5, 0xe1, 0x4a, 0xfc, 0x81, 0xd6, 0x77, 0x81, 0x0c, 0xb9, 0x06, 0x02, 0x46, 0xfd, 0x54, 0x22, 0xab, 0x92,
    0xd5, 0xb6, 0x18, 0x22, 0x1b, 0x0f, 0x00, 0x3f, 0xce, 0xe6, 0x8a, 0x64, 0x30, 0xe6, 0x12, 0x91, 0xca, 0x44, 0xf7, 0x6a, 0xb5, 0xcd, 0x8b, 0x2a, 0xbb, 0xbf, 0x47, 0x81, 0xa8, 0x94, 0xc6, 0x88,
    0x6f, 0xaf, 0x57, 0x62, 0x84, 0x87, 0xb2, 0x21, 0xe0, 0xcc, 0x69, 0xbb, 0x55, 0xcb, 0x72, 0x7f, 0x9f, 0xb6, 0xc0, 0xa7, 0xa5, 0x09, 0x16, 0xca, 0xd8, 0x49, 0xd6, 0x7e, 0xcd, 0x35, 0x41, 0x75,
    0xc1, 0x4e, 0x86, 0xd6, 0x0d, 0x00, 0x3d, 0x27, 0x44, 0x37, 0x9f, 0x83, 0x20, 0x3c, 0x0e, 0xe1, 0x59, 0x04, 0x10, 0x97, 0x81, 0x9f, 0x63, 0x0a, 0x3b, 0x79, 0xc3, 0xbb, 0xea, 0xc3, 0x72, 0x6f,
    0x6e, 0xb4, 0xf4, 0x1e, 0xb2, 0x84, 0x1a, 0xbc, 0x78, 0xbf, 0x69, 0x35, 0xc4, 0x2b, 0xbe, 0x49, 0x56, 0xc3, 0x09, 0x2b, 0x9f, 0x7f, 0x9e, 0x3c, 0x7c, 0x88, 0x31, 0x2b, 0xd7, 0xdb, 0x89, 0xb5,
    0xfc, 0x43, 0x76, 0xbc, 0x06, 0xb3, 0x7e, 0xd8, 0xbd, 0x2a, 0x5d, 0x8a, 0x41, 0xae, 0x1e, 0xbd, 0x24, 0x6a, 0x89, 0x72, 0x83, 0xac, 0x21, 0x51, 0x0b, 0xfe, 0x49, 0xf7, 0x54, 0x41, 0xb8, 0xbb,
    0x32, 0x6e, 0x64, 0x1c, 0x36, 0xd3, 0x23, 0xa9, 0x1a, 0xb2, 0x4d, 0xca, 0xe9, 0x76, 0x82, 0x0b, 0xce, 0xc9, 0x42, 0x6e, 0x7c, 0x15, 0x81, 0x7e, 0x8f, 0x05, 0xc1, 0x09, 0x21, 0x4a, 0xb5, 0x34,
    0x06, 0x72, 0x6e, 0xd2, 0x55, 0xea, 0x9d, 0x7b, 0x09, 0xe1, 0xb0, 0x71, 0x47, 0xf6, 0xbf, 0xe2, 0x89, 0x8d, 0xf3, 0xcb, 0xe4, 0x46, 0x7e, 0xf5, 0x64, 0xec, 0x82, 0x78, 0x7a, 0xeb, 0xf3, 0xc3,
    0x17, 0xc0, 0x2c, 0xc2, 0x5d, 0x9c, 0x31, 0xc1, 0xc9, 0x0b, 0x78, 0x40, 0xfc, 0x15, 0x25, 0x96, 0xf0, 0x0a, 0x41, 0x8c, 0xa5, 0xd2, 0x8c, 0x04, 0x8c, 0x61, 0x73, 0x32, 0x04, 0xb7, 0x78, 0xaf,
    0xda, 0xc7, 0x39, 0x0e, 0xc3, 0x2c, 0xec, 0x79, 0x65, 0x17, 0x20, 0x22, 0xa4, 0x71, 0xe1, 0x07, 0x1d, 0x8c, 0xb1, 0xd3, 0xc2, 0x84, 0xe5, 0x29, 0x04, 0xa8, 0x20, 0xbe, 0x53, 0x60, 0x7a, 0x7d,
    0x45, 0xe2, 0xe1, 0x12, 0x2f, 0x52, 0xea, 0x0f, 0x57, 0x22, 0x99, 0x6e, 0x10, 0x9f, 0x9e, 0x87, 0xbc, 0x57, 0x52, 0x5c, 0x62, 0xe8, 0x66, 0xb8, 0x2c, 0xcb, 0xf4, 0x80, 0x05, 0x6f, 0x96, 0x9b,
    0xda, 0xe1, 0x8c, 0x9e, 0x5f, 0x1e, 0x77, 0x6e, 0x04, 0x72, 0xce, 0x97, 0xf1, 0x01, 0x47, 0xdc, 0xe6, 0x9b, 0xa8, 0x04, 0xc3, 0x0a, 0x47, 0x9e, 0x92, 0x4c, 0x06, 0xf8, 0xa2, 0x0e, 0xf9, 0x07,
    0xec, 0x96, 0x98, 0x88, 0x61, 0xbf, 0xa8, 0x7e, 0x24, 0x8f, 0xfc, 0x7d, 0xe5, 0x00, 0x2a, 0x92, 0xc2, 0x65, 0x89, 0x32, 0x85, 0x1c, 0xe9, 0xb2, 0x88, 0x11, 0x99, 0x9a, 0x48, 0x90, 0x88, 0xc3,
    0x02, 0xdc, 0x4f, 0xb8, 0x87, 0xe1, 0x45, 0xbd, 0xfe, 0x8a, 0xbd, 0xee, 0xf0, 0x4b, 0x75, 0x94, 0xeb, 0x4f, 0xbe, 0xdc, 0x0d, 0xc0, 0xf7, 0x11, 0x41, 0x39, 0x89, 0x4e, 0x38, 0xa2, 0x88, 0xf1,
    0x07, 0xca, 0xd2, 0x13, 0x92, 0xb8, 0x62, 0x0e, 0x70, 0x37, 0x44, 0xce, 0x4d, 0xea, 0xf0, 0x17, 0x0a, 0x5b, 0x49, 0x12, 0xe0, 0xd8, 0x4a, 0xc7, 0x40, 0x33, 0xff, 0xd5, 0x26, 0xe6, 0xbf, 0x26,
    0x9f, 0x91, 0x9f, 0x41, 0x3e, 0xe7, 0x77, 0x1c, 0x96, 0x9c, 0x3b, 0xc2, 0x80, 0x58, 0x31, 0x85, 0xcd, 0x21, 0x5f, 0xf2, 0x5b, 0x6b, 0x12, 0x19, 0xb0, 0xaf, 0xdd, 0x71, 0xc1, 0x6b, 0x88, 0x40,
    0xb2, 0xf5, 0x8c, 0x21, 0x77, 0x4a, 0xaa, 0xee, 0x12, 0x15, 0x66, 0x14, 0xfe, 0xe3, 0x9c, 0x91, 0x89, 0xc9, 0x6c, 0xf5, 0x0a, 0xb3, 0x6f, 0xc6, 0x2b, 0xe4, 0x8f, 0xd1, 0x35, 0xa8, 0x49, 0x98,
    0xf5, 0xd0, 0xcc, 0x61, 0x0e, 0x86, 0x60, 0xd1, 0x37, 0xcd, 0xf2, 0xbd, 0xb6, 0x03, 0x76, 0x7a, 0x9e, 0x62, 0x47, 0x4f, 0xed, 0xcc, 0x7f, 0xe6, 0x22, 0xb8, 0x60, 0x8f, 0x97, 0xcf, 0xee, 0xb3,
    0x56, 0x29, 0x8f, 0x41, 0x9d, 0x8b, 0x8b, 0x62, 0xa8, 0x1a, 0x5c, 0x92, 0xb0, 0xa7, 0xb9, 0xe2, 0xac, 0x48, 0xc2, 0x9d, 0xf3, 0xb9, 0xf1, 0x04, 0xfd, 0x58, 0x04, 0xcb, 0x3f, 0x54, 0x77, 0x2a,
    0x6b, 0xda, 0xc8, 0x1e, 0xfb, 0x40, 0x64, 0x74, 0x48, 0xb7, 0x93, 0x96, 0x67, 0xb1, 0xfa, 0x18, 0xc7, 0x54, 0xa9, 0x20, 0x7b, 0x25, 0x2f, 0x50, 0x00, 0x18, 0xee, 0x5e, 0x1f, 0xc2, 0xb6, 0xda,
    0xe1, 0xa4, 0x20, 0xa0, 0x36, 0x8a, 0x7a, 0xde, 0x0d, 0x3e, 0x60, 0xa6, 0x4f, 0x00, 0xb2, 0x80, 0x33, 0x2b, 0x1c, 0xe1, 0x8e, 0x8a, 0x64, 0xb0, 0x1a, 0x8a, 0x44, 0x9f, 0xc9, 0x20, 0x35, 0x5a,
    0x73, 0x32, 0x6e, 0xad, 0xad, 0xaa, 0xe5, 0x48, 0xc7, 0xf5, 0xa5, 0x48, 0xd0, 0xfc, 0x8c, 0x75, 0xd5, 0x6d, 0xd0, 0xf8, 0x2c, 0x8a, 0x4c, 0x9d, 0xd6, 0x59, 0x50, 0x77, 0xfc, 0xb9, 0x65, 0x98,
    0x76, 0x17, 0x96, 0x0f, 0x85, 0xf8, 0x7f, 0x38, 0xab, 0xea, 0xb7, 0x5e, 0x54, 0x78, 0xd8, 0xb8, 0x40, 0x4d, 0x6c, 0xe1, 0x19, 0xee, 0x41, 0xd5, 0x8d, 0xdc, 0xb0, 0xdd, 0xe1, 0x0a, 0xae, 0x08,
    0xcd, 0xba, 0xa1, 0xb6, 0xe1, 0xe6, 0x5e, 0xe0, 0x0c, 0x48, 0x99, 0x58, 0xf5, 0x44, 0xf7, 0x1a, 0xbc, 0x6e, 0x68, 0xe3, 0x31, 0x39, 0xd0, 0x57, 0x93, 0xae, 0xd2, 0x76, 0x5e, 0xe9, 0x1f, 0xb3,
    0xda, 0xe4, 0x08, 0xf6, 0xc4, 0x29, 0xb0, 0xe7, 0x00, 0xc3, 0x4c, 0x4d, 0x72, 0xc1, 0xe0, 0x5e, 0x7e, 0x1f, 0x90, 0x96, 0x14, 0x51, 0xb0, 0xe1, 0xd2, 0x71, 0x53, 0x80, 0x4f, 0xb6, 0xc8, 0x7a,
    0xe2, 0x7f, 0x11, 0x28, 0xac, 0xa3, 0x83, 0x76, 0x01, 0x53, 0x79, 0x12, 0x52, 0x1a, 0x15, 0xa7, 0xb7, 0xd9, 0xf6, 0x06, 0x15, 0x49, 0xc8, 0xb1, 0x60, 0xd2, 0x94, 0x11, 0x31, 0x6a, 0x60, 0x2a,
    0xb1, 0x7a, 0x61, 0xa4, 0x5f, 0x9b, 0x70, 0x4d, 0xa6, 0x8d, 0xed, 0x26, 0x9e, 0x64, 0x95, 0x9d, 0xe5, 0xa0, 0xca, 0xc1, 0x47, 0xbf, 0xe0, 0x1e, 0xae, 0x00, 0xe0, 0xc5, 0x31, 0x1b, 0x98, 0xd8,
    0x3c, 0x81, 0x6c, 0x60, 0xfa, 0x5a, 0xab, 0x93, 0x79, 0x1f, 0xf5, 0x00, 0xce, 0x65, 0xc0, 0x4a, 0x69, 0xf7, 0x10, 0xf6, 0x70, 0x8a, 0xf9, 0xe4, 0xb1, 0x1c, 0x2a, 0xb2, 0x35, 0x3a, 0xe7, 0xc7,
    0xc0, 0x3f, 0xe1, 0x49, 0xe0, 0xa9, 0x73, 0x13, 0xa1, 0x69, 0xaf, 0xfd, 0xa1, 0xc3, 0x7e, 0x85, 0xbe, 0xfb, 0xe0, 0x14, 0xe1, 0x2f, 0x1a, 0x79, 0x2f, 0x68, 0xa4, 0xb5, 0x73, 0x9b, 0xdf, 0xd1,
    0x45, 0x88, 0x41, 0x27, 0xd4, 0x7f, 0x0f, 0x2b, 0x93, 0xe4, 0x0b, 0x30, 0x07, 0x05, 0x24, 0xe6, 0x5c, 0xd5, 0xb8, 0x03, 0x17, 0x8a, 0x21, 0xde, 0x5b, 0xa9, 0xac, 0xd2, 0x31, 0x14, 0x05, 0x08,
    0x3e, 0xb4, 0xe8, 0x81, 0x4e, 0x38, 0x14, 0x4a, 0x92, 0x41, 0xf0, 0x10, 0x36, 0xc0, 0x9c, 0xaa, 0x44, 0x26, 0x38, 0x84, 0x59, 0x3b, 0xed, 0x45, 0xd6, 0xa4, 0x7b, 0xbf, 0xe4, 0x1f, 0xf2, 0xe3,
    0xc1, 0x34, 0xde, 0xba, 0xb2, 0xd2, 0xc4, 0x1b, 0x27, 0x9e, 0x36, 0x0a, 0x92, 0x88, 0xe1, 0xfe, 0x0d, 0xbe, 0x48, 0xef, 0x88, 0x23, 0x09, 0x90, 0x40, 0x64, 0xc9, 0x44, 0x03, 0xf8, 0x5f, 0x7b,
    0x93, 0xf4, 0x58, 0x1b, 0xc1, 0xda, 0x3c, 0xf1, 0xb4, 0xbd, 0x84, 0x5c, 0x65, 0x0d, 0x82, 0x91, 0x6a, 0x72, 0xae, 0x98, 0x21, 0xac, 0xed, 0x0b, 0xe4, 0xe0, 0x3a, 0x37, 0xb2, 0xe7, 0xb4, 0x76,
    0xa6, 0xbd, 0x2e, 0xa9, 0x12, 0x5d, 0x72, 0x9d, 0xaa, 0x1b, 0x40, 0xc7, 0xad, 0xdb, 0x95, 0x8d, 0x52, 0x6b, 0x0d, 0xbf, 0x56, 0x9c, 0x66, 0x42, 0xba, 0x9d, 0x62, 0x64, 0x84, 0x22, 0x2e, 0xd1,
    0xfc, 0x83, 0x8c, 0xb7, 0xd3, 0x3a, 0xb6, 0x1d, 0x13, 0x40, 0x42, 0x11, 0x43, 0x21, 0xa0, 0x55, 0x15, 0xde, 0x05, 0xee, 0x30, 0x5c, 0x23, 0x1d, 0x9b, 0xd6, 0xf4, 0x35, 0xe1, 0x11, 0xcf, 0x8f,
    0x18, 0x6b, 0xa1, 0x71, 0xf2, 0xde, 0xb0, 0xee, 0x83, 0x0a, 0xe6, 0xe2, 0x1f, 0x9c, 0x2b, 0x57, 0xe5, 0x04, 0x7b, 0x66, 0xc2, 0x8e, 0x1c, 0xf7, 0xef, 0xb8, 0xf1, 0x29, 0x9d, 0x7a, 0x0c, 0x3b,
    0xe4, 0x8e, 0xab, 0xe3, 0xd0, 0x93, 0x8a, 0x3a, 0x21, 0x36, 0x0b, 0x48, 0x2a, 0x63, 0x4b, 0x64, 0x56, 0x3d, 0x8b, 0xf1, 0x23, 0x65, 0x90, 0x7d, 0x3e, 0x7b, 0xf6, 0x4e, 0xa6, 0x83, 0x22, 0xd0,
    0x33, 0xea, 0xb4, 0xbd, 0xb9, 0xc8, 0x3a, 0x0a, 0xa7, 0xcc, 0xd3, 0x37, 0x89, 0x9c, 0x28, 0x64, 0xba, 0xd1, 0xea, 0xef, 0x0c, 0xe5, 0x7f, 0xa3, 0xf0, 0x1f, 0xee, 0xcf, 0x94, 0xc3, 0x1f, 0xd6,
    0x35, 0xbd, 0x02, 0x34, 0x7b, 0x9c, 0x91, 0x46, 0x49, 0x7e, 0x0d, 0x0c, 0x59, 0x5e, 0xeb, 0x59, 0xa9, 0xfb, 0xa6, 0xb9, 0x6f, 0x37, 0x0b, 0x07, 0x59, 0xaa, 0x66, 0x17, 0x09, 0x36, 0xc8, 0xf8,
    0xb8, 0xb9, 0x94, 0xf3, 0xe8, 0xa2, 0xd8, 0x5c, 0x7a, 0xc4, 0x56, 0xbb, 0x4d, 0xda, 0x85, 0xd1, 0x09, 0xb1, 0x6e, 0xa7, 0x0a, 0x95, 0xce, 0xb3, 0xb7, 0x10, 0x4f, 0x5c, 0x15, 0x7a, 0x69, 0xdf,
    0x93, 0x70, 0x03, 0xa2, 0x41, 0x56, 0xaa, 0x9e, 0x09, 0xae, 0x9f, 0x91, 0xbc, 0x55, 0xb2, 0xbf, 0xbe, 0x17, 0xe0, 0xc0, 0xc0, 0xda, 0x8a, 0x24, 0xf9, 0x58, 0x0c, 0xe0, 0xe3, 0x59, 0x2c, 0x8e,
    0x3f, 0xde, 0xc0, 0x08, 0x12, 0x6a, 0x35, 0x42, 0x46, 0xa0, 0x0e, 0xa4, 0x19, 0xb7, 0x80, 0x7a, 0xa1, 0x85, 0xc2, 0xd0, 0xd4, 0x8e, 0x5c, 0x5f, 0xc2, 0x1f, 0x64, 0x5a, 0xec, 0x26, 0x45, 0x25,
    0x58, 0xb9, 0x69, 0x65, 0xa0, 0x75, 0x9a, 0xb2, 0xff, 0x74, 0x84, 0xce, 0xfa, 0x19, 0x56, 0xfa, 0x61, 0x3f, 0xf8, 0x81, 0x5d, 0x2d, 0x96, 0x24, 0x59, 0xd9, 0x20, 0xb7, 0x4f, 0x62, 0xe6, 0x44,
    0x76, 0x6c, 0x2f, 0x91, 0xc4, 0x5a, 0x4f, 0xba, 0x1d, 0xb3, 0xc7, 0x04, 0xb2, 0xaf, 0x06, 0x13, 0x7a, 0x03, 0x0d, 0x98, 0x00, 0xe1, 0xfe, 0x7e, 0xa2, 0x83, 0x5e, 0xa9, 0xe9, 0x51, 0x56, 0x6f,
    0x80, 0xc3, 0x42, 0xa4, 0xe8, 0xb6, 0xda, 0xf1, 0x1d, 0xc6, 0xb5, 0xb3, 0x73, 0x28, 0x14, 0x54, 0xcf, 0x8c, 0xa2, 0x4f, 0xfc, 0x23, 0xd0, 0x53, 0xc1, 0x3f, 0x75, 0x38, 0x9e, 0xd5, 0xeb, 0x5c,
    0x13, 0x8d, 0x59, 0x83, 0x5d, 0x63, 0x23, 0xd7, 0x4b, 0x62, 0x79, 0x83, 0xbc, 0x6d, 0xec, 0x4a, 0x84, 0x6a, 0x11, 0x6e, 0x9c, 0xcf, 0x1f, 0x1f, 0xb6, 0xfe, 0x72, 0xdf, 0x34, 0x17, 0x71, 0x8d,
    0x15, 0x66, 0x21, 0x58, 0x44, 0x13, 0x7e, 0x6f, 0x20, 0x23, 0xbb, 0x83, 0x89, 0xf7, 0xcf, 0xee, 0x76, 0x4b, 0x96, 0xb5, 0xb2, 0x28, 0x8f, 0xce, 0x3f, 0xeb, 0x2c, 0x01, 0xa4, 0xac, 0x88, 0x15,
    0x2d, 0x85, 0x86, 0x04, 0xd4, 0x67, 0x05, 0x9b, 0x2b, 0x4d, 0xdf, 0xc7, 0x52, 0x5e, 0x7d, 0x74, 0x9f, 0x81, 0xc5, 0xaf, 0xab, 0x3c, 0x09, 0x54, 0x2a, 0x39, 0x0d, 0x52, 0xf5, 0x39, 0x82, 0xdf,
    0xc9, 0xb3, 0x8b, 0xa0, 0x10, 0x30, 0x5d, 0x08, 0x70, 0x9e, 0x25, 0x17, 0xf4, 0x01, 0xbf, 0x3d, 0x3a, 0x06, 0xe7, 0xc0, 0xfb, 0x5d, 0x5d, 0x1a, 0xfd, 0xb0, 0xf6, 0x86, 0x52, 0x85, 0xf6, 0xc3,
    0xc2, 0x60, 0x46, 0x38, 0xe9, 0x8a, 0x72, 0x3a, 0xd5, 0xa6, 0xe6, 0x2e, 0xea, 0xda, 0x0f, 0xc2, 0xe7, 0x63, 0xac, 0x01, 0xb7, 0xa3, 0x1c, 0x85, 0x98, 0x9f, 0x7b, 0xa4, 0xc4, 0xe1, 0xb4, 0x6b,
    0xdd, 0x99, 0x3e, 0x55, 0x7f, 0x32, 0x84, 0x74, 0xe2, 0x8c, 0xcc, 0x89, 0xca, 0x19, 0x6b, 0x2c, 0x80, 0xe0, 0x4c, 0x49, 0xa3, 0x29, 0xbf, 0x58, 0xba, 0xda, 0x01, 0xb4, 0xcd, 0xe3, 0xb3, 0x80,
    0xaf, 0x49, 0xf4, 0x47, 0x56, 0x0e, 0x2d, 0x87, 0x00, 0xbb, 0x14, 0x35, 0x8f, 0x0c, 0x15, 0xc9, 0xcc, 0x4f, 0x06, 0x67, 0x7c, 0x69, 0x53, 0xde, 0xc4, 0x6f, 0xa0, 0x14, 0x5a, 0x2d, 0x94, 0xa2,
    0xb1, 0x2d, 0x98, 0x0a, 0xe8, 0xcc, 0xa9, 0x96, 0x6f, 0xe1, 0x3d, 0x63, 0x14, 0x2c, 0xc2, 0x8a, 0xde, 0x80, 0x5c, 0x31, 0xdc, 0x16, 0x18, 0x49, 0x34, 0xe1, 0x5a, 0x06, 0x5f, 0x56, 0x8f, 0x60,
    0xbd, 0x98, 0xa4, 0x1f, 0xac, 0xfd, 0xa8, 0x62, 0x66, 0xbe, 0x76, 0xa3, 0x4c, 0xb1, 0x76, 0x39, 0x0f, 0x49, 0xbd, 0xd6, 0xdc, 0x9a, 0xe9, 0x45, 0x94, 0x06, 0x58, 0x44, 0x2b, 0x26, 0x76, 0x5f,
    0xa0, 0x9a, 0x5c, 0xda, 0x12, 0xcb, 0x27, 0x95, 0xc6, 0xcd, 0x0b, 0xec, 0xf7, 0x01, 0xc5, 0x36, 0x61, 0x69, 0xb4, 0xfa, 0x52, 0xf4, 0xcf, 0x91, 0xe9, 0xd0, 0x40, 0x60, 0x70, 0xf3, 0x28, 0x57,
    0xa7, 0x37, 0xcf, 0x26, 0xc9, 0x36, 0x34, 0x39, 0xbb, 0xd9, 0xa6, 0x51, 0xb4, 0x31, 0x31, 0x05, 0xff, 0x3e, 0x0a, 0x22, 0xc7, 0x87, 0x3b, 0x8d, 0xbe, 0x75, 0xe9, 0xd8, 0xd9, 0xb2, 0xd9, 0x9d,
    0xac, 0x97, 0xd0, 0x5f, 0xd4, 0xce, 0x29, 0xc3, 0x4a, 0x26, 0x00, 0xc1, 0xc3, 0x90, 0x14, 0x48, 0x03, 0xfc, 0x6d, 0x3e, 0xf0, 0x05, 0xad, 0x30, 0x61, 0xe8, 0x2d, 0xdd, 0x8e, 0xa6, 0xa4, 0xf4,
    0xe1, 0xce, 0x2a, 0x8d, 0x5d, 0x98, 0xa1, 0xf6, 0x94, 0xa0, 0xb5, 0xa8, 0x43, 0x53, 0x40, 0x4d, 0x8c, 0x29, 0xe6, 0x00, 0x23, 0x35, 0x05, 0xa2, 0xbc, 0xbf, 0xb1, 0x0c, 0x07, 0x32, 0x2b, 0x91,
    0xab, 0x38, 0x6a, 0x6f, 0xf8, 0x4b, 0x5a, 0x0b, 0x3d, 0x63, 0x69, 0x39, 0xbd, 0x9b, 0x2a, 0x94, 0xf1, 0x26, 0xe8, 0x1a, 0xa2, 0x23, 0x66, 0x6a, 0xf2, 0x84, 0x3b, 0x06, 0x34, 0xfd, 0xa3, 0xbd,
    0x08, 0xf2, 0xf6, 0xbf, 0x79, 0x4d, 0x1a, 0x58, 0xf3, 0xfb, 0x5e, 0x72, 0x78, 0xea, 0x61, 0xee, 0x24, 0x51, 0xd3, 0xd9, 0x4c, 0x33, 0xd6, 0x4a, 0x46, 0x69, 0x2c, 0xa4, 0x53, 0x7e, 0x79, 0xdc,
    0x47, 0x7b, 0x0d, 0x19, 0x74, 0x9a, 0xc6, 0xb5, 0x54, 0x24, 0xf5, 0x25, 0x95, 0x44, 0xa5, 0x4b, 0x6e, 0x69, 0xeb, 0x9d, 0x5f, 0x33, 0xd5, 0x8a, 0x52, 0x98, 0xb7, 0xa2, 0x7e, 0xab, 0x49, 0xc9,
    0x91, 0x43, 0xbd, 0x23, 0x11, 0xa8, 0xe3, 0xc5, 0x16, 0x35, 0xbd, 0x1a, 0xf1, 0x2b, 0x2d, 0x8e, 0x08, 0x05, 0x4a, 0x2c, 0xcb, 0x7c, 0xe7, 0x54, 0x47, 0xf0, 0x77, 0x60, 0x39, 0xfa, 0x1a, 0xf8,
    0x90, 0xcb, 0x21, 0x3e, 0x49, 0x0c, 0x94, 0x84, 0x82, 0x24, 0xd7, 0xd4, 0xb9, 0xa0, 0x18, 0x7a, 0xd3, 0x0c, 0xfa, 0x44, 0xf5, 0xec, 0x97, 0x98, 0x51, 0xf0, 0x62, 0xd2, 0xa1, 0xd0, 0xcc, 0xcb,
    0x83, 0xfb, 0x25, 0xe6, 0xad, 0x93, 0x5e, 0x8e, 0x41, 0x89, 0xea, 0xc1, 0xf3, 0xa8, 0x38, 0x69, 0x2b, 0x56, 0xc4, 0x05, 0xba, 0x66, 0xd8, 0xce, 0x8b, 0x8d, 0xe5, 0xf6, 0xfd, 0x41, 0x5a, 0xd2,
    0x84, 0xe0, 0x53, 0x3a, 0x94, 0x01, 0xce, 0xe0, 0x37, 0x4d, 0x29, 0xd5, 0xfb, 0xd3, 0x64, 0x5e, 0x8c, 0x51, 0x4b, 0xa2, 0xcd, 0x8d, 0x39, 0x8d, 0x91, 0x61, 0xfd, 0x0e, 0xcf, 0x50, 0xa0, 0xc0,
    0xe6, 0x75, 0x70, 0x47, 0x5e, 0x73, 0x07, 0x1e, 0xe6, 0xe0, 0xbc, 0x9e, 0x11, 0xc9, 0x6e, 0xc7, 0x56, 0x75, 0x15, 0xa3, 0x26, 0x76, 0x16, 0x6c, 0xe5, 0x1c, 0x88, 0x47, 0x06, 0xf0, 0x8c, 0x4b,
    0x21, 0xee, 0x61, 0x8e, 0x8a, 0x82, 0xa0, 0xcb, 0xe6, 0x45, 0xe7, 0xab, 0x1c, 0x9b, 0x0e, 0x5a, 0xb0, 0x1d, 0x2e, 0x8b, 0x4e, 0x86, 0x0b, 0x75, 0x17, 0x18, 0x89, 0xab, 0xce, 0x23, 0x9c, 0xd4,
    0x26, 0x65, 0x68, 0x31, 0x45, 0x11, 0xd8, 0xae, 0x26, 0xdf, 0xc3, 0x43, 0x62, 0x86, 0x8c, 0x5f, 0x55, 0x93, 0x8e, 0x8b, 0xc7, 0x26, 0x54, 0xe9, 0x37, 0x96, 0x76, 0x92, 0xca, 0xb3, 0x51, 0x3c,
    0xb4, 0x80, 0x4c, 0xf0, 0xb6, 0x2d, 0x7b, 0xaf, 0x25, 0x52, 0x8d, 0x46, 0xf7, 0x88, 0x8c, 0x59, 0xe9, 0xa6, 0xc6, 0xde, 0xb9, 0xed, 0xea, 0x94, 0x0a, 0x47, 0x0e, 0xb7, 0xee, 0x02, 0xb6, 0x0d,
    0x25, 0xbe, 0x99, 0x1b, 0x14, 0x42, 0x5d, 0x91, 0x26, 0x1d, 0x21, 0x2e, 0x84, 0x6b, 0x6f, 0x1f, 0xe8, 0x7e, 0x23, 0x9f, 0x19, 0xc7, 0x27, 0x61, 0xa7, 0x62, 0xbc, 0xf2, 0xfa, 0x7b, 0xe4, 0xd9,
    0x1d, 0xf6, 0xfa, 0x38, 0x6f, 0x5c, 0xb5, 0x21, 0xd0, 0xfb, 0x8c, 0x2f, 0xec, 0x06, 0x61, 0x92, 0xc3, 0x6b, 0x9c, 0xdc, 0xcf, 0xd5, 0x04, 0xe6, 0x31, 0x32, 0x65, 0x53, 0x99, 0xf3, 0x5f, 0xc5,
    0x55, 0x64, 0x94, 0xc7, 0xd8, 0xe0, 0x4d, 0xf6, 0x4a, 0x3d, 0x94, 0xc1, 0x93, 0x0f, 0x1a, 0x81, 0x90, 0x57, 0x99, 0x1d, 0x28, 0x21, 0x63, 0xaf, 0x2d, 0xce, 0xc3, 0xe9, 0x0f, 0x82, 0xd8, 0x2f,
    0x7e, 0xd5, 0x2b, 0x4e
};


static const BYTE g_XmsskeyShake256_10_256[] = {
    0x00, 0x00, 0x00, 0x10, 0xa1, 0x0e, 0xd2, 0x61, 0x03, 0xda, 0x03, 0xe2, 0x7d, 0xd7, 0xb2, 0x0f,
    0x48, 0xd5, 0x09, 0xc2, 0x82, 0x3c, 0xdb, 0x51, 0x73, 0x3f, 0x68, 0x9c, 0x57, 0x83, 0xf8, 0x70,
    0x15, 0xc6, 0x47, 0x10, 0x62, 0x8d, 0x89, 0x7d, 0x22, 0xf4, 0x82, 0x58, 0x2d, 0x41, 0x70, 0xe8,
    0x2b, 0x04, 0x7b, 0xa1, 0x4d, 0x9c, 0x6d, 0xf6, 0xbd, 0x37, 0x0b, 0x47, 0x36, 0xff, 0x8c, 0x96,
    0x5e, 0x68, 0xca, 0xc4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe5, 0xb9, 0xae, 0xa7,
    0x88, 0x59, 0x0c, 0x3e, 0xca, 0xfc, 0xff, 0x89, 0x1c, 0x59, 0x66, 0x33, 0xf2, 0xc1, 0x4d, 0x2a,
    0x65, 0x56, 0xc9, 0xbd, 0x33, 0x94, 0xa8, 0xe3, 0x22, 0xcd, 0x31, 0x44, 0x19, 0x47, 0x5f, 0x9b,
    0x7a, 0x28, 0x53, 0xef, 0x9f, 0xec, 0xea, 0xb8, 0xa3, 0x60, 0x65, 0x8b, 0x39, 0x70, 0x98, 0x51,
    0x14, 0xf2, 0x46, 0x85, 0x4d, 0x52, 0x9b, 0x6d, 0x95, 0xbc, 0x2f, 0x6f
};

static const BYTE g_XmssSigShake256_10_256[] = {
    0x00, 0x00, 0x00, 0x01, 0x03, 0x27, 0x9e, 0x44, 0x0c, 0x8e, 0xbb, 0x08, 0x92, 0x2a, 0xc0, 0x50, 0xeb, 0x10, 0xad, 0xc4, 0x44, 0xdc, 0x5a, 0x29, 0x66, 0x69, 0x52, 0xbb, 0x25, 0x87, 0x73, 0x52,
    0x3e, 0x8d, 0xfe, 0x40, 0x49, 0x4a, 0xff, 0x60, 0x15, 0xd8, 0x7e, 0x49, 0x9a, 0x7e, 0xb2, 0x25, 0x9d, 0x77, 0x3f, 0x14, 0xa7, 0x9a, 0x7f, 0x2d, 0x90, 0x2d, 0x23, 0xf0, 0x56, 0xb4, 0xb2, 0x8f,
    0x1e, 0x75, 0x9d, 0xd4, 0x76, 0x1e, 0x24, 0x82, 0x8a, 0xa0, 0x56, 0xfa, 0x1f, 0xc0, 0xa7, 0x9d, 0x2d, 0x7c, 0x28, 0xc9, 0x52, 0xa9, 0x06, 0xb9, 0x57, 0x2f, 0x0e, 0x46, 0xfe, 0x41, 0x6d, 0x0d,
    0x2d, 0xb3, 0xab, 0x7e, 0x5a, 0xb8, 0x45, 0x00, 0xa0, 0x37, 0x13, 0x79, 0xd6, 0x07, 0xd0, 0x2f, 0x40, 0x22, 0x30, 0x03, 0xd8, 0xdd, 0x0c, 0xc5, 0xf6, 0xc8, 0x77, 0xc0, 0x17, 0x96, 0xff, 0x78,
    0xee, 0x94, 0x55, 0xc1, 0x63, 0xd7, 0x45, 0xa5, 0x21, 0xf9, 0x29, 0xa9, 0xb0, 0xd2, 0x39, 0x64, 0x50, 0xfe, 0x53, 0xa7, 0xcd, 0x65, 0xf7, 0x90, 0x7c, 0x6f, 0x90, 0xa4, 0xfe, 0xe3, 0xb4, 0x04,
    0x60, 0x49, 0x1e, 0x12, 0xfe, 0x0c, 0x4b, 0xb0, 0xf2, 0x59, 0xc6, 0x0f, 0x03, 0xc5, 0xfe, 0xad, 0x8d, 0x95, 0xc5, 0x6e, 0xf2, 0xd8, 0x83, 0x1e, 0x08, 0x9a, 0x10, 0x12, 0xf5, 0x1d, 0xac, 0xd5,
    0xa5, 0x2f, 0x86, 0x21, 0x81, 0x81, 0xde, 0x40, 0xf4, 0xf5, 0x07, 0x32, 0xa2, 0x34, 0x90, 0x9a, 0x4c, 0x3a, 0x38, 0xb2, 0x4a, 0x86, 0x17, 0x40, 0xf1, 0x76, 0x82, 0xb4, 0xee, 0x22, 0x69, 0x5c,
    0x33, 0x2b, 0xb7, 0xbd, 0x35, 0xbf, 0x39, 0xba, 0x99, 0x65, 0x38, 0x63, 0xc0, 0x3b, 0x47, 0x38, 0x13, 0x94, 0x0c, 0x11, 0x49, 0x04, 0x3a, 0x59, 0x08, 0x2f, 0x9f, 0xe6, 0x9b, 0x34, 0x57, 0xc7,
    0x32, 0x21, 0xbd, 0x8f, 0xda, 0x44, 0x6b, 0xfc, 0xc5, 0x05, 0x3a, 0x5f, 0xcb, 0x37, 0x9a, 0x6f, 0x07, 0x4b, 0x5b, 0x7d, 0xef, 0x57, 0x4c, 0xcc, 0xaa, 0x03, 0xd9, 0x84, 0x0f, 0x7e, 0xcf, 0x93,
    0x45, 0x1c, 0xf5, 0x87, 0xc3, 0x14, 0x3f, 0x80, 0x12, 0x54, 0xb5, 0x12, 0x66, 0xc5, 0xbb, 0xf8, 0x67, 0x7b, 0x67, 0x9a, 0x72, 0x21, 0x8f, 0x18, 0x71, 0x51, 0x69, 0xd5, 0x9c, 0x3d, 0x65, 0xe5,
    0x69, 0x62, 0x0d, 0xd2, 0xac, 0x4e, 0x6f, 0x8a, 0x17, 0xc7, 0x6d, 0x25, 0x0c, 0xce, 0xe5, 0x19, 0x8b, 0xf8, 0x14, 0xb8, 0x01, 0xc0, 0x55, 0xb3, 0xfa, 0x50, 0x4a, 0xcc, 0xe6, 0x54, 0xf7, 0xe8,
    0x68, 0x59, 0x41, 0x15, 0xd5, 0x5a, 0x43, 0x1b, 0xa0, 0x78, 0x06, 0x35, 0xb8, 0xd5, 0xae, 0x9f, 0xb7, 0x0b, 0xa0, 0x11, 0xa4, 0x33, 0xfc, 0x2c, 0x8d, 0xe5, 0xa3, 0x62, 0xce, 0x6a, 0xbd, 0x13,
    0xb8, 0xdb, 0x82, 0xaf, 0x2e, 0x74, 0x65, 0x26, 0xa4, 0x77, 0xb0, 0xba, 0x75, 0xf2, 0x9a, 0x87, 0x3c, 0x84, 0x2d, 0x9d, 0xc6, 0x5b, 0x30, 0xac, 0x6f, 0x90, 0x07, 0xeb, 0xb0, 0x5f, 0x0c, 0xaf,
    0x0c, 0xf6, 0xf6, 0xea, 0xae, 0x8e, 0x9e, 0x41, 0xa0, 0x0f, 0x73, 0xad, 0x8c, 0x67, 0xb8, 0x9a, 0x21, 0x6f, 0xfe, 0xc2, 0xdb, 0xa0, 0x17, 0xed, 0xfe, 0x40, 0xc9, 0xb0, 0x12, 0x6c, 0x9a, 0x10,
    0x5a, 0x5b, 0xc4, 0x8f, 0x97, 0x49, 0x3a, 0x86, 0x64, 0xf1, 0x3c, 0x38, 0x96, 0xa9, 0x38, 0x9c, 0x3b, 0x17, 0x57, 0xa6, 0x83, 0x18, 0xea, 0x41, 0x6b, 0xd4, 0xde, 0x3f, 0x3d, 0x4b, 0xf6, 0x80,
    0x05, 0xba, 0x3a, 0x2e, 0x94, 0xa6, 0x43, 0x67, 0x9f, 0x88, 0x7d, 0x19, 0x80, 0xb7, 0xfb, 0x43, 0x23, 0xaf, 0x43, 0x3b, 0xe5, 0xfd, 0x0f, 0x10, 0xa1, 0x2a, 0x4c, 0xf5, 0x11, 0x47, 0xbe, 0xc6,
    0x78, 0x52, 0x89, 0x00, 0xf0, 0xa2, 0x84, 0xee, 0x2a, 0x45, 0xf6, 0x18, 0x3d, 0x7f, 0x38, 0xba, 0x01, 0x93, 0xcb, 0x03, 0xee, 0xd4, 0x50, 0x06, 0xee, 0xab, 0xc0, 0x16, 0x17, 0x26, 0x36, 0x86,
    0x4c, 0x44, 0x66, 0xe4, 0x34, 0xef, 0x0d, 0x91, 0x2c, 0x68, 0xaf, 0x03, 0xb8, 0x5d, 0x9d, 0x59, 0xa0, 0xc8, 0x30, 0xff, 0x8f, 0x3b, 0xb4, 0xbb, 0x3b, 0xaa, 0xcb, 0xb0, 0x2d, 0x88, 0x63, 0x59,
    0xaf, 0x86, 0x3d, 0xb9, 0xbd, 0xb8, 0x3a, 0x72, 0x62, 0xa3, 0xa5, 0x40, 0x50, 0x09, 0x1a, 0x65, 0x32, 0xfb, 0xb6, 0x5a, 0x49, 0xf8, 0x39, 0xef, 0xf6, 0xf7, 0xba, 0xfc, 0x1e, 0x75, 0xa8, 0xed,
    0x34, 0x4c, 0x4b, 0x4f, 0xce, 0x44, 0xaa, 0x0c, 0xa3, 0x71, 0x05, 0x02, 0x39, 0x23, 0xa2, 0x60, 0x57, 0x49, 0x55, 0x03, 0x69, 0xdf, 0x38, 0x49, 0xa0, 0x89, 0xd7, 0x45, 0x72, 0x8d, 0xce, 0xc6,
    0x1c, 0xb0, 0xcb, 0xa7, 0x0b, 0x4f, 0xc4, 0x92, 0x7c, 0xca, 0x18, 0x38, 0x2e, 0xd6, 0x1b, 0x6f, 0x4e, 0xe8, 0x54, 0x07, 0x5a, 0x66, 0x1a, 0x68, 0xa2, 0xc4, 0xd0, 0xdf, 0xd5, 0x05, 0x77, 0xa6,
    0x5a, 0xbb, 0xa4, 0xcc, 0xf4, 0x1c, 0x5a, 0xc7, 0x8e, 0x38, 0xd7, 0x21, 0xc3, 0x28, 0xb0, 0x79, 0x57, 0x38, 0x31, 0x05, 0xb1, 0x1e, 0xe9, 0xd0, 0x95, 0x49, 0x8a, 0x33, 0xf2, 0x47, 0x7b, 0x55,
    0x3b, 0x7f, 0x49, 0xed, 0x22, 0x6a, 0x50, 0xab, 0xc1, 0x9d, 0x64, 0xf7, 0x11, 0x60, 0xa4, 0x71, 0x15, 0x95, 0x1d, 0x55, 0x2b, 0x42, 0x69, 0x4a, 0x78, 0x95, 0xbc, 0xc3, 0xf9, 0x08, 0x07, 0x80,
    0x2e, 0x2b, 0xe7, 0xde, 0x24, 0x39, 0xd4, 0x49, 0x08, 0x5a, 0x1b, 0x5f, 0x55, 0x19, 0x55, 0xd2, 0x8a, 0xbd, 0xec, 0x95, 0xf9, 0x90, 0xbd, 0x31, 0xd3, 0x52, 0x16, 0x3e, 0x56, 0xec, 0x87, 0x05,
    0xc7, 0x26, 0x0d, 0xfd, 0xe3, 0xe9, 0x0f, 0x00, 0x82, 0x01, 0x3b, 0x5a, 0xd8, 0xef, 0x62, 0xb5, 0x37, 0x63, 0x34, 0x77, 0x8b, 0xbf, 0xc4, 0x5d, 0xe3, 0xfe, 0xfc, 0x06, 0xe8, 0x50, 0xcb, 0x2c,
    0xd8, 0x66, 0xe1, 0xf0, 0xff, 0x2a, 0xad, 0x11, 0x0d, 0xfd, 0xf4, 0xd7, 0x2c, 0x1a, 0x45, 0xc7, 0xdf, 0x29, 0xac, 0x1f, 0xab, 0x49, 0x68, 0x30, 0xdf, 0x0e, 0xd5, 0x6b, 0xa0, 0x70, 0xc9, 0x8b,
    0xf1, 0x46, 0xb8, 0x0c, 0x7e, 0xee, 0x28, 0xb5, 0xba, 0xcd, 0xeb, 0xd8, 0xf2, 0x81, 0x1a, 0x54, 0xa6, 0x7b, 0x25, 0x90, 0x17, 0x1a, 0x26, 0xf1, 0x5b, 0x59, 0xea, 0xbf, 0xd3, 0xdb, 0xa4, 0x99,
    0x00, 0xf0, 0x0c, 0xa4, 0x36, 0x2a, 0xa1, 0xe4, 0x70, 0x51, 0x17, 0x3b, 0x60, 0xb9, 0x0e, 0x61, 0x9f, 0x4c, 0x86, 0x6a, 0x84, 0x4b, 0x6d, 0x14, 0x09, 0x11, 0x28, 0x89, 0xfb, 0x42, 0xf4, 0x75,
    0xc6, 0x49, 0x2a, 0x17, 0x01, 0x02, 0x34, 0x5f, 0x2a, 0x4b, 0xa5, 0x69, 0xce, 0x1f, 0xad, 0x58, 0x0b, 0x22, 0xb3, 0x06, 0xd4, 0xde, 0x56, 0xd4, 0xf3, 0x73, 0x55, 0x35, 0xbb, 0xf0, 0x1a, 0x7d,
    0x99, 0x9e, 0x21, 0x98, 0xdb, 0x12, 0x22, 0xf8, 0xac, 0xbf, 0x53, 0xef, 0xc6, 0x86, 0x05, 0x68, 0x18, 0xe8, 0x0f, 0x23, 0x53, 0x20, 0x60, 0x24, 0x09, 0x5c, 0x11, 0xf2, 0xaf, 0xb3, 0x86, 0xb4,
    0x60, 0x1b, 0xb4, 0x2b, 0x95, 0x3f, 0xb4, 0xc0, 0x1e, 0x08, 0x81, 0x08, 0x3c, 0x23, 0x1a, 0x5e, 0x18, 0xfb, 0x1c, 0xb2, 0x8a, 0x4b, 0xaa, 0x13, 0x13, 0xcf, 0x84, 0x7d, 0x1b, 0x5b, 0xc3, 0x54,
    0x32, 0x7a, 0x2f, 0xc1, 0x41, 0x69, 0x0d, 0xc8, 0x0c, 0x07, 0x26, 0x30, 0xbc, 0x32, 0x6a, 0x06, 0x17, 0x0a, 0xa9, 0x78, 0x3e, 0x06, 0x52, 0x1f, 0x67, 0xbc, 0xe3, 0x41, 0x43, 0xb4, 0x9f, 0xe3,
    0x28, 0x0e, 0xca, 0xb7, 0x89, 0xb0, 0x09, 0xb6, 0x4c, 0xed, 0xa5, 0xb4, 0xc5, 0x4d, 0xa1, 0x3f, 0xde, 0x01, 0x4e, 0x16, 0x4e, 0x39, 0xf4, 0xae, 0x68, 0x83, 0xbd, 0x4c, 0x25, 0xd4, 0x77, 0x0c,
    0x4c, 0x56, 0x02, 0x2d, 0x40, 0xff, 0x37, 0xbc, 0xe4, 0xac, 0xc0, 0x96, 0xc3, 0x1f, 0x0b, 0xc7, 0x19, 0x3e, 0x25, 0x1a, 0x44, 0x83, 0x34, 0x3e, 0xc9, 0xf5, 0x97, 0xab, 0xcd, 0xb2, 0x31, 0xf0,
    0x02, 0xac, 0x65, 0xd2, 0xb2, 0x9e, 0x3b, 0xfc, 0xcf, 0x77, 0x12, 0x6c, 0xae, 0x8c, 0x2d, 0xfe, 0xd9, 0x4c, 0x78, 0x66, 0x38, 0xfc, 0x9e, 0x1b, 0x90, 0x7f, 0xd6, 0x21, 0x7e, 0x6c, 0x0b, 0x5e,
    0x7c, 0x81, 0xa8, 0x8c, 0xd7, 0x45, 0xc7, 0x05, 0x8c, 0xb3, 0x2c, 0x0c, 0x34, 0x18, 0xcf, 0x0d, 0x43, 0x76, 0x4f, 0xd1, 0xd4, 0xe2, 0xe8, 0x26, 0x8a, 0x3a, 0x9f, 0x93, 0xc7, 0x5c, 0x77, 0x0a,
    0x88, 0x44, 0xe7, 0x2c, 0xdc, 0xcf, 0x48, 0xea, 0xf4, 0x1d, 0x3f, 0x01, 0x13, 0xd3, 0x92, 0xa9, 0x57, 0x5d, 0x2e, 0x68, 0x77, 0x73, 0x0b, 0xf8, 0x13, 0x3d, 0xcc, 0xb8, 0x89, 0x46, 0x93, 0xb2,
    0x58, 0xf9, 0xc7, 0x70, 0xd6, 0xec, 0x68, 0x9a, 0x66, 0xf8, 0x00, 0x76, 0x68, 0x67, 0xf7, 0xf5, 0xda, 0x98, 0x78, 0x13, 0xf5, 0x82, 0x4e, 0xce, 0xd6, 0x33, 0x67, 0x0f, 0x61, 0xf1, 0x0e, 0x95,
    0xa7, 0x9d, 0x85, 0x65, 0x2c, 0x1d, 0x49, 0xfc, 0x05, 0xcc, 0xe0, 0xd9, 0xbc, 0xf3, 0x2b, 0xc5, 0x7c, 0x18, 0x61, 0x76, 0xb7, 0x9e, 0x2f, 0x08, 0xf6, 0x4a, 0x7d, 0x1a, 0x18, 0xaf, 0x9c, 0x3c,
    0x2a, 0x7d, 0x5e, 0x91, 0xe1, 0xf8, 0x87, 0x6e, 0xb1, 0x51, 0xa4, 0x70, 0xfa, 0x3d, 0x8f, 0x07, 0x36, 0x35, 0xaa, 0xa6, 0x86, 0x67, 0xca, 0x11, 0x7c, 0x95, 0x12, 0x9e, 0x6e, 0xc5, 0xba, 0x6b,
    0x91, 0x9c, 0x05, 0x28, 0x39, 0x33, 0x94, 0x31, 0xe3, 0xbf, 0x78, 0x04, 0x30, 0x12, 0x36, 0xc1, 0x7d, 0xa2, 0xad, 0x2f, 0xfd, 0x27, 0xa8, 0x87, 0x0b, 0x8e, 0xda, 0x54, 0x26, 0x62, 0x2a, 0x1d,
    0x79, 0xc6, 0x5b, 0x89, 0xec, 0x32, 0x70, 0x89, 0x01, 0xea, 0x61, 0xe9, 0x7c, 0xd7, 0xfe, 0x79, 0x63, 0xb9, 0xe8, 0xd2, 0x20, 0xff, 0xa4, 0x48, 0x96, 0xb3, 0x16, 0x6c, 0x94, 0x65, 0xb2, 0xb1,
    0x19, 0xe5, 0x19, 0xda, 0x8d, 0xc0, 0x82, 0x20, 0x3b, 0x3e, 0xae, 0xf6, 0x9d, 0x2e, 0xcd, 0x85, 0x11, 0x5d, 0xcc, 0x70, 0x56, 0x61, 0xdd, 0x40, 0x9c, 0xfe, 0xa4, 0xfc, 0xee, 0xe0, 0xa2, 0xc3,
    0x20, 0x8e, 0xe5, 0xbd, 0x6b, 0xa0, 0xcc, 0x0d, 0xcf, 0xb6, 0x8a, 0x41, 0x7b, 0xed, 0xcd, 0x4a, 0x84, 0xcf, 0xde, 0xe6, 0x30, 0xab, 0x4a, 0xf9, 0xd1, 0x97, 0x33, 0x3f, 0xb2, 0x39, 0x0e, 0xa2,
    0x12, 0xb4, 0x72, 0x2a, 0xcc, 0x85, 0x15, 0x37, 0x53, 0x77, 0x42, 0x76, 0xbc, 0x1a, 0x9c, 0x97, 0x22, 0x2c, 0xd5, 0xe6, 0xd4, 0x0d, 0xa4, 0xe0, 0xda, 0x28, 0xc3, 0x8a, 0x8e, 0x45, 0xd0, 0x9d,
    0x96, 0x00, 0x24, 0xd0, 0xd4, 0x99, 0xea, 0xdd, 0x10, 0xd6, 0x16, 0xa6, 0x3a, 0x79, 0x04, 0xca, 0xc1, 0xf3, 0x02, 0xa5, 0xbf, 0x98, 0xab, 0x6b, 0x8e, 0x44, 0xbb, 0x77, 0x80, 0x9e, 0x18, 0x37,
    0xe6, 0xf5, 0x1a, 0xd8, 0xe8, 0x3e, 0x99, 0xe8, 0xad, 0xdc, 0x9b, 0x77, 0x07, 0xa2, 0x6a, 0xcf, 0x7d, 0x5f, 0x12, 0xdd, 0x4f, 0xf8, 0x7f, 0x04, 0x5c, 0x17, 0xbf, 0x97, 0x52, 0xd0, 0xc0, 0x1a,
    0x5f, 0xa0, 0x6e, 0x8c, 0xc5, 0x9a, 0xef, 0xef, 0xc5, 0x0d, 0x30, 0x17, 0xe7, 0xcc, 0x51, 0xbe, 0x70, 0xf1, 0xb8, 0x21, 0xa4, 0x8e, 0x99, 0x1f, 0x0e, 0x64, 0x93, 0xcb, 0x62, 0x03, 0xbd, 0x29,
    0x35, 0x8e, 0x46, 0x75, 0x0a, 0x2c, 0xfe, 0x1e, 0x11, 0x35, 0xca, 0x2d, 0xd0, 0x72, 0x16, 0xb6, 0xf8, 0x70, 0xcc, 0x31, 0x2f, 0xaa, 0x4a, 0x20, 0x74, 0x85, 0x12, 0x7e, 0x83, 0xae, 0x37, 0xd1,
    0xee, 0x3c, 0x84, 0x9f, 0xf7, 0x3f, 0xf8, 0x29, 0x70, 0xf7, 0x14, 0x0c, 0x5c, 0x3c, 0x9a, 0x87, 0xaa, 0x44, 0xf8, 0x33, 0x08, 0x01, 0x49, 0x25, 0x8f, 0x38, 0x6f, 0xf5, 0xc3, 0x78, 0x24, 0x72,
    0x48, 0x0c, 0x90, 0xfa, 0x8e, 0x43, 0x41, 0x4c, 0xb1, 0x84, 0xf8, 0x89, 0x7e, 0x85, 0x43, 0x9d, 0x94, 0x15, 0xef, 0xa8, 0xcc, 0xb2, 0xa1, 0x34, 0x7b, 0xc9, 0x60, 0xbb, 0xe0, 0xc2, 0x82, 0x57,
    0x2d, 0x5b, 0x4a, 0xdc, 0x23, 0x9e, 0xda, 0xd4, 0x2e, 0xfa, 0x16, 0x43, 0x40, 0xe6, 0x1d, 0xca, 0x6c, 0x08, 0x54, 0x2b, 0x28, 0x4b, 0x85, 0x28, 0x2b, 0x86, 0xf8, 0x73, 0x2e, 0x86, 0x52, 0x9a,
    0xce, 0x67, 0x3b, 0x30, 0x49, 0xc8, 0xaf, 0xa5, 0x17, 0x68, 0x77, 0x94, 0x2d, 0x7a, 0x3b, 0x82, 0x35, 0x4a, 0x5a, 0x19, 0xfd, 0x99, 0xbb, 0x80, 0xda, 0x7d, 0x4b, 0xae, 0x9f, 0x3e, 0x5f, 0x3d,
    0x8f, 0xff, 0x66, 0x7e, 0xe1, 0x37, 0xa9, 0xcb, 0xae, 0x9c, 0xf0, 0x95, 0xfa, 0xb2, 0x42, 0x32, 0x85, 0x42, 0xb7, 0x99, 0x17, 0xa4, 0xe1, 0x0f, 0x40, 0x2b, 0x3f, 0xc6, 0x6e, 0xe6, 0x0b, 0xe4,
    0x8a, 0x7b, 0x35, 0x25, 0x5d, 0x18, 0x57, 0x64, 0x3e, 0x10, 0xd6, 0x5b, 0xdb, 0x19, 0x6a, 0xba, 0xf6, 0x9b, 0x4c, 0xc6, 0xaf, 0x4c, 0x57, 0x68, 0xde, 0xd7, 0xcf, 0x22, 0x21, 0xb0, 0x0a, 0x3f,
    0x74, 0x68, 0x0f, 0xcb, 0xde, 0xdc, 0x52, 0x7b, 0x9c, 0x1a, 0xa5, 0x30, 0xa2, 0xbb, 0x5e, 0x00, 0x18, 0x9b, 0xec, 0x30, 0x71, 0xbe, 0x5e, 0x4b, 0x40, 0xc1, 0xf1, 0x6e, 0xc2, 0xf3, 0x8c, 0x9a,
    0x5a, 0xa8, 0x44, 0x61, 0x8e, 0x76, 0x6f, 0xe1, 0x59, 0x93, 0x7c, 0x0e, 0x3c, 0x2a, 0x6a, 0x77, 0x0f, 0xf9, 0x12, 0xf0, 0x13, 0x11, 0x51, 0x47, 0xe0, 0xc5, 0x25, 0xd2, 0xa3, 0x90, 0xc2, 0x75,
    0x1d, 0x45, 0x28, 0xe0, 0xc7, 0x24, 0x4a, 0xef, 0xf0, 0xbe, 0xd7, 0x32, 0x1d, 0x20, 0x08, 0x94, 0x20, 0x01, 0x06, 0x37, 0x73, 0x22, 0x18, 0xc9, 0x75, 0xd0, 0xf7, 0xc0, 0x1f, 0xaf, 0xf6, 0x04,
    0x8f, 0x3a, 0x87, 0x9c, 0x36, 0xfb, 0xe3, 0x9a, 0x2a, 0xf7, 0xf8, 0xc3, 0x08, 0xc2, 0x65, 0x4e, 0x60, 0x80, 0xa7, 0xff, 0x36, 0xd0, 0x71, 0x12, 0x04, 0x72, 0x77, 0xbe, 0x97, 0x66, 0x65, 0x70,
    0xf1, 0x01, 0x4b, 0x4b, 0x91, 0xd1, 0xb3, 0x8b, 0xb1, 0x2a, 0x05, 0xfa, 0xf1, 0x90, 0xa3, 0xf8, 0xad, 0x82, 0x28, 0xe5, 0xe2, 0xc0, 0x94, 0xae, 0xa9, 0x32, 0xbe, 0x2a, 0x5d, 0x36, 0xc3, 0x72,
    0x32, 0x38, 0xb4, 0x9b, 0x7e, 0xda, 0x0b, 0x15, 0xa5, 0xaf, 0x83, 0x59, 0xe9, 0x88, 0x3f, 0x3a, 0x21, 0x5d, 0xfd, 0x38, 0x7a, 0x0d, 0x62, 0x7f, 0x5a, 0x8e, 0xbb, 0x80, 0x4f, 0xd2, 0x71, 0xdf,
    0xa3, 0x86, 0xf8, 0x2b, 0x36, 0x0c, 0x2b, 0x4c, 0x99, 0x18, 0xd4, 0x97, 0xb9, 0x7b, 0xf4, 0xcd, 0x38, 0xbc, 0xd1, 0x71, 0xe4, 0xfa, 0xe3, 0xe4, 0xa9, 0xcd, 0x96, 0x2b, 0x8a, 0x30, 0x2c, 0x8f,
    0xd0, 0xa8, 0xc3, 0xfd, 0x7d, 0x44, 0xf0, 0x8b, 0xbd, 0x09, 0xd7, 0x97, 0xab, 0x6e, 0x27, 0x90, 0xd4, 0x24, 0x53, 0xbc, 0x5e, 0x8c, 0x1b, 0x6a, 0xdf, 0x12, 0x19, 0x95, 0x5b, 0x75, 0x3e, 0x53,
    0x56, 0x45, 0x6a, 0x08, 0x96, 0x41, 0x40, 0x9f, 0xba, 0x14, 0x50, 0x5b, 0xca, 0x89, 0x2c, 0x89, 0x59, 0xd0, 0x24, 0x20, 0xd4, 0x5d, 0xc8, 0xe0, 0x89, 0xd4, 0x9a, 0xc6, 0x9b, 0x74, 0x81, 0xf5,
    0xc6, 0x41, 0x6d, 0xf8, 0xa9, 0x7f, 0x88, 0xe0, 0x94, 0xaf, 0xa8, 0xae, 0x2b, 0x8f, 0x7e, 0x61, 0x57, 0xb9, 0x99, 0xb1, 0x44, 0x86, 0x13, 0x89, 0x54, 0x15, 0x38, 0x29, 0xa1, 0x4a, 0x0b, 0xbb,
    0x71, 0x88, 0x05, 0x31, 0x04, 0xbd, 0x8e, 0x25, 0xc5, 0x7a, 0x87, 0x90, 0xb1, 0x1d, 0x4d, 0x92, 0xed, 0xbd, 0x79, 0xce, 0xf4, 0x31, 0x23, 0x95, 0xd9, 0xa2, 0x68, 0x54, 0x32, 0xf7, 0x7d, 0xf7,
    0x23, 0x1d, 0xf1, 0xc6, 0xeb, 0x1f, 0x75, 0xbd, 0x4c, 0xbb, 0xd3, 0x65, 0xb8, 0x92, 0x96, 0xc4, 0xf7, 0xc9, 0x89, 0x58, 0x98, 0xbb, 0xf8, 0x5a, 0xd3, 0xdb, 0x3e, 0x7a, 0x9a, 0xf4, 0x98, 0x0a,
    0x91, 0xfd, 0x2e, 0x68, 0xc6, 0x09, 0xed, 0xac, 0xbb, 0xe3, 0x58, 0x45, 0xb9, 0x5e, 0xd7, 0x62, 0x45, 0xe4, 0xcc, 0x29, 0x71, 0xc1, 0x24, 0x6a, 0x3b, 0x6a, 0x79, 0xbf, 0xe9, 0xff, 0x16, 0xa1,
    0x57, 0x40, 0xc6, 0x30, 0x82, 0xe1, 0x92, 0xb1, 0x00, 0x20, 0xab, 0xbf, 0x03, 0xda, 0xb4, 0x8c, 0x67, 0x86, 0xd4, 0x95, 0xd3, 0x5b, 0xbc, 0xc0, 0xf9, 0xce, 0x54, 0x7a, 0x94, 0x2d, 0x73, 0x0d,
    0x1c, 0x0d, 0xcd, 0x83, 0xf2, 0xe8, 0xed, 0xed, 0x6c, 0xaa, 0xa6, 0x9e, 0x7f, 0x7b, 0x7a, 0x51, 0x6f, 0x2c, 0xa7, 0xb8, 0x28, 0x55, 0xb6, 0xcf, 0x89, 0xfb, 0x33, 0x3a, 0x1b, 0x93, 0xd0, 0x44,
    0x32, 0xac, 0x7d, 0x49, 0x98, 0x2d, 0xd7, 0x48, 0xa2, 0x39, 0xbf, 0xc3, 0x75, 0xa9, 0xd0, 0x8c, 0x07, 0xdb, 0x7c, 0x77, 0x23, 0x3f, 0xa7, 0x2b, 0xa4, 0x22, 0x68, 0xee, 0x86, 0x61, 0x98, 0x77,
    0xb8, 0x6c, 0xf8, 0x37, 0x15, 0x87, 0xdd, 0x78, 0x1b, 0xe2, 0x00, 0x76, 0x1e, 0x92, 0xcc, 0xe0, 0x78, 0x0e, 0xf1, 0x4d, 0xb4, 0xf7, 0xbf, 0x10, 0x77, 0x36, 0xf8, 0x17, 0x53, 0xbd, 0x53, 0x30,
    0x21, 0x18, 0xfa, 0x73, 0x8b, 0xcf, 0xb8, 0xca, 0x03, 0x60, 0x1e, 0xda, 0xaf, 0xfa, 0xec, 0x26, 0x13, 0xf0, 0x47, 0x86, 0x4f, 0x9c, 0x38, 0xa4, 0xb4, 0x9a, 0xba, 0xda, 0x12, 0x54, 0x9d, 0x5a,
    0x40, 0x53, 0x4c, 0xcb, 0xe0, 0x9d, 0x15, 0xd7, 0xf0, 0x7f, 0xfc, 0x04, 0x18, 0x76, 0xc8, 0x06, 0xc9, 0xf1, 0xb8, 0x03, 0x67, 0x21, 0xa3, 0x4e, 0x5b, 0x6e, 0xd9, 0x63, 0xb0, 0x93, 0x56, 0x27,
    0x63, 0x4f, 0x8b, 0xb1, 0x5c, 0x4e, 0x7c, 0x07, 0x22, 0x77, 0xbf, 0xf7, 0x0d, 0x25, 0x56, 0x93, 0xa3, 0x37, 0x4d, 0xfa, 0x52, 0x09, 0xef, 0xa1, 0x61, 0xa9, 0xc9, 0x4c, 0x63, 0xd9, 0xdd, 0xfe,
    0x9c, 0x16, 0x05, 0x93, 0x4b, 0x65, 0xa3, 0x85, 0x5a, 0xda, 0x80, 0xff, 0x11, 0xd7, 0x2f, 0x5b, 0x98, 0x61, 0x23, 0x63, 0x96, 0xd2, 0x8d, 0x5e, 0x21, 0x21, 0xbd, 0x10, 0x3a, 0xfc, 0xb7, 0x17,
    0x07, 0xe3, 0xec, 0x03, 0xda, 0xfd, 0x47, 0xfe, 0xcf, 0xed, 0x93, 0xa1, 0xcf, 0xb8, 0xba, 0x57, 0xf1, 0x1b, 0x31, 0x87, 0xb0, 0x72, 0x2b, 0x4f, 0x0c, 0xfa, 0xa4, 0x55, 0x45, 0xaa, 0xc2, 0x5d,
    0x1a, 0x98, 0x5b, 0x25, 0x85, 0x87, 0x8a, 0xb4, 0x03, 0x0a, 0x8c, 0x5a, 0x04, 0x27, 0xa4, 0x1e, 0xfb, 0xd5, 0xa5, 0xd2, 0x47, 0xa2, 0x6d, 0x56, 0x95, 0xf9, 0x87, 0x43, 0x9f, 0xfe, 0x01, 0x01,
    0xec, 0xf1, 0x2f, 0x26
};

#endif // PERF_XMSS_DATA

struct {
    UINT32              algId;
    BOOL                isMultitree;
    PCBYTE              pbPrvkeyBlob;
    SIZE_T              cbPrvkeyBlob;
    PCBYTE              pbSignature;
    SIZE_T              cbSignature;
    PSYMCRYPT_XMSS_KEY  pKey;
} CONCAT2(g_XmssKeys, ImpXxx)[] = {

    {
        SYMCRYPT_XMSS_SHA2_10_256,
        FALSE,
        g_XmsskeySha2_10_256,
        sizeof(g_XmsskeySha2_10_256),
        g_XmssSigSha2_10_256,
        sizeof(g_XmssSigSha2_10_256),
        nullptr
    },
    {
        SYMCRYPT_XMSS_SHA2_16_256,
        FALSE,
        g_XmsskeySha2_16_256,
        sizeof(g_XmsskeySha2_16_256),
        g_XmssSigSha2_16_256,
        sizeof(g_XmssSigSha2_16_256),
        nullptr
    },
    {
        SYMCRYPT_XMSS_SHA2_20_256,
        FALSE,
        g_XmsskeySha2_20_256,
        sizeof(g_XmsskeySha2_20_256),
        g_XmssSigSha2_20_256,
        sizeof(g_XmssSigSha2_20_256),
        nullptr
    },
    {
        SYMCRYPT_XMSS_SHA2_10_512,
        FALSE,
        g_XmsskeySha2_10_512,
        sizeof(g_XmsskeySha2_10_512),
        g_XmssSigSha2_10_512,
        sizeof(g_XmssSigSha2_10_512),
        nullptr
    },
    {
        SYMCRYPT_XMSS_SHAKE256_10_256,
        FALSE,
        g_XmsskeyShake256_10_256,
        sizeof(g_XmsskeyShake256_10_256),
        g_XmssSigShake256_10_256,
        sizeof(g_XmssSigShake256_10_256),
        nullptr
    },

};

template<>
void
SetupSymCryptXmsskey<ImpXxx>(UINT32 algId)
{
    SYMCRYPT_ERROR          scError = SYMCRYPT_NO_ERROR;
    SYMCRYPT_XMSS_PARAMS    params;
    BOOL bFound = FALSE;

    for (int i = 0; i < ARRAY_SIZE(CONCAT2(g_XmssKeys, ImpXxx)); i++)
    {
        if (algId == CONCAT2(g_XmssKeys, ImpXxx)[i].algId)
        {
            bFound = TRUE;

            if (CONCAT2(g_XmssKeys, ImpXxx)[i].pKey == nullptr)
            {
                scError = ScDispatchSymCryptXmssParamsFromAlgId((SYMCRYPT_XMSS_ALGID)algId, &params);
                CHECK(scError == SYMCRYPT_NO_ERROR, "?");

                CONCAT2(g_XmssKeys, ImpXxx)[i].pKey = ScDispatchSymCryptXmsskeyAllocate(&params, 0);
                CHECK(CONCAT2(g_XmssKeys, ImpXxx)[i].pKey != nullptr, "?");

                scError = ScDispatchSymCryptXmsskeySetValue(
                    CONCAT2(g_XmssKeys, ImpXxx)[i].pbPrvkeyBlob,
                    CONCAT2(g_XmssKeys, ImpXxx)[i].cbPrvkeyBlob,
                    SYMCRYPT_XMSSKEY_TYPE_PRIVATE,
                    0,
                    CONCAT2(g_XmssKeys, ImpXxx)[i].pKey);
                CHECK(scError == SYMCRYPT_NO_ERROR, "?");
            }

            break;
        }
    }

    CHECK(bFound == TRUE, "?");
}

template<>
VOID
algImpKeyPerfFunction< ImpXxx, AlgXmss>(PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T keySize)
{
    UNREFERENCED_PARAMETER(buf1);
    UNREFERENCED_PARAMETER(buf2);
    UNREFERENCED_PARAMETER(buf3);
    UNREFERENCED_PARAMETER(keySize);

    UINT32 algId = (UINT32)keySize;
    SetupSymCryptXmsskey<ImpXxx>(algId);
}

template<>
VOID
algImpDataPerfFunction<ImpXxx, AlgXmss>(PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize)
{
    UNREFERENCED_PARAMETER(buf1);
    UNREFERENCED_PARAMETER(buf2);
    UNREFERENCED_PARAMETER(buf3);
    UNREFERENCED_PARAMETER(dataSize);
}

template<>
VOID
algImpDecryptPerfFunction<ImpXxx, AlgXmss>(PBYTE buf1, PBYTE buf2, PBYTE buf3, SIZE_T dataSize)
{
    UNREFERENCED_PARAMETER(buf1);
    UNREFERENCED_PARAMETER(buf2);
    UNREFERENCED_PARAMETER(buf3);

    SYMCRYPT_ERROR scError;
    UINT32 algId = (UINT32)dataSize;
    BOOL bFound = FALSE;
    static const BYTE msg[] = { 0x61, 0x62, 0x63 };

    for (int i = 0; i < ARRAY_SIZE(CONCAT2(g_XmssKeys, ImpXxx)); i++)
    {
        if (algId == CONCAT2(g_XmssKeys, ImpXxx)[i].algId)
        {
            bFound = TRUE;

            scError = ScDispatchSymCryptXmssVerify(
                CONCAT2(g_XmssKeys, ImpXxx)[i].pKey,
                msg,
                sizeof(msg),
                0,
                CONCAT2(g_XmssKeys, ImpXxx)[i].pbSignature,
                CONCAT2(g_XmssKeys, ImpXxx)[i].cbSignature);

            CHECK(scError == SYMCRYPT_NO_ERROR, "?");

            break;
        }
    }

    CHECK(bFound == TRUE, "?");
}

template<>
VOID
algImpCleanPerfFunction<ImpXxx, AlgXmss>(PBYTE buf1, PBYTE buf2, PBYTE buf3)
{
    UNREFERENCED_PARAMETER(buf1);
    UNREFERENCED_PARAMETER(buf2);
    UNREFERENCED_PARAMETER(buf3);
}

template<>
XmssImp< ImpXxx, AlgXmss >::XmssImp()
{
    m_perfKeyFunction = &algImpKeyPerfFunction  <ImpXxx, AlgXmss>;
    m_perfDataFunction = nullptr;
    m_perfDecryptFunction = &algImpDecryptPerfFunction<ImpXxx, AlgXmss>;
    m_perfCleanFunction = &algImpCleanPerfFunction<ImpXxx, AlgXmss>;

    state.pKey = nullptr;
}

template<>
XmssImp<ImpXxx, AlgXmss>::~XmssImp()
{
    if (state.pKey != nullptr)
    {
        ScDispatchSymCryptXmsskeyFree(state.pKey);
        state.pKey = nullptr;
    }

    // Free initialized keys used in perf tests
    for (int i = 0; i < ARRAY_SIZE(CONCAT2(g_XmssKeys, ImpXxx)); i++)
    {
        if (CONCAT2(g_XmssKeys, ImpXxx)[i].pKey != nullptr)
        {
            ScDispatchSymCryptXmsskeyFree(CONCAT2(g_XmssKeys, ImpXxx)[i].pKey);
            CONCAT2(g_XmssKeys, ImpXxx)[i].pKey = nullptr;
        }
    }

}

template<>
NTSTATUS XmssImp<ImpXxx, AlgXmss>::setKey(
    _In_                    UINT32  uAlgId,
                            BOOL    fMultitree,
    _In_reads_bytes_(cbSrc) PCBYTE  pbSrc,
                            SIZE_T  cbSrc,
                            BOOL    fVerify)
{
    NTSTATUS status = STATUS_SUCCESS;
    SYMCRYPT_XMSS_PARAMS params;
    SYMCRYPT_ERROR scError;
    SIZE_T cbPublicKey;
    SIZE_T cbPrivateKey;
    SYMCRYPT_XMSSKEY_TYPE keyType = SYMCRYPT_XMSSKEY_TYPE_NONE;

    if (state.pKey != nullptr)
    {
        ScDispatchSymCryptXmsskeyFree(state.pKey);
        state.pKey = nullptr;
    }

    if (fMultitree)
    {
        ScDispatchSymCryptXmssMtParamsFromAlgId((SYMCRYPT_XMSSMT_ALGID)uAlgId, &params);
    }
    else
    {
        ScDispatchSymCryptXmssParamsFromAlgId((SYMCRYPT_XMSS_ALGID)uAlgId, &params);
    }

    state.pKey = ScDispatchSymCryptXmsskeyAllocate(&params, 0);
    CHECK3(state.pKey != NULL, "Cannot allocate XMSS key for algid = %u", uAlgId);

    scError = ScDispatchSymCryptXmssSizeofKeyBlobFromParams(&params, SYMCRYPT_XMSSKEY_TYPE_PUBLIC, &cbPublicKey);
    CHECK(scError == SYMCRYPT_NO_ERROR, "?");
    if(cbSrc == cbPublicKey)
    {
        keyType = SYMCRYPT_XMSSKEY_TYPE_PUBLIC;
    }

    scError = ScDispatchSymCryptXmssSizeofKeyBlobFromParams(&params, SYMCRYPT_XMSSKEY_TYPE_PRIVATE, &cbPrivateKey);
    CHECK(scError == SYMCRYPT_NO_ERROR, "?");
    if(cbSrc == cbPrivateKey)
    {
        keyType = SYMCRYPT_XMSSKEY_TYPE_PRIVATE;
    }

    UINT32 flags = fVerify ? SYMCRYPT_FLAG_XMSSKEY_VERIFY_ROOT : 0;
    scError = ScDispatchSymCryptXmsskeySetValue(pbSrc, cbSrc, keyType, flags, state.pKey);
    CHECK3(scError == SYMCRYPT_NO_ERROR, "XMSS key initialization error for algid = %u", uAlgId);

    return status;
}

template<>
NTSTATUS XmssImp<ImpXxx, AlgXmss>::sign(
    _In_reads_bytes_(cbInput)       PCBYTE  pbInput,
                                    SIZE_T  cbInput,
    _Out_writes_bytes_(cbSignature) PBYTE   pbSignature,
                                    SIZE_T  cbSignature)
{
    NTSTATUS status = STATUS_SUCCESS;
    SYMCRYPT_ERROR scError;

    scError = ScDispatchSymCryptXmssSign(state.pKey, pbInput, cbInput, 0, pbSignature, cbSignature);
    CHECK(scError == SYMCRYPT_NO_ERROR, "Xmss signing error");

    return status;
}


template<>
NTSTATUS XmssImp<ImpXxx, AlgXmss>::verify(
    _In_reads_bytes_(cbInput)       PCBYTE  pbInput,
                                    SIZE_T  cbInput,
    _In_reads_bytes_(cbSignature)   PCBYTE  pbSignature,
                                    SIZE_T  cbSignature)
{
    NTSTATUS status = STATUS_SUCCESS;
    SYMCRYPT_ERROR scError;

    scError = ScDispatchSymCryptXmssVerify(state.pKey, pbInput, cbInput, 0, pbSignature, cbSignature);

    switch (scError)
    {
    case SYMCRYPT_NO_ERROR:
        status = STATUS_SUCCESS;
        break;
    case SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE:
        status = STATUS_INVALID_SIGNATURE;
        break;
    case SYMCRYPT_INVALID_ARGUMENT:
        status = STATUS_INVALID_PARAMETER;
        break;
    default:
        iprint("Unexpected SymCrypt error %08x, %d, %d, %s\n", scError);
        CHECK(FALSE, "?");
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}
